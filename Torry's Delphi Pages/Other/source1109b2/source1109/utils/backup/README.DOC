*OVERVIEW*
TBackupTable is intended to allow backing up a database
*without* the need to shut down the server.  The idea is to
obtain a local copy of the data as quickly as possible.  Using a
local server and local FF tables was tried and was far too slow.

The fastest method is to simply copy the data buffer(s) to a
file.  Data is obtained with FFDbiGetRecordBatch when possible.
If the Table contains a BLOB field, then records are obtained
one by one, and BLOB(s) saved in a separate file.  These files
are much smaller than the FFD files, since they contain no
indexes, and are "packed" end to end.

Having obtained a local copy, you can compare the real database
with the copy.  If it is the same, you can be reasonably assured
that the copy has relational integrity, then ZIP it or whatever.

You can optionally copy the backup files to a second backup set.
Then continue on with the copy/compare/copy to second cycle.
The second backup set would then represent the last available
valid database.

TBackupTable is derived from TffTable (so has all its
properties, methods and events).  Some obvious "enhancements"
were avoided to keep it as simple as possible.  eg. automated
status displays, timed backups, logging.  These can be easily
done using events, and calling methods appropriately, or you
could derive a new component.

*PROPERTIES*
BackupDir:string - path to backup directory

BufSize:longint - default 10000 - size of the buffer used by
  GetRecordBatch.  NOTE: increasing this can diminish
  performance!

StopOnCopyFail:boolean - default true - exit the CopyDatabase
  method should something go wrong (eg. someone added a new
  record during the copy of a table).  There may be a good
  reason to set this to false, and thus obtain a copy at any
  cost.

TableList:TStringList - the list of Table Names to process.  eg.
  you could set this to a single Table, then call
  RestoreDatabase to just restore one table.  NOTE: no wild
  cards!  Suggest you use TableList.SaveToFile() and
  TableList.LoadFromFile() to maintain a list on disk.

*PUBLIC*
property CompareFailTable:string - the table name a compare failed on.
  May be used to determine further actions.

property Cancelled:boolean - will abort a Copy, Compare or Restore.
It should prove useful in conjunction with an engine monitor which
detects any changes in a database. The copy process could be resumed
in a more timely manner. As well, it would eliminate the need to do
a Compare.


*METHODS*
constructor Create(AOwner:TComponent); override;
  Sets up the TableList and sets defaults.

destructor Destroy; override;
  Frees TableList.

function CopyDatabase:boolean;
  Returns true if successful.  Possible reasons for failure -
  someone had locked the table, records were added or deleted
  during the copy of a table ie. RecordCount changed.  This
  method will immediately exit if StopOnCopyFail is true
  (default).  Files generated by the copy have file names as
  follows - TableName plus extension - the data dictionary is
  .DCT.  The data only is .DT1.  BLOBs use BL1.  The 1 means
  "primary backup".

function CompareDatabase:boolean;
  Returns true if the copied data is the same as the real
  database.

procedure CopyB1ToB2;
  Simply copies the "primary" set of backup files to a
  "secondary" set - having 2 at the end.  This would be useful
  if a continuous timed backup method was employed.  It may be
  useful when the database is highly volatile.

procedure CopyB2ToB1;
  Reverse of above, since restoring uses the "primary" set.

procedure RestoreDatabase;
  Hopefully does that, and is likely to take MUCH more time than
  backing up - possibly 100 X slower, depending on index
  structures.  It uses the .DCT files and the "primary" data
  files .DT1 and .BL1.  The tables will be created if they don't
  exist.

*EVENTS*
TCopyingEvent = procedure (Sender:TObject; TableNo,
                           Percent:integer) of object;

TCopyBeginEvent = procedure (Sender:TObject; TableNo:integer;
                             TableName:string) of object;

TEncryptEvent = procedure (Sender:TObject; TableNo:integer;
                           TableName:string;
                           IsBLOB:boolean;
                           var aBlock; aBlockLen : TffWord32) of object;

OnEncrypt:TEncryptEvent - called before saving data buffers to
  encrypt it.  Use IsBLOB to determine if you will encrypt BLOB
  fields.  NOTE: "severe" encryption diminishes the ability to
  compress the backup files.  Simple XOR encryption avoids this
  problem.

OnDecrypt:TEncryptEvent - the partner event.

OnTableCopying:TCopyingEvent - called periodically during the
  Copying of each table.  Use to update status information.

OnTableCopyBegin:TCopyBeginEvent - called at the start of each
  table copy.  Use to initiallise status.

OnTableComparing:TCopyingEvent - Use the same as copying.

OnTableCompareBegin:TCopyBeginEvent - Use the same as copying.

OnFileB1ToB2Begin:TCopyBeginEvent - called at the start of each
  table copy to the B2 set.

OnFileB2ToB1Begin:TCopyBeginEvent - as above in reverse.

OnTableRestoring:TCopyingEvent - use the same as copying.

OnTableRestoreBegin:TCopyBeginEvent - use the same as copying.

*USING IT*
Set the BackupDir property to an appropriate directory for the
backup files.  It will be created if not existing.

Set the DatabaseName appropriately.

Add the Table Names to the TableList (TStringList).  You could
use Session.GetTableNames() to do this.

Call the appropriate method. eg. CopyDatabase;

If you are sure you have a good copy at this stage, you could
simply ZIP the files to a floppy.

If your database is volatile, you could try this...
Retries:=0;
repeat
  OK:=CopyDatabase;
  if OK then OK:=CompareDatabase;
  inc(Retries);
until OK or (Retries>X);
if OK then ZIPToFloppy else showmessage('backup failed');

And a loop for continuous backing up!!!

Cancelled:=false;
repeat
  repeat
    OK:=CopyDatabase;
    if OK then OK:=CompareDatabase;
  until OK or Cancelled;
  if OK the CopyB1ToB2;{the B2 set is now the most recent valid data}
until Cancelled;

Not yet sure how to get at the B2 files during the above process???

*FF1 version* is in FF1Vers.ZIP. It is included for anyone wanting to
convert data between FF1 and FF2 and back.

*FEEDBACK*
Any improvements, suggestions, bugs found, use made of this etc. to...

Ian Peck
ianpeck@netconnect.com.au
