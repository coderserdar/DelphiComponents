Unit fssql;

{==============================================================================
FSSQL
0.0.0.103
Date of Generation: 28/04/2005
Comment:
Author: Krzysztof Winnicki
Copyright:

This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
this file that you edit manually will be over-written when the file is
regenerated.
==============================================================================}

Interface
Uses SysUtils,
  Classes,
  fscocobase,
  fssqldef,
  fssqldb,
  Dialogs,
  fsfuninterp,
  fsllbase,
  fsstdate;

Const
  fsmaxT = 200;
Type
  fsSymbolSet = Array[0..fsmaxT Div setsize] Of TBitSet;

  EFSSQL = Class(Exception);
  TfsSql = Class;

  TfsSqlScanner = Class(TCocoRScanner)
  Private
    FOwner: TfsSql;
    Function CharInIgnoreSet(Const Ch: char): boolean;
    Procedure CheckLiteral(Var Sym: Integer);
    Function Equal(s: String): boolean;
    Function Comment: boolean;
  Protected
    Procedure NextCh; Override;
  Public
    Constructor Create;

    Procedure Get(Var sym: Integer; TableN: boolean = False); Override; // Gets next symbol from source file

    Property CurrentSymbol;
    Property NextSymbol;
    Property OnStatusUpdate;
    Property Owner: TfsSql Read fOwner Write fOwner;
    Property ScannerError;
    Property SrcStream;
  End; { TfsSqlScanner }

  TfsSql = Class(TCocoRGrammar)
  Private
    { strictly internal variables }
    symSet: Array[0..7] Of fsSymbolSet; // symSet[0] = allSyncSyms
    Function GetBuildDate: TDateTime;
    Function GetVersion: String;
    Function GetVersionStr: String;
    Procedure SetVersion(Const Value: String);
    Function GetVersionInfo: String;
    Function _In(Var s: fsSymbolSet; x: Integer): boolean;
    Procedure InitSymSet;

    {Production methods}
    Procedure _SimpleAlias(Var TableRef: TfsSqlTableRef);
    Procedure _BooleanLiteral(Parent: TfsSqlNode; Var BooleanLiteral: TfsSqlBooleanLiteral);
    Procedure _IntervalLiteral(Parent: TfsSqlNode;
      Var IntervalLiteral: TfsSqlIntervalLiteral);
    Procedure _TimestampLiteral(Parent: TfsSqlNode;
      Var TimestampLiteral: TfsSqlTimestampLiteral; Value: String = '');
    Procedure _TimeLiteral(Parent: TfsSqlNode;
      Var TimeLiteral: TfsSqlTimeLiteral; Value: String = '');
    Procedure _DateLiteral(Parent: TfsSqlNode;
      Var DateLiteral: TfsSqlDateLiteral; Value: String = '');
    Procedure _StringLiteral(Parent: TfsSqlNode;
      Var StringLiteral: TfsSqlStringLiteral; Value: String);
    Procedure _IntegerLiteral(Parent: TfsSqlNode;
      Var IntegerLiteral: TfsSqlIntegerLiteral; Value: String);
    Procedure _Integer64Literal(Parent: TfsSqlNode;
      Var Integer64Literal: TfsSqlInteger64Literal; Value: String);
    Procedure _FloatLiteral(Parent: TfsSqlNode;
      Var FloatLiteral: TfsSqlFloatLiteral);
    Procedure _WhenClause(Parent: TfsSqlNode;
      Var WhenClause: TfsSqlWhenClause);
    Procedure _WhenClauseList(Parent: TfsSqlNode;
      Var WhenClauseList: TfsSqlWhenClauseList);
    Procedure _CoalesceExpression(Parent: TfsSqlNode;
      Var CoalesceExp: TfsSqlCoalesceExpression);
    Procedure _CaseExpression(Parent: TfsSqlNode;
      Var CaseExp: TfsSqlCaseExpression);
    Procedure _ScalarFunction(Parent: TfsSqlNode;
      Var Func: TfsSqlScalarFunc);
    Procedure _Param(Parent: TfsSqlNode;
      Var Param: TfsSqlParam);
    Procedure _Literal(Parent: TfsSqlNode;
      Var Literal: TfsSqlLiteral);
    Procedure _Factor(Parent: TfsSqlNode;
      Var Factor: TfsSqlFactor;
      MulOp: TfsSqlMulOp);
    Procedure _Term(Parent: TfsSqlNode; Var Term: TfsSqlTerm; AddOp: TfsSqlAddOp);
    Procedure _SimpleExpressionList(Parent: TfsSqlNode;
      Var SimpleExpressionList: TfsSqlSimpleExpressionList);
    Procedure _IsTest(Parent: TfsSqlNode;
      Var IsTest: TfsSqlIsTest);
    Procedure _MatchClause(Parent: TfsSqlNode;
      Var MatchClause: TfsSqlMatchClause);
    Procedure _InClause(Parent: TfsSqlNode;
      Var InClause: TfsSqlInClause;
      Negated: Boolean);
    Procedure _LikeClause(Parent: TfsSqlNode;
      Var LikeClause: TfsSqlLikeClause;
      Negated: Boolean);
    Procedure _BetweenClause(Parent: TfsSqlNode;
      Var BetweenClause: TfsSqlBetweenClause;
      Negated: Boolean);
    Procedure _AllOrAnyClause(Parent: TfsSqlNode;
      Var AllOrAny: TfsSqlAllOrAnyClause);
    Procedure _UniqueClause(Parent: TfsSqlNode;
      Var Unique: TfsSqlUniqueClause);
    Procedure _ExistsClause(Parent: TfsSqlNode;
      Var Exists: TfsSqlExistsClause);
    Procedure _CondPrimary(Parent: TfsSqlNode;
      Var CondPrimary: TfsSqlCondPrimary);
    Procedure _CondFactor(Parent: TfsSqlNode;
      Var CondFactor: TfsSqlCondFactor);
    Procedure _CondTerm(Parent: TfsSqlNode;
      Var CondTerm: TfsSqlCondTerm);
    Procedure _GroupColumn(Parent: TfsSqlNode;
      Var Col: TfsSqlGroupColumn);
    Procedure _UnionGroupColumn(UnionParent: TfsSqlNode;
      Var Col: TfsSqlGroupColumn);
    Procedure _FieldRef(Parent: TfsSqlNode; Var FieldRef: TfsSqlFieldRef);
    Procedure _Aggregate(Parent: TfsSqlNode; Var Aggregate: TfsSqlAggregate);
    Procedure _Column(Parent: TfsSqlNode;
      Var Col: TfsSqlColumn);
    Procedure _ColumnAlias(Var Selection: TfsSqlSelection);
    Procedure _Selection(SelectionList: TfsSqlSelectionList);
    Procedure _OrderColumn(Parent: TfsSqlNode; Var Col: TfsSqlOrderColumn);
    Procedure _OrderItem(Parent: TfsSqlNode;
      Var OrderItem: TfsSqlOrderItem);
    Procedure _UnionOrderColumn(Parent: TfsSqlNode; Var Col: TfsSqlOrderColumn);
    Procedure _UnionOrderItem(Parent: TfsSqlNode;
      Var OrderItem: TfsSqlOrderItem);
    Procedure _UpdateItem(Parent: TfsSqlNode;
      Var UpdateItem: TfsSqlUpdateItem);
    Procedure _UpdateList(Parent: TfsSqlNode;
      Var UpdateList: TfsSqlUpdateList);
    Procedure _SimpleTableRef(Parent: TfsSqlNode; Var TableRef: TfsSqlTableRef);
    Procedure _SimpleExpression(Parent: TfsSqlNode;
      Var SimpleExpression: TfsSqlSimpleExpression);
    Procedure _ValueItem(Parent: TfsSqlNode;
      Var ValueItem: TfsSqlValueItem);
    Procedure _InsertItem(Parent: TfsSqlNode;
      Var InsertItem: TfsSqlInsertItem);
    Procedure _ValueList(Parent: TfsSqlNode;
      Var ValueList: TfsSqlValueList);
    Procedure _TableConstructor(Parent: TfsSqlNode; Var ValueList: TfsSqlValueList);
    Procedure _NonJoinTablePrimary(Parent: TfsSqlNode; Var NonJoinTablePrimary: TfsSqlNonJoinTablePrimary);
    Procedure _NonJoinTableTerm(Parent: TfsSqlNode; Var NonJoinTableTerm: TfsSqlNonJoinTableTerm);
    Procedure _UsingItem(Parent: TfsSqlNode;
      Var UsingItem: TfsSqlUsingItem);
    Procedure _UsingList(Parent: TfsSqlNode;
      Var UsingList: TfsSqlUsingList);
    Procedure _TableRef(Parent: TfsSqlNode; Var TableRef: TfsSqlTableRef);
    Procedure _NonJoinTableExp(Parent: TfsSqlNode; Var NonJoinTableExp: TfsSqlNonJoinTableExp);
    Procedure _JoinTableExp(Parent: TfsSqlNode; Const JoinTableExp: TfsSqlJoinTableExp);
    Procedure _SimpleTableRefOrParenTableExp(Parent: TfsSqlNode; Var TableRef: TfsSqlTableRef);
    Procedure _InsertColumnList(Parent: TfsSqlNode;
      Var InsertColumnList: TfsSqlInsertColumnList);
    Procedure _SQLName(Var aName: String; TableN: boolean = False);
    Procedure _OrderList(Parent: TfsSqlNode;
      Var OrderList: TfsSqlOrderList);
    Procedure _UnionOrderList(UnionParent: TfsSqlNode;
      Var UnionOrderList: TfsSqlOrderList);
    Procedure _GroupColumnList(Parent: TfsSqlNode;
      Var ColumnList: TfsSqlGroupColumnList);
    Procedure _UnionGroupColumnList(UnionParent: TfsSqlNode;
      Var ColumnList: TfsSqlGroupColumnList);
    Procedure _CondExp(Parent: TfsSqlNode;
      Var CondExp: TfsSqlCondExp);
    Procedure _TableRefList(Parent: TfsSqlNode;
      Var TableRefList: TfsSqlTableRefList);
    Procedure _SelectionList(Parent: TfsSqlSELECT; Var SelectionList: TfsSqlSelectionList);
    Procedure _SelectStatement(Parent: TfsSqlNode;
      Var Select: TfsSqlSELECT);
    Procedure _DeleteStatement(Parent: TfsSqlNode;
      Var DeleteSt: TfsSqlDELETE);
    Procedure _UpdateStatement(Parent: TfsSqlNode;
      Var UpdateSt: TfsSqlUPDATE);
    Procedure _InsertStatement(Parent: TfsSqlNode;
      Var InsertSt: TfsSqlINSERT);
    Procedure _TableExp(Parent: TfsSqlNode; Var TableExp: TfsSqlTableExp;
      CreateUnion: boolean = True);
    Procedure _FSSQL;

  Private
    FRootNode: TfsSqlStatement;
    FReservedWordList: TStringList;
    FAllowReservedWordNames: boolean;

    Procedure Init;
    Procedure Final;
    Procedure InitReservedWordList;

    Function CheckSQLName(Const SQLNameString: String): String;
    Function IsColumnList: Boolean;
    Function Matches(n: Integer): Boolean;
    Function IsSymbol(n: Integer): boolean; {mwr}

    Function IsParenNonJoinTableExp: Boolean;
    Function IsParenJoinTableExp: Boolean;
    Function IsParenTableExp: Boolean;
    Function IsNonJoinTableExp: Boolean;
    Function IsJoinTableExp: Boolean;
    Function IsTableExp: Boolean;
    Function IsTableRef: Boolean;

  Protected
    { Protected Declarations }
    Procedure Get(TableN: boolean = False); Override;
  Public
    { Public Declarations }
    Constructor Create(AOwner: TComponent); Override;
    Destructor Destroy; Override;

    Function ErrorStr(Const ErrorCode: Integer; Const Data: String): String; Override;
    Procedure Execute;
    Function GetScanner: TfsSqlScanner;
    Procedure Parse;

    Property ErrorList;
    Property ListStream;
    Property SourceStream;
    Property Successful;
    Property BuildDate: TDateTime Read GetBuildDate;
    Property VersionStr: String Read GetVersionStr;
    Property VersionInfo: String Read GetVersionInfo;

  Public
    Property RootNode: TfsSqlStatement Read FRootNode Write FRootNode;
    Property AllowReservedWordNames: boolean Read FAllowReservedWordNames Write FAllowReservedWordNames;

  Published
    { Published Declarations }
    Property AfterGet;
    Property AfterParse;
    Property AfterGenList;
    Property BeforeGenList;
    Property BeforeParse;
    Property ClearSourceStream;
    Property GenListWhen;
    Property SourceFileName;
    Property Version: String Read GetVersion Write SetVersion;

    Property OnCustomError;
    Property OnError;
    Property OnFailure;
    Property OnStatusUpdate;
    Property OnSuccess;
  End; { TfsSql }

Implementation

Const

  EOFSYMB = 0;
  IDENTSYM = 1;
  INTEGER_SYM = 2;
  FLOAT_SYM = 3;
  SQLSTRINGSYM = 4;
  SQLNAMESTRINGSYM = 5;
  NOINDEXSYM = 6;
  NOREDUCESYM = 7;
  _SEMICOLONSYM = 8;
  SELECTSYM = 9;
  ALLSYM = 10;
  DISTINCTSYM = 11;
  FROMSYM = 12;
  WHERESYM = 13;
  GROUPSYM = 14;
  BYSYM = 15;
  HAVINGSYM = 16;
  ORDERSYM = 17;
  INSERTSYM = 18;
  INTOSYM = 19;
  DEFAULTSYM = 20;
  VALUESSYM = 21;
  _LPARENSYM = 22;
  _RPARENSYM = 23;
  CROSSSYM = 24;
  JOINSYM = 25;
  NATURALSYM = 26;
  INNERSYM = 27;
  LEFTSYM = 28;
  OUTERSYM = 29;
  RIGHTSYM = 30;
  FULLSYM = 31;
  UNIONSYM = 32;
  ONSYM = 33;
  USINGSYM = 34;
  _COMMASYM = 35;
  TABLESYM = 36;
  NULLSYM = 37;
  DELETESYM = 38;
  UPDATESYM = 39;
  SETSYM = 40;
  _EQUALSYM = 41;
  ASCSYM = 42;
  DESCSYM = 43;
  _POINTSYM = 44;
  _STARSYM = 45;
  ASSYM = 46;
  COUNTSYM = 47;
  MINSYM = 48;
  MAXSYM = 49;
  SUMSYM = 50;
  AVGSYM = 51;
  ORSYM = 52;
  ANDSYM = 53;
  NOTSYM = 54;
  _LESS_EQUALSYM = 55;
  _LESSSYM = 56;
  _GREATERSYM = 57;
  _GREATER_EQUALSYM = 58;
  _LESS_GREATERSYM = 59;
  ANYSYM = 60;
  SOMESYM = 61;
  EXISTSSYM = 62;
  UNIQUESYM = 63;
  ISSYM = 64;
  TRUESYM = 65;
  FALSESYM = 66;
  UNKNOWNSYM = 67;
  BETWEENSYM = 68;
  LIKESYM = 69;
  ESCAPESYM = 70;
  IGNORESYM = 71;
  CASESYM = 72;
  INSYM = 73;
  MATCHSYM = 74;
  PARTIALSYM = 75;
  _PLUSSYM = 76;
  _MINUSSYM = 77;
  _BAR_BARSYM = 78;
  _SLASHSYM = 79;
  CHARACTER_UNDERSCORELENGTHSYM = 80;
  FLAGSSYM = 81;
  COALESCESYM = 82;
  CURRENT_UNDERSCOREDATESYM = 83;
  CURRENT_UNDERSCORETIMESYM = 84;
  CURRENT_UNDERSCORETIMESTAMPSYM = 85;
  CASTSYM = 86;
  USERSYM = 87;
  LOWERSYM = 88;
  UPPERSYM = 89;
  POSITIONSYM = 90;
  TOPSYM = 91;
  SUBSTRINGSYM = 92;
  FORSYM = 93;
  WEEKNOSYM = 94;
  TRIMSYM = 95;
  LEADINGSYM = 96;
  TRAILINGSYM = 97;
  BOTHSYM = 98;
  EXTRACTSYM = 99;
  YEARSYM = 100;
  MONTHSYM = 101;
  DAYSYM = 102;
  HOURSYM = 103;
  MINUTESYM = 104;
  SECONDSYM = 105;
  NULLIFSYM = 106;
  ABSSYM = 107;
  CEILINGSYM = 108;
  FLOORSYM = 109;
  EXPSYM = 110;
  LOGSYM = 111;
  POWERSYM = 112;
  RANDSYM = 113;
  ROUNDSYM = 114;
  ELSESYM = 115;
  ENDSYM = 116;
  WHENSYM = 117;
  THENSYM = 118;
  _QUERYSYM = 119;
  DATESYM = 120;
  TIMESYM = 121;
  TIMESTAMPSYM = 122;
  INTERVALSYM = 123;
  TOSYM = 124;

  // DATATYPE
  BOOLEANSYM = 125;
  SINGLECHARSYM = 126;
  SINGLEWIDECHARSYM = 127;
  BYTESYM = 128;
  WORD16SYM = 129;
  WORD32SYM = 130;
  INT8SYM = 131;
  INT16SYM = 132;
  INT32SYM = 133;
  INT64SYM = 134;
  AUTOINC32SYM = 135;
  AUTOINC64SYM = 136;
  SINGLESYM = 137;
  DOUBLESYM = 138;
  EXTENDEDSYM = 139;
  CURRENCYSYM = 140;
  BLOBSYM = 141;
  MEMOSYM = 142;
  GRAPHICSYM = 143;
  BYTEARRAYSYM = 144;
  SHORTSTRINGSYM = 145;
  VARNULLSTRINGSYM = 146;
  NULLSTRINGSYM = 147;
  VARWIDESTRINGSYM = 148;
  WIDESTRINGSYM = 149;
  RECVERSIONSYM = 150;
  BCDSYM = 153; // fstBcd  //NUMERIC, DECIMAL DEC
  CLOBSYM = 154; // fstClob  //CLOB TEXT  - Clob
  WIDECLOBSYM = 155; //fstWideClob
  INTARRAYSYM = 156;
  DOUBLEARRAYSYM = 157;
  WORDARRAYSYM = 158;

  PERCENTSYM = 159;
  STARTFROMSYM = 160;
  DOWNSYM = 161;
  TOPDOWNSYM = 162;
  CENTERSYM = 163;
  TOPCENTERDOWNSYM = 164;
  TOPCENTERSYM = 165;
  CENTERDOWNSYM = 166;
  DIVBYSYM = 167;
  ATFIRSTSYM = 168;

  SELECTTREESYM = 169;
  SELECTTREEPATHSYM = 170;
  PLANSYM = 171; // FOR PLANING USED INDEX
  DIVSYM = 172;
  MODSYM = 173;
  ODDSYM = 174;

  ONLINESYM = 175;
  FIRSTSYM = 176;
  INDEXNAMESYM = 177;
  COMMITBYSYM = 178;
  ORDERUNIONSYM = 179;
  ARRAYSYM = 180;

  LASTAUTOINCSYM = 181; // for database
  NEXTAUTOINCSYM = 182; // next value
  READLASTAUTOINCSYM = 183; // read last value
  ISRECORDLOCKEDSYM = 184;

  ISUNDELETEDRECORDSYM = 185;
  ISPROTECTDELETERECORDSYM = 186;
  ISPROTECTUPDATERECORDSYM = 187;
  ISMARKASBADRECORDSYM = 188;
  GROUPUNIONSYM = 189;

  { LARGESYMSYM = 151;
   OBJECTSYM = 152;
   VARYINGSYM = 190;
   NATIONALSYM = 191;
   BINARYSYM = 192;  }

  CREATESYM = 193;
  VIEWSYM = 194;
  ALTERSYM = 195;
  DROPSYM = 196;
  INDEXSYM = 197;
  ASSERTSYM = 198;
  TRIGGERSYM = 199;
  FOREGEINSYM = 200;

  // ..205

  NOSYMB = 200;
  _NOSYM = NOSYMB; {ERROR TOKEN CODE}

  { --------------------------------------------------------------------------- }

Procedure TfsSql.InitReservedWordList;
Begin
  FReservedWordList.Add('ABS');
  FReservedWordList.Add('ALL');
  FReservedWordList.Add('AND');
  FReservedWordList.Add('ANY');
  FReservedWordList.Add('AS');
  FReservedWordList.Add('ASC');
  FReservedWordList.Add('AVG');
  FReservedWordList.Add('BETWEEN');
  FReservedWordList.Add('BOTH');
  FReservedWordList.Add('BY');
  FReservedWordList.Add('CASE');
  FReservedWordList.Add('CEILING'); {!!.11}
  FReservedWordList.Add('CHARACTER_LENGTH');
  FReservedWordList.Add('CHAR_LENGTH');
  FReservedWordList.Add('FLAGS');
  FReservedWordList.Add('COALESCE');
  FReservedWordList.Add('COUNT');
  FReservedWordList.Add('CROSS');
  FReservedWordList.Add('CURRENT_DATE');
  FReservedWordList.Add('CURRENT_TIME');
  FReservedWordList.Add('CURRENT_TIMESTAMP');
  FReservedWordList.Add('CURRENT_USER');
  FReservedWordList.Add('DATE');
  FReservedWordList.Add('DAY');
  FReservedWordList.Add('DEFAULT');
  FReservedWordList.Add('DELETE');
  FReservedWordList.Add('DESC');
  FReservedWordList.Add('DISTINCT');
  FReservedWordList.Add('ELSE');
  FReservedWordList.Add('END');
  FReservedWordList.Add('EXP'); {!!.11}
  FReservedWordList.Add('ESCAPE');
  FReservedWordList.Add('EXISTS');
  FReservedWordList.Add('EXTRACT');
  FReservedWordList.Add('FALSE');
  FReservedWordList.Add('FLOOR'); {!!.11}
  FReservedWordList.Add('FOR');
  FReservedWordList.Add('FROM');
  FReservedWordList.Add('FULL');
  FReservedWordList.Add('GROUP');
  FReservedWordList.Add('GROUPUNION');
  FReservedWordList.Add('HAVING');
  FReservedWordList.Add('HOUR');
  FReservedWordList.Add('IN');
  FReservedWordList.Add('INNER');
  FReservedWordList.Add('INSERT');
  FReservedWordList.Add('INTERVAL');
  FReservedWordList.Add('IS');
  FReservedWordList.Add('JOIN');
  FReservedWordList.Add('LEADING');
  FReservedWordList.Add('LEFT');
  FReservedWordList.Add('LIKE');
  FReservedWordList.Add('LOG'); {!!.11}
  FReservedWordList.Add('LOWER');
  FReservedWordList.Add('MATCH');
  FReservedWordList.Add('MAX');
  FReservedWordList.Add('MIN');
  FReservedWordList.Add('MINUTE');
  FReservedWordList.Add('MONTH');
  FReservedWordList.Add('NOINDEX');
  FReservedWordList.Add('NOREDUCE');
  FReservedWordList.Add('NOT');
  FReservedWordList.Add('NULL');
  FReservedWordList.Add('NULLIF');
  FReservedWordList.Add('OR');
  FReservedWordList.Add('ORDER');
  FReservedWordList.Add('ORDERUNION');
  FReservedWordList.Add('OUTER');
  FReservedWordList.Add('PARTIAL');
  FReservedWordList.Add('POSITION');
  FReservedWordList.Add('POWER'); {!!.11}
  FReservedWordList.Add('RAND'); {!!.11}
  FReservedWordList.Add('RIGHT');
  FReservedWordList.Add('ROUND'); {!!.11}
  FReservedWordList.Add('SECOND');
  FReservedWordList.Add('SELECT');
  //FReservedWordList.Add( 'SOUNDEX' );
  FReservedWordList.Add('SET');
  FReservedWordList.Add('SOME');
  FReservedWordList.Add('SUBSTRING');
  FReservedWordList.Add('SUM');
  FReservedWordList.Add('TABLE');
  FReservedWordList.Add('THEN');
  FReservedWordList.Add('TIME');
  FReservedWordList.Add('TIMESTAMP');
  FReservedWordList.Add('TO');
  FReservedWordList.Add('TRAILING');
  FReservedWordList.Add('TRIM');
  FReservedWordList.Add('TRUE');
  FReservedWordList.Add('UNIQUE');
  FReservedWordList.Add('UNKNOWN');
  FReservedWordList.Add('UPDATE');
  FReservedWordList.Add('UPPER');
  FReservedWordList.Add('USER');
  FReservedWordList.Add('USING');
  FReservedWordList.Add('VALUES');
  FReservedWordList.Add('WEEKNO');
  FReservedWordList.Add('WHEN');
  FReservedWordList.Add('WHERE');
  FReservedWordList.Add('YEAR');
  FReservedWordList.Add('CAST');
  FReservedWordList.Add('STARTPOSITION');
  FReservedWordList.Add('PERCENT');
  FReservedWordList.Add('TOP');
  FReservedWordList.Add('DOWN');

  FReservedWordList.Add('BOOLEAN');
  FReservedWordList.Add('SINGLECHAR');
  FReservedWordList.Add('SINGLEWIDECHAR');
  FReservedWordList.Add('BYTY');
  FReservedWordList.Add('WORD16');
  FReservedWordList.Add('WORD32');
  FReservedWordList.Add('UINT8');
  FReservedWordList.Add('UIN16');
  FReservedWordList.Add('UIN32');
  FReservedWordList.Add('INT8');
  FReservedWordList.Add('INT16');
  FReservedWordList.Add('INT32');
  FReservedWordList.Add('INT64');
  FReservedWordList.Add('AUTOINC32');
  FReservedWordList.Add('AUTOINC64');
  FReservedWordList.Add('SINGLE');
  FReservedWordList.Add('DOUBLE');
  FReservedWordList.Add('EXTENDED');
  FReservedWordList.Add('CURRENCY');
  FReservedWordList.Add('DATETIME');
  FReservedWordList.Add('BLOB');
  FReservedWordList.Add('MEMO');
  FReservedWordList.Add('GRAPHIC');
  FReservedWordList.Add('ARRAYUINT8');
  FReservedWordList.Add('ARRAYUINT16');
  FReservedWordList.Add('SHORTSTRING');
  FReservedWordList.Add('NULLSTRING');
  FReservedWordList.Add('WIDESTRING');

  // SYNONIM DATA
  FReservedWordList.Add('CHAR');
  FReservedWordList.Add('CHARAKTER');
  FReservedWordList.Add('NCHAR');
  FReservedWordList.Add('NSINGLECHAR');
  FReservedWordList.Add('MONEY');
  FReservedWordList.Add('IMAGE');
  FReservedWordList.Add('REAL');
  FReservedWordList.Add('FLOAT');
  FReservedWordList.Add('INT');
  FReservedWordList.Add('INTEGER');
  FReservedWordList.Add('WORD');
  FReservedWordList.Add('DWORD');
  FReservedWordList.Add('LARGEINT');
  FReservedWordList.Add('BIGINT');
  FReservedWordList.Add('TINYINT');
  FReservedWordList.Add('SHORTINT');

  FReservedWordList.Add('CLOB');
  FReservedWordList.Add('TEXT');
  FReservedWordList.Add('NUMERIC');
  FReservedWordList.Add('DECIMAL');
  FReservedWordList.Add('DEC');
  FReservedWordList.Add('BCD');
  FReservedWordList.Add('VARNULLSTRING');
  FReservedWordList.Add('VARWIDESTRING');
  FReservedWordList.Add('VARCHAR');
  FReservedWordList.Add('NVARCHAR');
  FReservedWordList.Add('BINARY');
  FReservedWordList.Add('NATIONAL');
  FReservedWordList.Add('VARYING');
  FReservedWordList.Add('OBJECT');
  FReservedWordList.Add('ARRAYINT32');
  FReservedWordList.Add('ARRAYDOUBLE');

  FReservedWordList.Add('LARGE');
  FReservedWordList.Add('LIMITOPEN');

  FReservedWordList.Add('TOPDOWN');
  FReservedWordList.Add('CENTER');
  FReservedWordList.Add('TOPCENTERDOWN');
  FReservedWordList.Add('TOPCENTER');
  FReservedWordList.Add('CENTERDOWN');
  FReservedWordList.Add('DIVBY');
  FReservedWordList.Add('ATFIRST');
  FReservedWordList.Add('SELECTTREE');
  FReservedWordList.Add('SELECTTREEPATH');
  FReservedWordList.Add('PLAN');
  FReservedWordList.Add('DIV');
  FReservedWordList.Add('MOD');
  FReservedWordList.Add('ODD');
  FReservedWordList.Add('ONLINE');
  FReservedWordList.Add('FIRST');
  FReservedWordList.Add('USEINDEX');
  FReservedWordList.Add('COMMITBY');

  FReservedWordList.Add('ARRAY');
  FReservedWordList.Add('INSERTROW'); // INSERTROW(POSITION,LIST VALUES)
  FReservedWordList.Add('ADDROW'); // ADDROW(LIST VALUES)
  FReservedWordList.Add('LASTAUTOINC');
  FReservedWordList.Add('NEXTAUTOINC');
  FReservedWordList.Add('READLASTAUTOINC');
  FReservedWordList.Add('ISRECORDLOCKED');
  FReservedWordList.Add('ISUNDELETEDRECORD');
  FReservedWordList.Add('ISPROTECTDELETERECORD');
  FReservedWordList.Add('ISPROTECTUPDATERECORD');
  FReservedWordList.Add('ISMARKASBADRECORD');

  FReservedWordList.Sorted := True;
End;

Procedure TfsSql.Init;
Begin
  fRootNode := TfsSqlStatement.Create;
  fRootNode.UseIndex := True;
  fRootNode.Reduce := True;
  InitReservedWordList;
End;

Procedure TfsSql.Final;
Begin
  If successful And fRootNode.Reduce Then
    fRootNode.ReduceStrength;
End;

Function TfsSql.CheckSQLName(Const SQLNameString: String): String;
Var
  Idx: Integer;
Begin
  Result := copy(SQLNameString, 2, length(SQLNameString) - 2);
  If Not fAllowReservedWordNames
    And fReservedWordList.Find(UpperCase(Result), Idx) Then
    SemError(303, Result);
End;

Function TfsSql.IsSymbol(n: Integer): boolean;
Begin
  If CurrentInputSymbol = n Then
    Result := True
  Else
    Result := False;
End;

Function TfsSql.Matches(n: Integer): boolean;
Begin
  Result := IsSymbol(n);
  If Result Then
    Get;
End; {Expect}

Function TfsSql.IsColumnList: boolean;
Var
  BS: String;
Begin
  Result := False;
  BS := Bookmark;
  Try
    If Not Matches(_lparenSym) Then
      Exit;
    If Not Matches(identSym)
      And Not Matches(SQLNameStringSym) Then
      Exit;
    While (fCurrentInputSymbol = _commaSym) Do
      Begin
        Get;
        If Not Matches(identSym)
          And Not Matches(SQLNameStringSym) Then
          Exit;
      End;
    If Not Matches(_rparenSym) Then
      Exit;
    Result := True;
  Finally
    GotoBookmark(BS);
  End;
End;

Function TfsSql.IsParenNonJoinTableExp: boolean;
Var
  BS: String;
Begin
  Result := False;
  BS := Bookmark;
  Try
    If Not Matches(_lparenSym) Then
      Exit;
    If Not IsParenNonJoinTableExp
      And Not (fCurrentInputSymbol In [SELECTsym, TABLEsym, VALUESsym]) Then
      Exit;
    Result := True;
  Finally
    GotoBookmark(BS);
  End;
End;

Function TfsSql.IsNonJoinTableExp: boolean;
Var
  BS: String;
Begin
  Result := False;
  BS := Bookmark;
  Try
    If Not IsParenNonJoinTableExp
      And Not (fCurrentInputSymbol In [SELECTsym, TABLEsym, VALUESsym]) Then
      Exit;
    Result := True;
  Finally
    GotoBookmark(BS);
  End;
End;

Function TfsSql.IsTableRef: boolean;
Begin
  Result := False;
  If (fCurrentInputSymbol = identSym) Or
    (fCurrentInputSymbol = SQLNameStringSym) Then
    Begin
      Get;
      If (fCurrentInputSymbol = _pointSym) Then
        Begin
          Get;
          Get;
        End;
      Result := True;
    End;
End;

Function TfsSql.IsParenJoinTableExp: boolean;
Var
  BS: String;
Begin
  Result := False;
  BS := Bookmark;
  Try
    If Not Matches(_lparenSym) Then
      Exit;
    If Not IsTableRef Then
      Exit;
    If Not (fCurrentInputSymbol In [CROSSSym, NATURALSym, INNERSym, LEFTSym, RIGHTSym, FULLSym,
      //UNIONSym,
      JOINSym]) Then
      Exit;
    Result := True;
  Finally
    GotoBookmark(BS);
  End;
End;

Function TfsSql.IsJoinTableExp: boolean;
Var
  BS: String;
Begin
  Result := False;
  BS := Bookmark;
  Try
    If Not IsTableRef Then
      Exit;
    If IsSymbol(ASSym) Then
      Get;
    If IsSymbol(identSym) Then
      Get;
    If Not (fCurrentInputSymbol In [CROSSSym, NATURALSym, INNERSym, LEFTSym, RIGHTSym, FULLSym,
      //UNIONSym,
      JOINSym]) Then
      Exit;
    Result := True;
  Finally
    GotoBookmark(BS);
  End;
End;

Function TfsSql.IsParenTableExp: boolean;
Begin
  Result := IsParenNonJoinTableExp Or IsParenJoinTableExp;
End;

Function TfsSql.IsTableExp: boolean;
Begin
  Result := IsNonJoinTableExp Or IsJoinTableExp Or IsParenTableExp;
End;

(* End of Arbitrary Code *)

{ --------------------------------------------------------------------------- }
{ ---- implementation for TfsSqlScanner ---- }

Procedure TfsSqlScanner.NextCh;
{ Return global variable ch }
Begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  SrcStream.Seek(BufferPosition, soFromBeginning);
  CurrInputCh := CurrentCh(BufferPosition);
  If (CurrInputCh = _EL) Or ((CurrInputCh = _LF) And (LastInputCh <> _EL)) Then
    Begin
      CurrLine := CurrLine + 1;
      If Assigned(OnStatusUpdate) Then
        OnStatusUpdate(Owner, cstLineNum, '', CurrLine);
      StartOfLine := BufferPosition;
    End
End; {NextCh}

Function TfsSqlScanner.Comment: boolean;
Var
  level: Integer;
  startLine: Integer;
  oldLineStart: Longint;
  CommentStr: String;
Begin
  level := 1;
  startLine := CurrLine;
  oldLineStart := StartOfLine;
  CommentStr := CharAt(BufferPosition);
  //Result := false;
  If (CurrInputCh = '/') Then
    Begin
      NextCh;
      CommentStr := CommentStr + CharAt(BufferPosition);
      If (CurrInputCh = '/') Then
        Begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
          While True Do
            Begin
              If (CurrInputCh = CHR(13)) Then
                Begin
                  level := level - 1;
                  NumEOLInComment := CurrLine - startLine;
                  NextCh;
                  CommentStr := CommentStr + CharAt(BufferPosition);
                  If level = 0 Then
                    Begin
                      Result := True;
                      Exit;
                    End;
                End
              Else If CurrInputCh = _EF Then
                Begin
                  Result := False;
                  Exit;
                End
              Else
                Begin
                  NextCh;
                  CommentStr := CommentStr + CharAt(BufferPosition);
                End;
            End; { WHILE TRUE }
        End
      Else
        Begin
          If (CurrInputCh = _CR) Or (CurrInputCh = _LF) Then
            Begin
              CurrLine := CurrLine - 1;
              StartOfLine := oldLineStart
            End;
          BufferPosition := BufferPosition - 1;
          CurrInputCh := LastInputCh;
          //Result := false;
        End;
    End;
  //Result := false;
  If (CurrInputCh = '-') Then
    Begin
      NextCh;
      CommentStr := CommentStr + CharAt(BufferPosition);
      If (CurrInputCh = '-') Then
        Begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
          While True Do
            Begin
              If (CurrInputCh = CHR(13)) Then
                Begin
                  level := level - 1;
                  NumEOLInComment := CurrLine - startLine;
                  NextCh;
                  CommentStr := CommentStr + CharAt(BufferPosition);
                  If level = 0 Then
                    Begin
                      Result := True;
                      Exit;
                    End;
                End
              Else If CurrInputCh = _EF Then
                Begin
                  Result := False;
                  Exit;
                End
              Else
                Begin
                  NextCh;
                  CommentStr := CommentStr + CharAt(BufferPosition);
                End;
            End; { WHILE TRUE }
        End
      Else
        Begin
          If (CurrInputCh = _CR) Or (CurrInputCh = _LF) Then
            Begin
              CurrLine := CurrLine - 1;
              StartOfLine := oldLineStart
            End;
          BufferPosition := BufferPosition - 1;
          CurrInputCh := LastInputCh;
          //Result := false;
        End;
    End;
  Result := False;
  If (CurrInputCh = '/') Then
    Begin
      NextCh;
      CommentStr := CommentStr + CharAt(BufferPosition);
      If (CurrInputCh = '*') Then
        Begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
          While True Do
            Begin
              If (CurrInputCh = '*') Then
                Begin
                  NextCh;
                  CommentStr := CommentStr + CharAt(BufferPosition);
                  If (CurrInputCh = '/') Then
                    Begin
                      level := level - 1;
                      NextCh;
                      CommentStr := CommentStr + CharAt(BufferPosition);
                      If level = 0 Then
                        Begin
                          Result := True;
                          Exit;
                        End
                    End
                End
              Else If (CurrInputCh = '/') Then
                Begin
                  NextCh;
                  CommentStr := CommentStr + CharAt(BufferPosition);
                  If (CurrInputCh = '*') Then
                    Begin
                      level := level + 1;
                      NextCh;
                      CommentStr := CommentStr + CharAt(BufferPosition);
                    End
                End
              Else If CurrInputCh = _EF Then
                Begin
                  Result := False;
                  Exit;
                End
              Else
                Begin
                  NextCh;
                  CommentStr := CommentStr + CharAt(BufferPosition);
                End;
            End; { WHILE TRUE }
        End
      Else
        Begin
          If (CurrInputCh = _CR) Or (CurrInputCh = _LF) Then
            Begin
              CurrLine := CurrLine - 1;
              StartOfLine := oldLineStart
            End;
          BufferPosition := BufferPosition - 1;
          CurrInputCh := LastInputCh;
          Result := False;
        End;
    End;
End; { Comment }

Function TfsSqlScanner.CharInIgnoreSet(Const Ch: char): boolean;
Begin
  Result := (Ch = ' ') Or
    ((CurrInputCh >= CHR(1)) And (CurrInputCh <= ' '));
End; {CharInIgnoreSet}

Function TfsSqlScanner.Equal(s: String): boolean;
Var
  i: Integer;
  q: Longint;
Begin
  If NextSymbol.Len <> Length(s) Then
    Begin
      Result := False;
      Exit
    End;
  i := 1;
  q := bpCurrToken;
  While i <= NextSymbol.Len Do
    Begin
      If CurrentCh(q) <> s[i] Then
        Begin
          Result := False;
          Exit;
        End;
      inc(i);
      inc(q);
    End;
  Result := True
End; {Equal}

Procedure TfsSqlScanner.CheckLiteral(Var Sym: Integer);
Begin
  Case CurrentCh(bpCurrToken) Of
    'A': If Equal('ABS') Then
        Begin
          sym := ABSSym;
        End
      Else If Equal('ARRAY') Then
        Begin
          sym := ARRAYSym;
        End
      Else If Equal('ARRAYUINT8') Then
        Begin
          sym := BYTEARRAYSym;
        End
      Else If Equal('ARRAYUINT16') Then
        Begin
          sym := WORDARRAYSYM;
        End
      Else If Equal('ARRAYINT32') Then
        Begin
          sym := INTARRAYSym;
        End
      Else If Equal('ARRAYDOUBLE') Then
        Begin
          sym := DOUBLEARRAYSym;
        End
      Else If Equal('ALL') Then
        Begin
          sym := ALLSym;
        End
      Else If Equal('AND') Then
        Begin
          sym := ANDSym;
        End
      Else If Equal('ANY') Then
        Begin
          sym := ANYSym;
        End
      Else If Equal('AS') Then
        Begin
          sym := ASSym;
        End
      Else If Equal('ASC') Then
        Begin
          sym := ASCSym;
        End
      Else If Equal('AUTOINC32') Then
        Begin
          sym := AUTOINC32Sym;
        End
      Else If Equal('AUTOINC64') Then
        Begin
          sym := AUTOINC64Sym;
        End
      Else If Equal('ATFIRST') Then
        Begin
          sym := ATFIRSTSym;
        End
      Else If Equal('AVG') Then
        Begin
          sym := AVGSym;
        End;

    'B': If Equal('BETWEEN') Then
        Begin
          sym := BETWEENSym;
        End
      Else If Equal('BYTE') Then
        Begin
          sym := BYTESym;
        End
      Else If Equal('BIGINT') Then
        Begin
          sym := INT64Sym;
        End
      Else If Equal('BOTH') Then
        Begin
          sym := BOTHSym;
        End
      Else If Equal('BOOL') Then
        Begin
          sym := BOOLEANSym;
        End
      Else If Equal('BOOLEAN') Then
        Begin
          sym := BOOLEANSym;
        End
      Else If Equal('BLOB') Then
        Begin
          sym := BLOBSym;
        End
      Else If Equal('BY') Then
        Begin
          sym := BYSym;
        End;

    'C': If Equal('CASE') Then
        Begin
          sym := CASESym;
        End
      Else If Equal('CHAR') Then
        Begin
          sym := NULLSTRINGSym;
        End
      Else If Equal('CHARACTER') Then
        Begin
          sym := NULLSTRINGSym;
        End
      Else If Equal('COMMITBY') Then
        Begin
          sym := COMMITBYSym;
        End
      Else If Equal('CAST') Then
        Begin
          sym := CASTSym;
        End
      Else If Equal('CEILING') Then
        Begin
          sym := CEILINGSym;
        End
      Else If (Equal('CHARACTER_LENGTH') Or Equal('CHAR_LENGTH')) Then
        Begin
          sym := CHARACTER_underscoreLENGTHSym;
        End
      Else If Equal('CENTERDOWN') Then
        Begin
          sym := CENTERDOWNSym;
        End
      Else If Equal('CENTER') Then
        Begin
          sym := CENTERSym;
        End
      Else If Equal('COALESCE') Then
        Begin
          sym := COALESCESym;
        End
      Else If Equal('COUNT') Then
        Begin
          sym := COUNTSym;
        End
      Else If Equal('CROSS') Then
        Begin
          sym := CROSSSym;
        End
      Else If Equal('CURRENT_DATE') Then
        Begin
          sym := CURRENT_underscoreDATESym;
        End
      Else If Equal('CURRENT_TIME') Then
        Begin
          sym := CURRENT_underscoreTIMESym;
        End
      Else If Equal('CURRENT_TIMESTAMP') Then
        Begin
          sym := CURRENT_underscoreTIMESTAMPSym;
        End
      Else If Equal('CURRENCY') Then
        Begin
          sym := CURRENCYSYM;
        End
      Else If Equal('CURRENT_USER') Then
        Begin
          sym := USERSym;
        End;

    'D': If Equal('DATE') Then
        Begin
          sym := DATESym;
        End
      Else If Equal('DWORD') Then
        Begin
          sym := WORD32SYM;
        End
      Else If Equal('DOUBLE') Then
        Begin
          sym := DOUBLESym;
        End
      Else If Equal('DAY') Then
        Begin
          sym := DAYSym;
        End
      Else If Equal('DEFAULT') Then
        Begin
          sym := DEFAULTSym;
        End
      Else If Equal('DELETE') Then
        Begin
          sym := DELETESym;
        End
      Else If Equal('DESC') Then
        Begin
          sym := DESCSym;
        End
      Else If Equal('DIV') Then
        Begin
          sym := DIVSym;
        End
      Else If Equal('DISTINCT') Then
        Begin
          sym := DISTINCTSym;
        End
      Else If Equal('DIVBY') Then
        Begin
          sym := DIVBYSym;
        End
      Else If Equal('DATETIME') Then
        Begin
          sym := TIMESTAMPSYM;
        End
      Else If Equal('DOWN') Then
        Begin
          sym := DOWNSym;
        End;

    'E': If Equal('ELSE') Then
        Begin
          sym := ELSESym;
        End
      Else If Equal('EXTENDED') Then
        Begin
          sym := EXTENDEDSym;
        End
      Else If Equal('END') Then
        Begin
          sym := ENDSym;
        End
      Else If Equal('ESCAPE') Then
        Begin
          sym := ESCAPESym;
        End
      Else If Equal('EXISTS') Then
        Begin
          sym := EXISTSSym;
        End
      Else If Equal('EXP') Then
        Begin
          sym := EXPSym;
        End
      Else If Equal('EXTRACT') Then
        Begin
          sym := EXTRACTSym;
        End;

    'F': If Equal('FALSE') Then
        Begin
          sym := FALSESym;
        End
      Else If Equal('FLOOR') Then
        Begin
          sym := FLOORSym;
        End
      Else If Equal('FOR') Then
        Begin
          sym := FORSym;
        End
      Else If Equal('FROM') Then
        Begin
          sym := FROMSym;
        End
      Else If Equal('FLAGS') Then
        Begin
          sym := FLAGSsym;
        End
      Else If Equal('FIRST') Then
        Begin
          Sym := FIRSTSym;
        End
      Else If Equal('FLOAT') Then
        Begin
          sym := SINGLESym;
        End
      Else If Equal('FULL') Then
        Begin
          sym := FULLSym;
        End;

    'G': If Equal('GROUP') Then
        Begin
          sym := GROUPSym;
        End
      Else If Equal('GROUPUNION') Then
        Begin
          sym := GROUPUNIONSym;
        End
      Else If Equal('GRAPHIC') Then
        Begin
          sym := GRAPHICSYM;
        End;

    'H': If Equal('HAVING') Then
        Begin
          sym := HAVINGSym;
        End
      Else If Equal('HOUR') Then
        Begin
          sym := HOURSym;
        End;

    'I': If Equal('IGNORE') Then
        Begin
          sym := IGNORESym;
        End
      Else If Equal('IN') Then
        Begin
          sym := INSym;
        End
      Else If Equal('IMAGE') Then
        Begin
          sym := GRAPHICSYM;
        End
      Else If Equal('INNER') Then
        Begin
          sym := INNERSym;
        End
      Else If Equal('INSERT') Then
        Begin
          sym := INSERTSym;
        End
      Else If Equal('INTERVAL') Then
        Begin
          sym := INTERVALSym;
        End
      Else If Equal('INTO') Then
        Begin
          sym := INTOSym;
        End
      Else If Equal('INT8') Then
        Begin
          sym := INT8Sym;
        End
      Else If Equal('INT16') Then
        Begin
          sym := INT16Sym;
        End
      Else If Equal('INT32') Then
        Begin
          sym := INT32Sym;
        End
      Else If Equal('INT') Then
        Begin
          sym := INT32Sym;
        End
      Else If Equal('INTEGER') Then
        Begin
          sym := INT32Sym;
        End
      Else If Equal('INT64') Then
        Begin
          sym := INT64Sym;
        End
      Else If Equal('ISRECORDLOCKED') Then
        Begin
          sym := ISRECORDLOCKEDSYM;
        End

      Else If Equal('ISUNDELETEDRECORD') Then
        Begin
          sym := ISUNDELETEDRECORDSYM;
        End
      Else If Equal('ISPROTECTDELETERECORD') Then
        Begin
          sym := ISPROTECTDELETERECORDSYM;
        End
      Else If Equal('ISPROTECTUPDATERECORD') Then
        Begin
          sym := ISPROTECTUPDATERECORDSYM;
        End
      Else If Equal('ISMARKASBADRECORD') Then
        Begin
          sym := ISMARKASBADRECORDSYM;
        End
      Else If Equal('IS') Then
        Begin
          sym := ISSym;
        End;

    'J': If Equal('JOIN') Then
        Begin
          sym := JOINSym;
        End;

    'L': If Equal('LEADING') Then
        Begin
          sym := LEADINGSym;
        End
      Else If Equal('LARGEINT') Then
        Begin
          sym := INT64Sym;
        End
      Else If Equal('LEFT') Then
        Begin
          sym := LEFTSym;
        End
      Else If Equal('LIKE') Then
        Begin
          sym := LIKESym;
        End
      Else If Equal('LOG') Then
        Begin
          sym := LOGSym;
        End
      Else If Equal('LASTAUTOINC') Then
        Begin
          sym := LASTAUTOINCSym;
        End
      Else If Equal('LOWER') Then
        Begin
          sym := LOWERSym;
        End;

    'M': If Equal('MATCH') Then
        Begin
          sym := MATCHSym;
        End
      Else If Equal('MONEY') Then
        Begin
          sym := CURRENCYSym;
        End
      Else If Equal('MAX') Then
        Begin
          sym := MAXSym;
        End
      Else If Equal('MIN') Then
        Begin
          sym := MINSym;
        End
      Else If Equal('MINUTE') Then
        Begin
          sym := MINUTESym;
        End
      Else If Equal('MOD') Then
        Begin
          sym := MODSym;
        End
      Else If Equal('MEMO') Then
        Begin
          sym := MEMOSym;
        End
      Else If Equal('MONTH') Then
        Begin
          sym := MONTHSym;
        End;

    'N': If Equal('NATURAL') Then
        Begin
          sym := NATURALSym;
        End
      Else If Equal('NOINDEX') Then
        Begin
          sym := NOINDEXSym;
        End
      Else If Equal('NOREDUCE') Then
        Begin
          sym := NOREDUCESym;
        End
      Else If Equal('NOT') Then
        Begin
          sym := NOTSym;
        End
      Else If Equal('NULL') Then
        Begin
          sym := NULLSym;
        End
      Else If Equal('NCHAR') Then
        Begin
          sym := WIDESTRINGSym;
        End
      Else If Equal('NSINGLECHAR') Then
        Begin
          sym := SINGLEWIDECHARSym;
        End
      Else If Equal('NULLSTRING') Then
        Begin
          sym := NULLSTRINGSym;
        End
      Else If Equal('NEXTAUTOINC') Then
        Begin
          sym := NEXTAUTOINCSym;
        End
      Else If Equal('NULLIF') Then
        Begin
          sym := NULLIFSym;
        End;

    'O': If Equal('ON') Then
        Begin
          sym := ONSym;
        End
      Else If Equal('ODD') Then
        Begin
          sym := ODDSym;
        End
      Else If Equal('ONLINE') Then
        Begin
          sym := ONLINESym;
        End
      Else If Equal('OR') Then
        Begin
          sym := ORSym;
        End
      Else If Equal('ORDER') Then
        Begin
          sym := ORDERSym;
        End
      Else If Equal('ORDERUNION') Then
        Begin
          sym := ORDERUNIONSym;
        End
      Else If Equal('OUTER') Then
        Begin
          sym := OUTERSym;
        End;

    'P': If Equal('PARTIAL') Then
        Begin
          sym := PARTIALSym;
        End
      Else If Equal('PERCENT') Then
        Begin
          sym := PERCENTSym;
        End
      Else If Equal('PLAN') Then
        Begin
          sym := PLANSym;
        End
      Else If Equal('POSITION') Then
        Begin
          sym := POSITIONSym;
        End
      Else If Equal('POWER') Then
        Begin
          sym := POWERSym;
        End;

    'R': If Equal('RAND') Then
        Begin
          sym := RANDSym;
        End
      Else If Equal('RECVERSION') Then
        Begin
          sym := RECVERSIONSym;
        End
      Else If Equal('REAL') Then
        Begin
          sym := DOUBLESym;
        End
      Else If Equal('READLASTAUTOINC') Then
        Begin
          sym := READLASTAUTOINCSym;
        End
      Else If Equal('RIGHT') Then
        Begin
          sym := RIGHTSym;
        End
      Else If Equal('ROUND') Then
        Begin
          sym := ROUNDSym;
        End;

    'S':
      If Equal('SECOND') Then
        Begin
          sym := SECONDSym;
        End
      Else If Equal('SELECT') Then
        Begin
          sym := SELECTSym;
        End
      Else If Equal('SET') Then
        Begin
          sym := SETSym;
        End
      Else If Equal('SOME') Then
        Begin
          sym := SOMESym;
        End
      Else If Equal('STARTPOSITION') Then
        Begin
          sym := STARTFROMSym;
        End
      Else If Equal('SUBSTRING') Then
        Begin
          sym := SUBSTRINGSym;
        End
      Else If Equal('SINGLE') Then
        Begin
          sym := SINGLESym;
        End
      Else If Equal('SINGLECHAR') Then
        Begin
          sym := SINGLECHARSym;
        End
      Else If Equal('SINGLEWIDECHAR') Then
        Begin
          sym := SINGLEWIDECHARSym;
        End
      Else If Equal('SHORTSTRING') Then
        Begin
          sym := SHORTSTRINGSym;
        End
      Else If Equal('SHORTINT') Then
        Begin
          sym := INT8Sym;
        End
      Else If Equal('SELECTTREE') Then
        Begin
          sym := SELECTTREESym;
        End
      Else If Equal('SELECTTREEPATH') Then
        Begin
          sym := SELECTTREEPATHSym;
        End
      Else If Equal('SUM') Then
        Begin
          sym := SUMSym;
        End;

    'T': If Equal('TABLE') Then
        Begin
          sym := TABLESym;
        End
      Else If Equal('THEN') Then
        Begin
          sym := THENSym;
        End
      Else If Equal('TOPDOWN') Then
        Begin
          sym := TOPDOWNSym;
        End
      Else If Equal('TOPCENTERDOWN') Then
        Begin
          sym := TOPCENTERDOWNSym;
        End
      Else If Equal('TOPCENTER') Then
        Begin
          sym := TOPCENTERSym;
        End
      Else If Equal('TIME') Then
        Begin
          sym := TIMESym;
        End
      Else If Equal('TIMESTAMP') Then
        Begin
          sym := TIMESTAMPSym;
        End
      Else If Equal('TINYINT') Then
        Begin
          sym := BYTESym;
        End
      Else If Equal('TO') Then
        Begin
          sym := TOSym;
        End
      Else If Equal('TOP') Then
        Begin
          sym := TOPsym;
        End
      Else If Equal('TRAILING') Then
        Begin
          sym := TRAILINGSym;
        End
      Else If Equal('TRIM') Then
        Begin
          sym := TRIMSym;
        End
      Else If Equal('TRUE') Then
        Begin
          sym := TRUESym;
        End;

    'U': If Equal('UNION') Then
        Begin
          sym := UNIONSym;
        End
      Else If Equal('UINT8') Then
        Begin
          sym := BYTESym;
        End
      Else If Equal('UINT16') Then
        Begin
          sym := WORD16SYM;
        End
      Else If Equal('UINT32') Then
        Begin
          sym := WORD32SYM;
        End
      Else If Equal('USEINDEX') Then
        Begin
          sym := INDEXNAMESym;
        End
      Else If Equal('UNIQUE') Then
        Begin
          sym := UNIQUESym;
        End
      Else If Equal('UNKNOWN') Then
        Begin
          sym := UNKNOWNSym;
        End
      Else If Equal('UPDATE') Then
        Begin
          sym := UPDATESym;
        End
      Else If Equal('UPPER') Then
        Begin
          sym := UPPERSym;
        End
      Else If Equal('USER') Then
        Begin
          sym := USERSym;
        End
      Else If Equal('USING') Then
        Begin
          sym := USINGSym;
        End;

    'V': If Equal('VALUES') Then
        Begin
          sym := VALUESSym;
        End
      Else If Equal('VARNULLSTRING') Then
        Begin
          sym := VARNULLSTRINGSym;
        End
      Else If Equal('VARVIDESTRING') Then
        Begin
          sym := VARWIDESTRINGSym;
        End;

    'W': If Equal('WHEN') Then
        Begin
          sym := WHENSym;
        End
      Else If Equal('WEEKNO') Then
        Begin
          sym := WeekNoSym;
        End
      Else If Equal('WIDESTRING') Then
        Begin
          sym := WIDESTRINGSYM;
        End
      Else If Equal('WORD16') Then
        Begin
          sym := WORD16SYM;
        End
      Else If Equal('WORD') Then
        Begin
          sym := WORD16SYM;
        End
      Else If Equal('WORD32') Then
        Begin
          sym := WORD32SYM;
        End
      Else If Equal('WHERE') Then
        Begin
          sym := WHERESym;
        End;

    'Y': If Equal('YEAR') Then
        Begin
          sym := YEARSym;
        End;

    Else
      Begin
      End;
  End;
End; {CheckLiteral}

Procedure TfsSqlScanner.Get(Var sym: Integer; TableN: boolean = False);
Var
  state: Integer;
Begin {Get}
  While CharInIgnoreSet(CurrInputCh) Do
    NextCh;
  If ((CurrInputCh = '/') Or (CurrInputCh = '-') Or (CurrInputCh = '/')) And Comment Then
    Begin
      Get(sym);
      Exit;
    End;

  CurrentSymbol.Assign(NextSymbol);

  NextSymbol.Pos := BufferPosition;
  NextSymbol.Col := BufferPosition - StartOfLine;
  NextSymbol.Line := CurrLine;
  NextSymbol.Len := 0;

  ContextLen := 0;
  state := StartState[ORD(CurrInputCh)];
  bpCurrToken := BufferPosition;
  While True Do
    Begin
      NextCh;
      NextSymbol.Len := NextSymbol.Len + 1;
      If BufferPosition > SrcStream.Size Then
        Begin
          sym := EOFSYMB;
          CurrInputCh := _EF;
          BufferPosition := BufferPosition - 1;
          Exit
        End;
      Case state Of
        1:
          Begin
            If TableN Then
              Begin
                If ((CurrInputCh = '!') Or
                  (CurrInputCh >= '#') And (CurrInputCh <= '$') Or
                  (CurrInputCh >= '0') And (CurrInputCh <= '9') Or
                  (CurrInputCh >= '@') And (CurrInputCh <= 'Z') Or
                  (CurrInputCh = '\') Or
                  (CurrInputCh >= '^') And (CurrInputCh <= '{') Or
                  (CurrInputCh >= '}') Or (CurrInputCh >= '(') Or (CurrInputCh = ')')
                  Or (CurrInputCh = '.') Or (CurrInputCh = ',') Or (CurrInputCh = '''')
                  Or (CurrInputCh = ':') Or (CurrInputCh = '?') Or (CurrInputCh = '"')) Then
                  Begin

                  End
                Else
                  Begin
                    sym := identSym;
                    CheckLiteral(sym);
                    Exit;
                  End;
              End
            Else
              Begin
                If ((CurrInputCh = '!') Or
                  (CurrInputCh >= '#') And (CurrInputCh <= '$') Or
                  (CurrInputCh >= '0') And (CurrInputCh <= '9') Or
                  (CurrInputCh >= '@') And (CurrInputCh <= 'Z') Or
                  (CurrInputCh = '\') Or
                  (CurrInputCh >= '^') And (CurrInputCh <= '{') Or
                  (CurrInputCh >= '}')) Then
                  Begin

                  End
                Else
                  Begin
                    sym := identSym;
                    CheckLiteral(sym);
                    Exit;
                  End;
              End;
          End;
        2: If ((CurrInputCh >= '0') And (CurrInputCh <= '9')) Then
            Begin
              state := 3;
            End
          Else
            Begin
              sym := _pointSym;
              Exit;
            End;
        3: If ((CurrInputCh >= '0') And (CurrInputCh <= '9')) Then
            Begin

            End
          Else
            Begin
              sym := float_Sym;
              Exit;
            End;
        4: If ((CurrInputCh <= CHR(12)) Or
            (CurrInputCh >= CHR(14)) And (CurrInputCh <= '&') Or
            (CurrInputCh >= '(')) Then
            Begin

            End
          Else If (CurrInputCh = CHR(39)) Then
            Begin
              state := 8;
            End
          Else
            Begin
              sym := _noSym;
              Exit;
            End;
        5: If ((CurrInputCh <= CHR(12)) Or
            (CurrInputCh >= CHR(14)) And (CurrInputCh <= '!') Or
            (CurrInputCh >= '#')) Then
            Begin

            End
          Else If (CurrInputCh = '"') Then
            Begin
              state := 6;
            End
          Else
            Begin
              sym := _noSym;
              Exit;
            End;
        6:
          Begin
            sym := SQLNameStringSym;
            Exit;
          End;
        7: If ((CurrInputCh >= '0') And (CurrInputCh <= '9')) Then
            Begin
            End
          Else If (CurrInputCh = '.') Then
            Begin
              state := 2;
            End
          Else
            Begin
              sym := integer_Sym;
              Exit;
            End;
        8: If (CurrInputCh = CHR(39)) Then
            Begin
              state := 4;
            End
          Else
            Begin
              sym := SQLStringSym;
              Exit;
            End;
        9:
          Begin
            sym := _semicolonSym;
            Exit;
          End;
        10:
          Begin
            If TableN Then
              Begin
                If ((CurrInputCh = '!') Or
                  (CurrInputCh >= '#') And (CurrInputCh <= '$') Or
                  (CurrInputCh >= '0') And (CurrInputCh <= '9') Or
                  (CurrInputCh >= '@') And (CurrInputCh <= 'Z') Or
                  (CurrInputCh = '\') Or
                  (CurrInputCh >= '^') And (CurrInputCh <= '{') Or
                  (CurrInputCh >= '}') Or (CurrInputCh >= '(') Or (CurrInputCh = ')')
                  Or (CurrInputCh = '.') Or (CurrInputCh = ',') Or (CurrInputCh = '''')
                  Or (CurrInputCh = ':') Or (CurrInputCh = '?') Or (CurrInputCh = '"')) Then
                  Begin

                  End
                Else
                  Begin
                    sym := identSym;
                    CheckLiteral(sym);
                    Exit;
                  End;
              End
            Else
              Begin
                sym := _lparenSym;
                Exit;
              End;
          End;
        11:
          Begin
            sym := _rparenSym;
            Exit;
          End;
        12:
          Begin
            sym := _commaSym;
            Exit;
          End;
        13:
          Begin
            sym := _equalSym;
            Exit;
          End;
        14:
          Begin
            sym := _starSym;
            Exit;
          End;
        15: If (CurrInputCh = '=') Then
            Begin
              state := 16;
            End
          Else If (CurrInputCh = '>') Then
            Begin
              state := 19;
            End
          Else
            Begin
              sym := _lessSym;
              Exit;
            End;
        16:
          Begin
            sym := _less_equalSym;
            Exit;
          End;
        17: If (CurrInputCh = '=') Then
            Begin
              state := 18;
            End
          Else
            Begin
              sym := _greaterSym;
              Exit;
            End;
        18:
          Begin
            sym := _greater_equalSym;
            Exit;
          End;
        19:
          Begin
            sym := _less_greaterSym;
            Exit;
          End;
        20:
          Begin
            sym := _plusSym;
            Exit;
          End;
        21:
          Begin
            sym := _minusSym;
            Exit;
          End;
        22: If (CurrInputCh = '|') Then
            Begin
              state := 23;
            End
          Else
            Begin
              sym := _noSym;
              Exit;
            End;
        23:
          Begin
            sym := _bar_barSym;
            Exit;
          End;
        24:
          Begin
            sym := _slashSym;
            Exit;
          End;
        25:
          Begin
            sym := _querySym;
            Exit;
          End;
        26:
          Begin
            sym := EOFSYMB;
            CurrInputCh := #0;
            BufferPosition := BufferPosition - 1;
            Exit
          End;
        Else
          Begin
            sym := _noSym;
            Exit; // NextCh already done
          End;
      End;
    End;
End; {Get}

Constructor TfsSqlScanner.Create;
Begin
  Inherited;
  CurrentCh := CapChAt;
  fStartState[0] := 26;
  fStartState[1] := 27;
  fStartState[2] := 27;
  fStartState[3] := 27;
  fStartState[4] := 27;
  fStartState[5] := 27;
  fStartState[6] := 27;
  fStartState[7] := 27;
  fStartState[8] := 27;
  fStartState[9] := 27;
  fStartState[10] := 27;
  fStartState[11] := 27;
  fStartState[12] := 27;
  fStartState[13] := 27;
  fStartState[14] := 27;
  fStartState[15] := 27;
  fStartState[16] := 27;
  fStartState[17] := 27;
  fStartState[18] := 27;
  fStartState[19] := 27;
  fStartState[20] := 27;
  fStartState[21] := 27;
  fStartState[22] := 27;
  fStartState[23] := 27;
  fStartState[24] := 27;
  fStartState[25] := 27;
  fStartState[26] := 27;
  fStartState[27] := 27;
  fStartState[28] := 27;
  fStartState[29] := 27;
  fStartState[30] := 27;
  fStartState[31] := 27;
  fStartState[32] := 27;
  fStartState[33] := 1;
  fStartState[34] := 5;
  fStartState[35] := 1;
  fStartState[36] := 1;
  fStartState[37] := 27;
  fStartState[38] := 27;
  fStartState[39] := 4;
  fStartState[40] := 10;
  fStartState[41] := 11;
  fStartState[42] := 14;
  fStartState[43] := 20;
  fStartState[44] := 12;
  fStartState[45] := 21;
  fStartState[46] := 2;
  fStartState[47] := 24;
  fStartState[48] := 7;
  fStartState[49] := 7;
  fStartState[50] := 7;
  fStartState[51] := 7;
  fStartState[52] := 7;
  fStartState[53] := 7;
  fStartState[54] := 7;
  fStartState[55] := 7;
  fStartState[56] := 7;
  fStartState[57] := 7;
  fStartState[58] := 27;
  fStartState[59] := 9;
  fStartState[60] := 15;
  fStartState[61] := 13;
  fStartState[62] := 17;
  fStartState[63] := 25;
  fStartState[64] := 1;
  fStartState[65] := 1;
  fStartState[66] := 1;
  fStartState[67] := 1;
  fStartState[68] := 1;
  fStartState[69] := 1;
  fStartState[70] := 1;
  fStartState[71] := 1;
  fStartState[72] := 1;
  fStartState[73] := 1;
  fStartState[74] := 1;
  fStartState[75] := 1;
  fStartState[76] := 1;
  fStartState[77] := 1;
  fStartState[78] := 1;
  fStartState[79] := 1;
  fStartState[80] := 1;
  fStartState[81] := 1;
  fStartState[82] := 1;
  fStartState[83] := 1;
  fStartState[84] := 1;
  fStartState[85] := 1;
  fStartState[86] := 1;
  fStartState[87] := 1;
  fStartState[88] := 1;
  fStartState[89] := 1;
  fStartState[90] := 1;
  fStartState[91] := 27;
  fStartState[92] := 1;
  fStartState[93] := 27;
  fStartState[94] := 1;
  fStartState[95] := 1;
  fStartState[96] := 1;
  fStartState[97] := 1;
  fStartState[98] := 1;
  fStartState[99] := 1;
  fStartState[100] := 1;
  fStartState[101] := 1;
  fStartState[102] := 1;
  fStartState[103] := 1;
  fStartState[104] := 1;
  fStartState[105] := 1;
  fStartState[106] := 1;
  fStartState[107] := 1;
  fStartState[108] := 1;
  fStartState[109] := 1;
  fStartState[110] := 1;
  fStartState[111] := 1;
  fStartState[112] := 1;
  fStartState[113] := 1;
  fStartState[114] := 1;
  fStartState[115] := 1;
  fStartState[116] := 1;
  fStartState[117] := 1;
  fStartState[118] := 1;
  fStartState[119] := 1;
  fStartState[120] := 1;
  fStartState[121] := 1;
  fStartState[122] := 1;
  fStartState[123] := 1;
  fStartState[124] := 22;
  fStartState[125] := 1;
  fStartState[126] := 1;
  fStartState[127] := 1;
  fStartState[128] := 1;
  fStartState[129] := 1;
  fStartState[130] := 1;
  fStartState[131] := 1;
  fStartState[132] := 1;
  fStartState[133] := 1;
  fStartState[134] := 1;
  fStartState[135] := 1;
  fStartState[136] := 1;
  fStartState[137] := 1;
  fStartState[138] := 1;
  fStartState[139] := 1;
  fStartState[140] := 1;
  fStartState[141] := 1;
  fStartState[142] := 1;
  fStartState[143] := 1;
  fStartState[144] := 1;
  fStartState[145] := 1;
  fStartState[146] := 1;
  fStartState[147] := 1;
  fStartState[148] := 1;
  fStartState[149] := 1;
  fStartState[150] := 1;
  fStartState[151] := 1;
  fStartState[152] := 1;
  fStartState[153] := 1;
  fStartState[154] := 1;
  fStartState[155] := 1;
  fStartState[156] := 1;
  fStartState[157] := 1;
  fStartState[158] := 1;
  fStartState[159] := 1;
  fStartState[160] := 1;
  fStartState[161] := 1;
  fStartState[162] := 1;
  fStartState[163] := 1;
  fStartState[164] := 1;
  fStartState[165] := 1;
  fStartState[166] := 1;
  fStartState[167] := 1;
  fStartState[168] := 1;
  fStartState[169] := 1;
  fStartState[170] := 1;
  fStartState[171] := 1;
  fStartState[172] := 1;
  fStartState[173] := 1;
  fStartState[174] := 1;
  fStartState[175] := 1;
  fStartState[176] := 1;
  fStartState[177] := 1;
  fStartState[178] := 1;
  fStartState[179] := 1;
  fStartState[180] := 1;
  fStartState[181] := 1;
  fStartState[182] := 1;
  fStartState[183] := 1;
  fStartState[184] := 1;
  fStartState[185] := 1;
  fStartState[186] := 1;
  fStartState[187] := 1;
  fStartState[188] := 1;
  fStartState[189] := 1;
  fStartState[190] := 1;
  fStartState[191] := 1;
  fStartState[192] := 1;
  fStartState[193] := 1;
  fStartState[194] := 1;
  fStartState[195] := 1;
  fStartState[196] := 1;
  fStartState[197] := 1;
  fStartState[198] := 1;
  fStartState[199] := 1;
  fStartState[200] := 1;
  fStartState[201] := 1;
  fStartState[202] := 1;
  fStartState[203] := 1;
  fStartState[204] := 1;
  fStartState[205] := 1;
  fStartState[206] := 1;
  fStartState[207] := 1;
  fStartState[208] := 1;
  fStartState[209] := 1;
  fStartState[210] := 1;
  fStartState[211] := 1;
  fStartState[212] := 1;
  fStartState[213] := 1;
  fStartState[214] := 1;
  fStartState[215] := 1;
  fStartState[216] := 1;
  fStartState[217] := 1;
  fStartState[218] := 1;
  fStartState[219] := 1;
  fStartState[220] := 1;
  fStartState[221] := 1;
  fStartState[222] := 1;
  fStartState[223] := 1;
  fStartState[224] := 1;
  fStartState[225] := 1;
  fStartState[226] := 1;
  fStartState[227] := 1;
  fStartState[228] := 1;
  fStartState[229] := 1;
  fStartState[230] := 1;
  fStartState[231] := 1;
  fStartState[232] := 1;
  fStartState[233] := 1;
  fStartState[234] := 1;
  fStartState[235] := 1;
  fStartState[236] := 1;
  fStartState[237] := 1;
  fStartState[238] := 1;
  fStartState[239] := 1;
  fStartState[240] := 1;
  fStartState[241] := 1;
  fStartState[242] := 1;
  fStartState[243] := 1;
  fStartState[244] := 1;
  fStartState[245] := 1;
  fStartState[246] := 1;
  fStartState[247] := 1;
  fStartState[248] := 1;
  fStartState[249] := 1;
  fStartState[250] := 1;
  fStartState[251] := 1;
  fStartState[252] := 1;
  fStartState[253] := 1;
  fStartState[254] := 1;
  fStartState[255] := 1;
End; {Create}

{ --------------------------------------------------------------------------- }
{ ---- implementation for TfsSql ---- }

Constructor TfsSql.Create(AOwner: TComponent);
Begin
  Inherited;
  Scanner := TfsSqlScanner.Create;
  GetScanner.Owner := Self;
  FRootNode := Nil;
  FReservedWordList := TStringList.Create;
  FAllowReservedWordNames := True;

  InitSymSet;
End; {Create}

Destructor TfsSql.Destroy;
Begin
  Scanner.Free;
  FReservedWordList.Free;
  FReservedWordList := Nil;

  Inherited;
End; {Destroy}

Function TfsSql.ErrorStr(Const ErrorCode: Integer; Const Data: String): String;
Begin
  Case ErrorCode Of
    0: Result := 'EOF expected';
    1: Result := 'ident expected';
    2: Result := 'integer_ expected';
    3: Result := 'float expected';
    4: Result := 'SQLString expected';
    5: Result := 'SQLNameString expected';
    6: Result := '"NOINDEX" expected';
    7: Result := '"NOREDUCE" expected';
    8: Result := '";" expected';
    9: Result := '"SELECT" expected';
    10: Result := '"ALL" expected';
    11: Result := '"DISTINCT" expected';
    12: Result := '"FROM" expected';
    13: Result := '"WHERE" expected';
    14: Result := '"GROUP" expected';
    15: Result := '"BY" expected';
    16: Result := '"HAVING" expected';
    17: Result := '"ORDER" expected';
    18: Result := '"INSERT" expected';
    19: Result := '"INTO" expected';
    20: Result := '"DEFAULT" expected';
    21: Result := '"VALUES" expected';
    22: Result := '"(" expected';
    23: Result := '")" expected';
    24: Result := '"CROSS" expected';
    25: Result := '"JOIN" expected';
    26: Result := '"NATURAL" expected';
    27: Result := '"INNER" expected';
    28: Result := '"LEFT" expected';
    29: Result := '"OUTER" expected';
    30: Result := '"RIGHT" expected';
    31: Result := '"FULL" expected';
    32: Result := '"UNION" expected';
    33: Result := '"ON" expected';
    34: Result := '"USING" expected';
    35: Result := '"," expected';
    36: Result := '"TABLE" expected';
    37: Result := '"NULL" expected';
    38: Result := '"DELETE" expected';
    39: Result := '"UPDATE" expected';
    40: Result := '"SET" expected';
    41: Result := '"=" expected';
    42: Result := '"ASC" expected';
    43: Result := '"DESC" expected';
    44: Result := '"." expected';
    45: Result := '"*" expected';
    46: Result := '"AS" expected';
    47: Result := '"COUNT" expected';
    48: Result := '"MIN" expected';
    49: Result := '"MAX" expected';
    50: Result := '"SUM" expected';
    51: Result := '"AVG" expected';
    52: Result := '"OR" expected';
    53: Result := '"AND" expected';
    54: Result := '"NOT" expected';
    55: Result := '"<=" expected';
    56: Result := '"<" expected';
    57: Result := '">" expected';
    58: Result := '">=" expected';
    59: Result := '"<>" expected';
    60: Result := '"ANY" expected';
    61: Result := '"SOME" expected';
    62: Result := '"EXISTS" expected';
    63: Result := '"UNIQUE" expected';
    64: Result := '"IS" expected';
    65: Result := '"TRUE" expected';
    66: Result := '"FALSE" expected';
    67: Result := '"UNKNOWN" expected';
    68: Result := '"BETWEEN" expected';
    69: Result := '"LIKE" expected';
    70: Result := '"ESCAPE" expected';
    71: Result := '"IGNORE" expected';
    72: Result := '"CASE" expected';
    73: Result := '"IN" expected';
    74: Result := '"MATCH" expected';
    75: Result := '"PARTIAL" expected';
    76: Result := '"+" expected';
    77: Result := '"-" expected';
    78: Result := '"||" expected';
    79: Result := '"/" expected';
    80: Result := '"CHARACTER_LENGTH" expected';
    81: Result := '"FLAGS" expected';
    82: Result := '"COALESCE" expected';
    83: Result := '"CURRENT_DATE" expected';
    84: Result := '"CURRENT_TIME" expected';
    85: Result := '"CURRENT_TIMESTAMP" expected';
    86: Result := '"CAST" expected';
    87: Result := '"USER" expected';
    88: Result := '"LOWER" expected';
    89: Result := '"UPPER" expected';
    90: Result := '"POSITION" expected';
    91: Result := '"TOP" expected';
    92: Result := '"SUBSTRING" expected';
    93: Result := '"FOR" expected';
    94: Result := '"WEEKNO" expected';
    95: Result := '"TRIM" expected';
    96: Result := '"LEADING" expected';
    97: Result := '"TRAILING" expected';
    98: Result := '"BOTH" expected';
    99: Result := '"EXTRACT" expected';
    100: Result := '"YEAR" expected';
    101: Result := '"MONTH" expected';
    102: Result := '"DAY" expected';
    103: Result := '"HOUR" expected';
    104: Result := '"MINUTE" expected';
    105: Result := '"SECOND" expected';
    106: Result := '"NULLIF" expected';
    107: Result := '"ABS" expected';
    108: Result := '"CEILING" expected';
    109: Result := '"FLOOR" expected';
    110: Result := '"EXP" expected';
    111: Result := '"LOG" expected';
    112: Result := '"POWER" expected';
    113: Result := '"RAND" expected';
    114: Result := '"ROUND" expected';
    115: Result := '"ELSE" expected';
    116: Result := '"END" expected';
    117: Result := '"WHEN" expected';
    118: Result := '"THEN" expected';
    119: Result := '"?" expected';
    120: Result := '"DATE" expected';
    121: Result := '"TIME" expected';
    122: Result := '"TIMESTAMP OR DATETIME" expected';
    123: Result := '"INTERVAL" expected';
    124: Result := '"TO" expected';
    // DATATYPE
    125: Result := '"BOOLEAN" expected';
    126: Result := '"SINGLECHAR" expected';
    127: Result := '"SINGLEWIDECHAR" expected';
    128: Result := '"BYTE" expected';
    129: Result := '"WORD16" expected';
    130: Result := '"WORD32" expected';
    131: Result := '"INT8" expected';
    132: Result := '"INT16" expected';
    133: Result := '"INT32" expected';
    134: Result := '"INT64" expected';
    135: Result := '"AUTOINC32" expected';
    136: Result := '"AUTOINC64" expected';
    137: Result := '"SINGLE" expected';
    138: Result := '"DOUBLE" expected';
    139: Result := '"EXTENDED" expected';
    140: Result := '"CURRENCY" expected';
    141: Result := '"BLOB" expected';
    142: Result := '"MEMO" expected';
    143: Result := '"GRAPHIC" expected';
    144: Result := '"ARRAYUINT8" expected';
    145: Result := '"SHORTSTRING" expected';
    146: Result := '"VARNULLSTRING" expected';
    147: Result := '"NULLSTRING" expected';
    148: Result := '"VARWIDESTRING" expected';
    149: Result := '"WIDESTRING" expected';
    150: Result := '"RECVERSION" expected';
    151: Result := '"RES1" expected';
    152: Result := '"RES2" expected';
    153: Result := '"RES3" expected';
    154: Result := '"RES4" expected';
    155: Result := '"RES5" expected';

    156: Result := '"ARRAYINT32" expected';
    157: Result := '"ARRAYDOUBLE" expected';

    158: Result := '"ARRAYUINT16" expected';
    159: Result := '"PERCENT" expected';
    160: Result := '"STARTPOSITION" expected';
    161: Result := '"DOWN" expected';
    162: Result := '"TOPDOWN" expected';
    163: Result := '"CENTER" expected';
    164: Result := '"TOPCENTERDOWN" expected';
    165: Result := '"TOPCENTER" expected';
    166: Result := '"CENTERDOWN" expected';
    167: Result := '"DIVBY" expected';
    168: Result := '"ATFIRST" expected';
    169: Result := '"SELECTTREE" expected';
    170: Result := '"SELECTTREEPATH" expected';
    171: Result := '"PLAN" expected';
    172: Result := '"DIV" expected';
    173: Result := '"MOD" expected';
    174: Result := '"ODD" expected';
    175: Result := '"ONLINE" expected';
    176: Result := '"FIRST" expected';
    177: Result := '"USEINDEX" expected';
    178: Result := '"COMMITBY" expected';
    179: Result := '"ORDERUNION" expected';
    180: Result := '"ARRAY" expected';
    181: Result := '"LASTAUTOINC" expected';
    182: Result := '"NEXTAUTOINC" expected';
    183: Result := '"READLASTAUTOINC" expected';
    184: Result := '"ISRECORDLOCKED" expected';
    185: Result := '"ISUNDELETEDRECORD" expected';
    186: Result := '"ISPROTECTDELETERECORD" expected';
    187: Result := '"ISPROTECTUPDATERECORD" expected';
    188: Result := '"ISMARKASBADRECORD" expected';
    189: Result := '"GROUPUNION" expected';
    190: Result := 'not expected';

    {LARGESYMSYM = 190;
OBJECTSYM = 191;
VARYINGSYM = 192;
NATIONALSYM = 193;
BINARYSYM = 194;}

  //190  reserved
  //205
    206: Result := 'invalid BooleanLiteral';
    207: Result := 'invalid IntervalLiteral';
    208: Result := 'invalid IntervalLiteral';
    209: Result := 'invalid WhenClause';
    210: Result := 'invalid CaseExpression';
    211: Result := 'invalid ScalarFunction';
    212: Result := 'invalid ScalarFunction';
    213: Result := 'invalid ScalarFunction';
    214: Result := 'invalid Literal';
    255: Result := 'invalid Factor';
    216: Result := 'invalid Factor';
    217: Result := 'invalid IsTest';
    218: Result := 'invalid InClause';
    219: Result := 'invalid AllOrAnyClause';
    220: Result := 'invalid CondPrimary';
    221: Result := 'invalid CondPrimary';
    222: Result := 'invalid CondPrimary';
    223: Result := 'invalid CondPrimary';
    224: Result := 'invalid CondPrimary';
    225: Result := 'invalid FieldRef';
    226: Result := 'invalid Aggregate';
    227: Result := 'invalid Aggregate';
    228: Result := 'invalid Selection';
    229: Result := 'invalid OrderItem';
    230: Result := 'invalid UpdateItem';
    231: Result := 'invalid ValueItem';
    232: Result := 'invalid NonJoinTablePrimary';
    233: Result := 'invalid JoinTableExp';
    234: Result := 'invalid SimpleTableRefOrParenTableExp';
    235: Result := 'invalid SQLName';
    236: Result := 'invalid InsertStatement';
    237: Result := 'invalid TableExp';
    238: Result := 'invalid FSSQL';

    //260..299 - FOR DDL

    300: Result := 'Text after end of valid sql statement';
    301: Result := 'Nested aggregates are not allowed';
    302: Result := 'Aggregates may not appear in a WHERE clause';
    303: Result := 'Reserved word (' + data + ') not allowed';

    Else
      If Assigned(OnCustomError) Then
        Result := OnCustomError(Self, ErrorCode, Data)
      Else
        Begin
          Result := 'Error: ' + IntToStr(ErrorCode);
          If Trim(Data) > '' Then
            Result := Result + ' (' + Data + ')';
        End;
  End; {case nr}
End; {ErrorStr}

Procedure TfsSql.Execute;
Begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;

  { if there is a file name then load the file }
  If Trim(SourceFileName) <> '' Then
    Begin
      GetScanner.SrcStream.Clear;
      GetScanner.SrcStream.LoadFromFile(SourceFileName);
    End;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  { instigate the compilation }
  DoBeforeParse;
  Parse;
  DoAfterParse;

  { generate the source listing to the ListStream }
  If (GenListWhen = glAlways) Or ((GenListWhen = glOnError) And (ErrorList.Count > 0)) Then
    GenerateListing;
  If ClearSourceStream Then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0; // goto the beginning of the stream
  If Successful And Assigned(OnSuccess) Then
    OnSuccess(Self);
  If (Not Successful) And Assigned(OnFailure) Then
    OnFailure(Self, ErrorList.Count);
End; {Execute}

Procedure TfsSql.Get(TableN: boolean = False);
Begin
  Repeat

    GetScanner.Get(fCurrentInputSymbol, TableN);
    If fCurrentInputSymbol <= fsmaxT Then
      errDist := errDist + 1
    Else
      Begin
      End;
  Until fCurrentInputSymbol <= fsmaxT;
  If Assigned(AfterGet) Then
    AfterGet(Self, fCurrentInputSymbol);
End; {Get}

Function TfsSql.GetScanner: TfsSqlScanner;
Begin
  Result := Scanner As TfsSqlScanner;
End; {GetScanner}

Function TfsSql._In(Var s: fsSymbolSet; x: Integer): boolean;
Begin
  Result := x Mod setsize In s[x Div setsize];
End; {_In}

Procedure TfsSql._SimpleAlias(Var TableRef: TfsSqlTableRef);
Var
  aSQLName: String;
Begin
  If (fCurrentInputSymbol = ASSym) Then
    Begin
      Get;
    End;
  _SQLName(aSQLName);
  TableRef.Alias := aSQLName;
End;

Procedure TfsSql._BooleanLiteral(Parent: TfsSqlNode; Var BooleanLiteral: TfsSqlBooleanLiteral);
Begin
  BooleanLiteral := TfsSqlBooleanLiteral.Create(Parent);
  If (fCurrentInputSymbol = TRUESym) Then
    Begin
      Get;
      BooleanLiteral.Value := True;
    End
  Else If (fCurrentInputSymbol = FALSESym) Then
    Begin
      Get;
    End
  Else
    Begin
      SynError(206);
    End;
End;

Procedure TfsSql._IntervalLiteral(Parent: TfsSqlNode;
  Var IntervalLiteral: TfsSqlIntervalLiteral);
Begin
  IntervalLiteral := TfsSqlIntervalLiteral.Create(Parent);
  Expect(INTERVALSym);
  IntervalLiteral.StartDef := iUnspec;
  Expect(SQLStringSym);
  IntervalLiteral.Value := LexString;
  Case fCurrentInputSymbol Of
    YEARSym:
      Begin
        Get;
        IntervalLiteral.StartDef := iYear;
      End;
    MONTHSym:
      Begin
        Get;
        IntervalLiteral.StartDef := iMonth;
      End;
    DAYSym:
      Begin
        Get;
        IntervalLiteral.StartDef := iDay;
      End;
    HOURSym:
      Begin
        Get;
        IntervalLiteral.StartDef := iHour;
      End;
    MINUTESym:
      Begin
        Get;
        IntervalLiteral.StartDef := iMinute;
      End;
    SECONDSym:
      Begin
        Get;
        IntervalLiteral.StartDef := iSecond;
      End;
    Else
      Begin
        SynError(207);
      End;
  End;
  IntervalLiteral.EndDef := iUnspec;
  If (fCurrentInputSymbol = TOSym) Then
    Begin
      Get;
      Case fCurrentInputSymbol Of
        YEARSym:
          Begin
            Get;
            IntervalLiteral.EndDef := iYear;
          End;
        MONTHSym:
          Begin
            Get;
            IntervalLiteral.EndDef := iMonth;
          End;
        DAYSym:
          Begin
            Get;
            IntervalLiteral.EndDef := iDay;
          End;
        HOURSym:
          Begin
            Get;
            IntervalLiteral.EndDef := iHour;
          End;
        MINUTESym:
          Begin
            Get;
            IntervalLiteral.EndDef := iMinute;
          End;
        SECONDSym:
          Begin
            Get;
            IntervalLiteral.EndDef := iSecond;
          End;
        Else
          Begin
            SynError(208);
          End;
      End;
    End;
End;

Procedure TfsSql._TimestampLiteral(Parent: TfsSqlNode;
  Var TimestampLiteral: TfsSqlTimestampLiteral; Value: String = '');
Begin
  TimestampLiteral := TfsSqlTimestampLiteral.Create(Parent);
  If Value = '' Then
    Begin
      Expect(TIMESTAMPSym);
      Expect(SQLStringSym);
      TimestampLiteral.Value := LexString;
    End
  Else
    TimestampLiteral.Value := Value;
End;

Procedure TfsSql._TimeLiteral(Parent: TfsSqlNode;
  Var TimeLiteral: TfsSqlTimeLiteral; Value: String = '');
Begin
  TimeLiteral := TfsSqlTimeLiteral.Create(Parent);
  If Value = '' Then
    Begin
      Expect(TIMESym);
      Expect(SQLStringSym);
      TimeLiteral.Value := LexString;
    End
  Else
    TimeLiteral.Value := Value;
End;

Procedure TfsSql._DateLiteral(Parent: TfsSqlNode;
  Var DateLiteral: TfsSqlDateLiteral; Value: String = '');
Begin
  DateLiteral := TfsSqlDateLiteral.Create(Parent);
  {If (fCurrentInputSymbol = NULLSym) Then
    Begin
      Get;
    End  }
  If Value = '' Then
    Begin
      //dateliteral.isnull:= true;
      Expect(DATESym);
      Expect(SQLStringSym);
      DateLiteral.Value := LexString;
    End
  Else
    DateLiteral.Value := Value;
End;

Procedure TfsSql._StringLiteral(Parent: TfsSqlNode;
  Var StringLiteral: TfsSqlStringLiteral; Value: String);
Begin
  StringLiteral := TfsSqlStringLiteral.Create(Parent);
  //Expect(SQLStringSym);
  StringLiteral.Value := Value; //LexString;
End;

Procedure TfsSql._IntegerLiteral(Parent: TfsSqlNode;
  Var IntegerLiteral: TfsSqlIntegerLiteral; Value: String);
Begin
  IntegerLiteral := TfsSqlIntegerLiteral.Create(Parent);
  IntegerLiteral.Value := Value;
End;

Procedure TfsSql._Integer64Literal(Parent: TfsSqlNode;
  Var Integer64Literal: TfsSqlInteger64Literal; Value: String);
Begin
  Integer64Literal := TfsSqlInteger64Literal.Create(Parent);
  Integer64Literal.Value := Value;
End;

Procedure TfsSql._FloatLiteral(Parent: TfsSqlNode;
  Var FloatLiteral: TfsSqlFloatLiteral);
Var
  s: String;
Begin
  FloatLiteral := TfsSqlFloatLiteral.Create(Parent);
  Expect(float_Sym);
  s := LexString;
  FloatLiteral.Value := S;
End;

Procedure TfsSql._WhenClause(Parent: TfsSqlNode;
  Var WhenClause: TfsSqlWhenClause);
Var
  CondExp: TfsSqlCondExp;
  Exp: TfsSqlSimpleExpression;
Begin
  WhenClause := TfsSqlWhenClause.Create(Parent);
  Expect(WHENSym);
  _CondExp(WhenClause, CondExp);
  WhenClause.WhenExp := CondExp;
  Expect(THENSym);
  If (fCurrentInputSymbol = NULLSym) Then
    Begin
      Get;
    End
  Else If _In(symSet[1], fCurrentInputSymbol) Then
    Begin
      _SimpleExpression(WhenClause, Exp);
      WhenClause.ThenExp := Exp;
    End
  Else
    Begin
      SynError(209);
    End;
End;

Procedure TfsSql._WhenClauseList(Parent: TfsSqlNode;
  Var WhenClauseList: TfsSqlWhenClauseList);
Var
  WhenClause: TfsSqlWhenClause;
Begin
  WhenClauseList := TfsSqlWhenClauseList.Create(Parent);
  _WhenClause(WhenClauseList, WhenClause);
  WhenClauseList.AddWhenClause(WhenClause);
  While (fCurrentInputSymbol = WHENSym) Do
    Begin
      _WhenClause(WhenClauseList, WhenClause);
      WhenClauseList.AddWhenClause(WhenClause);
    End;
End;

Procedure TfsSql._CoalesceExpression(Parent: TfsSqlNode;
  Var CoalesceExp: TfsSqlCoalesceExpression);
Var
  Exp: TfsSqlSimpleExpression;
Begin
  CoalesceExp := TfsSqlCoalesceExpression.Create(Parent);
  Expect(_lparenSym);
  _SimpleExpression(CoalesceExp, Exp);
  CoalesceExp.AddArg(Exp);
  While (fCurrentInputSymbol = _commaSym) Do
    Begin
      Get;
      _SimpleExpression(CoalesceExp, Exp);
      CoalesceExp.AddArg(Exp);
    End;
  Expect(_rparenSym);
End;

Procedure TfsSql._CaseExpression(Parent: TfsSqlNode;
  Var CaseExp: TfsSqlCaseExpression);
Var
  WhenClauseList: TfsSqlWhenClauseList;
Var
  Exp: TfsSqlSimpleExpression;
Begin
  CaseExp := TfsSqlCaseExpression.Create(Parent);
  _WhenClauseList(CaseExp, WhenClauseList);
  CaseExp.WhenClauseList := WhenClauseList;
  If (fCurrentInputSymbol = ELSESym) Then
    Begin
      Get;
      If (fCurrentInputSymbol = NULLSym) Then
        Begin
          Get;
        End
      Else If _In(symSet[1], fCurrentInputSymbol) Then
        Begin
          _SimpleExpression(CaseExp, Exp);
          CaseExp.ElseExp := Exp;
        End
      Else
        Begin
          SynError(210);
        End;
    End;
  Expect(ENDSym);
End;

Procedure TfsSql._ScalarFunction(Parent: TfsSqlNode;
  Var Func: TfsSqlScalarFunc);
Var
  Exp: TfsSqlSimpleExpression;
Var
  CaseExp: TfsSqlCaseExpression;
Var
  CoalesceExp: TfsSqlCoalesceExpression;
  ft: TfsFieldType;
  fDecimals: Integer;
  fSize: Integer;
  fRound: TRound;

  Procedure _GetRound(Var ARound: TRound);
  Var
    R: Integer;
  Begin
    Get;
    Expect(integer_Sym);
    r := StrToIntDef(LexString, 0);
    Case r Of
      1: ARound := rMatAfter1;
      2: ARound := rMatAfter2;
      3: ARound := rMatAfter3;
      4: ARound := rMatAfter4;
      5: ARound := rMathematical; //5
      6: ARound := rMatAfter6;
      7: ARound := rMatAfter7;
      8: ARound := rMatAfter8;
      9: ARound := rMatAfter9;
    End;
  End;

  Procedure CheckRoundType(Var ADecimals: Integer; Var ARound: TRound);
  Begin
    ARound := rNone;
    ADecimals := 0;
    Get;
    Expect(integer_Sym);
    ADecimals := StrToIntDef(LexString, 0);
    If (fCurrentInputSymbol = _commaSym) Then
      Begin
        _GetRound(ARound);
      End;
    Expect(_rparenSym);
  End;

  Procedure CheckDataType(Var CDT: TfsFieldType; Var ADecimals: Integer; Var ASize: Integer; Var ARound: TRound);
  Var
    _min: boolean;
  Begin
    ADecimals := 0;
    ASize := 0;
    ARound := rNone;
    // CHARACTERSET - NOT YET
    Case fCurrentInputSymbol Of
      BOOLEANSym:
        Begin
          Get;
          CDT := fstBoolean;
        End;
      BYTESym:
        Begin
          Get;
          CDT := fstUInt8;
        End;
      WORD16Sym:
        Begin
          Get;
          CDT := fstUInt16;
        End;
      WORD32Sym:
        Begin
          Get;
          CDT := fstUInt32;
        End;
      INT32Sym:
        Begin
          Get;
          CDT := fstInt32;
        End;
      INT16Sym:
        Begin
          Get;
          CDT := fstInt16;
        End;
      INT8Sym:
        Begin
          Get;
          CDT := fstInt8;
        End;
      INT64Sym:
        Begin
          Get;
          CDT := fstInt64;
        End;
      RECVERSIONSYM:
        Begin
          Get;
          CDT := fstRecVersion;
          ASize := 1;
          ADecimals := 1;
          If (fCurrentInputSymbol = _lparenSym) Then
            Begin
              Get;
              Expect(integer_Sym);
              ASize := StrToIntDef(LexString, 1);
              If ASize < 1 Then
                ASize := 1;
              If (fCurrentInputSymbol = _commaSym) Then
                Begin
                  Get;
                  Expect(integer_Sym);
                  ADecimals := StrToIntDef(LexString, 1);
                End;
              Expect(_rparenSym);
            End;

        End;
      AUTOINC32Sym:
        Begin
          Get;
          CDT := fstAutoInc32;
          ASize := 0;
          ADecimals := 1;
          _min := False;
          If (fCurrentInputSymbol = _lparenSym) Then
            Begin
              Get;
              If (fCurrentInputSymbol = _minussym) Then
                Begin
                  _min := True;
                  Get;
                End;
              Expect(integer_Sym);
              ASize := StrToIntDef(LexString, 0);
              If _min Then ASize := -ASize;
              If (fCurrentInputSymbol = _commaSym) Then
                Begin
                  Get;
                  _min := False;
                  If (fCurrentInputSymbol = _minussym) Then
                    Begin
                      _min := True;
                      Get;
                    End;
                  Expect(integer_Sym);
                  ADecimals := StrToIntDef(LexString, 1);
                  If _min Then ADecimals := -ADecimals;
                End;
              Expect(_rparenSym);
            End;
        End;
      AUTOINC64Sym:
        Begin
          Get;
          CDT := fstAutoInc64;
          ASize := 0;
          ADecimals := 1;
          _min := False;
          If (fCurrentInputSymbol = _lparenSym) Then
            Begin
              Get;
              If (fCurrentInputSymbol = _minussym) Then
                Begin
                  _min := True;
                  Get;
                End;
              Expect(integer_Sym);
              ASize := StrToIntDef(LexString, 0);
              If _min Then ASize := -ASize;
              If (fCurrentInputSymbol = _commaSym) Then
                Begin
                  Get;
                  _min := False;
                  If (fCurrentInputSymbol = _minussym) Then
                    Begin
                      _min := True;
                      Get;
                    End;
                  Expect(integer_Sym);
                  ADecimals := StrToIntDef(LexString, 1);
                  If _min Then ADecimals := -ADecimals;
                End;
              Expect(_rparenSym);
            End;
        End;
      SINGLESym:
        Begin
          Get;
          CDT := fstSingle;
          ASize := 15;
          If (fCurrentInputSymbol = _lparenSym) Then
            Begin
              Get;
              Expect(integer_Sym);
              ASize := StrToIntDef(LexString, 15);
              If ASize < 1 Then
                ASize := 1;
              If (fCurrentInputSymbol = _commaSym) Then
                Begin
                  Get;
                  Expect(integer_Sym);
                  ADecimals := StrToIntDef(LexString, 0);
                  If (fCurrentInputSymbol = _commaSym) Then
                    Begin
                      _GetRound(ARound);
                    End;
                End;
              Expect(_rparenSym);
            End;
        End;
      DOUBLESym:
        Begin
          Get;
          CDT := fstDouble;
          ASize := 15;
          {If (fCurrentInputSymbol = _POSITIONSYM) Then
            Begin
              Get;
            End;}
          If (fCurrentInputSymbol = _lparenSym) Then
            Begin
              Get;
              Expect(integer_Sym);
              ASize := StrToIntDef(LexString, 15);
              If ASize < 1 Then
                ASize := 1;
              If (fCurrentInputSymbol = _commaSym) Then
                Begin
                  Get;
                  Expect(integer_Sym);
                  ADecimals := StrToIntDef(LexString, 0);
                  If (fCurrentInputSymbol = _commaSym) Then
                    Begin
                      _GetRound(ARound);
                    End;
                End;
              Expect(_rparenSym);
            End;
        End;
      EXTENDEDSym:
        Begin
          Get;
          CDT := fstExtended;
          ASize := 18;
          If (fCurrentInputSymbol = _lparenSym) Then
            Begin
              Get;
              Expect(integer_Sym);
              ASize := StrToIntDef(LexString, 18);
              If ASize < 1 Then
                ASize := 1;
              If (fCurrentInputSymbol = _commaSym) Then
                Begin
                  Get;
                  Expect(integer_Sym);
                  ADecimals := StrToIntDef(LexString, 0);
                  If (fCurrentInputSymbol = _commaSym) Then
                    Begin
                      _GetRound(ARound);
                    End;
                End;
              Expect(_rparenSym);
            End;
        End;
      CurrencySYM:
        Begin
          Get;
          CDT := fstCurrency;
          ASize := 18;
          If (fCurrentInputSymbol = _lparenSym) Then
            Begin
              Get;
              Expect(integer_Sym);
              ASize := StrToIntDef(LexString, 18);
              If ASize < 1 Then
                ASize := 1;
              If (fCurrentInputSymbol = _commaSym) Then
                Begin
                  Get;
                  Expect(integer_Sym);
                  ADecimals := StrToIntDef(LexString, 0);
                  If (fCurrentInputSymbol = _commaSym) Then
                    Begin
                      _GetRound(ARound);
                    End;
                End;
              Expect(_rparenSym);
            End;
        End;
      DATESym:
        Begin
          Get;
          CDT := fstDate;
        End;
      TIMESym:
        Begin
          Get;
          CDT := fstTime;
        End;
      TIMESTAMPSym:
        Begin
          Get;
          CDT := fstDateTime;
        End;
      BLOBSym:
        Begin
          Get;
          CDT := fstBlob;
        End;
      MEMOSym:
        Begin
          Get;
          CDT := fstBLOBMemo;
        End;
      GRAPHICSym:
        Begin
          Get;
          CDT := fstBLOBGraphic;
        End;
      BYTEARRAYSym: // 1 bajt
        Begin
          Get;
          CDT := fstArrayUInt8;
          Expect(_lparenSym);
          Expect(integer_Sym);
          ASize := StrToIntDef(LexString, 0);
          If ASize > ((32767 * 2) - 50) Then
            ASize := ((32767 * 2) - 50);
          If ASize < 1 Then
            ASize := 1;
          Expect(_rparenSym);
        End;
      WORDARRAYSym: // 2 bajt
        Begin
          Get;
          CDT := fstArrayUInt16;
          Expect(_lparenSym);
          Expect(integer_Sym);
          ASize := StrToIntDef(LexString, 0);
          If ASize > (32767 - 50) Then
            ASize := (32767 - 50);
          If ASize < 1 Then
            ASize := 1;
          Expect(_rparenSym);
        End;
      INTARRAYSym: // 4 bajty
        Begin
          Get;
          CDT := fstArrayInt32;
          Expect(_lparenSym);
          Expect(integer_Sym);
          ASize := StrToIntDef(LexString, 0);
          If ASize > (16383 - 50) Then
            ASize := (16383 - 50);
          If ASize < 1 Then
            ASize := 1;
          Expect(_rparenSym);
        End;
      DOUBLEARRAYSym: // 8 bajtow
        Begin
          Get;
          CDT := fstArrayDouble;
          Expect(_lparenSym);
          Expect(integer_Sym);
          ADecimals := 0;
          ASize := StrToIntDef(LexString, 0);
          If ASize > (8191 - 50) Then
            ASize := (8191 - 50);
          If ASize < 1 Then
            ASize := 1;
          If (fCurrentInputSymbol = _commaSym) Then
            Begin
              Get;
              Expect(integer_Sym);
              ADecimals := StrToIntDef(LexString, 0);
            End;
          Expect(_rparenSym);
        End;
      {STRINGARRAYSym:  // variable bajtow
      Begin
        Get;
        CDT := fstArrayDouble;
        Expect(_lparenSym);
        Expect(integer_Sym);
        ASize := StrToIntDef(LexString, 0);
        If ASize > (8191 - 50) Then
          ASize := (8191 - 50);
        If ASize < 1 Then
          ASize := 1;
        Expect(_rparenSym);
      End;  }
      SHORTSTRINGSym:
        Begin
          Get;
          CDT := fstShortString;
          Expect(_lparenSym);
          Expect(integer_Sym);
          ASize := StrToIntDef(LexString, 0);
          If ASize > 255 Then
            ASize := 255;
          If ASize < 1 Then
            ASize := 1;
          Expect(_rparenSym);
        End;
      SINGLECHARSym:
        Begin
          Get;
          CDT := fstSingleChar;
          ASize := 1;
          If (fCurrentInputSymbol = _lparenSym) Then
            Begin
              Get;
              Expect(_rparenSym);
            End;
        End;
      SINGLEWIDECHARSym:
        Begin
          Get;
          CDT := fstSingleWideChar;
          ASize := 1;
          If (fCurrentInputSymbol = _lparenSym) Then
            Begin
              Get;
              Expect(_rparenSym);
            End;
        End;
      WIDESTRINGSYM:
        Begin
          Get;
          CDT := fstWideString;
          Expect(_lparenSym);
          Expect(integer_Sym);
          ASize := StrToIntDef(LexString, 0);
          If ASize > 32767 Then
            ASize := 32767;
          If ASize < 1 Then
            ASize := 1;
          Expect(_rparenSym);
        End;
      {VARWIDESTRINGSYM:
        Begin
          Get;
          CDT := fstWideString;
          Expect(_lparenSym);
          Expect(integer_Sym);
          ASize := StrToIntDef(LexString, 0);
          If ASize > 32767 Then
            ASize := 32767;
          If ASize < 1 Then
            ASize := 1;
          Expect(_rparenSym);
        End;}

      NULLSTRINGSym:
        Begin
          Get;
          CDT := fstNullString;
          Expect(_lparenSym);
          Expect(integer_Sym);
          ASize := StrToIntDef(LexString, 0);
          If ASize > 32767 Then
            ASize := 32767;
          If ASize < 1 Then
            ASize := 1;
          Expect(_rparenSym);
        End;
      {VARNULLSTRINGSym:
        Begin
          Get;
          CDT := fstNullAnsiString;
          Expect(_lparenSym);
          Expect(integer_Sym);
          ASize := StrToIntDef(LexString, 0);
          If ASize > 32767 Then
            ASize := 32767;
          If ASize < 1 Then
            ASize := 1;
          Expect(_rparenSym);
        End;}
      // VARCHAR
      // NVARCHAR
      Else
        Begin
          SynError(205);
        End;
    End;
  End;

Begin
  Func := TfsSqlScalarFunc.Create(Parent);
  Case fCurrentInputSymbol Of
    CASESym:
      Begin
        Get;
        _CaseExpression(Func, CaseExp);
        Func.CaseExp := CaseExp;
        Func.SQLFunction := sfCase;
      End;
    CHARACTER_underscoreLENGTHSym:
      Begin
        Get;
        Expect(_lparenSym);
        _SimpleExpression(Func, Exp);
        Expect(_rparenSym);
        Func.SQLFunction := sfCharLen;
        Func.Arg1 := Exp;
      End;
    COALESCESym:
      Begin
        Get;
        _CoalesceExpression(Func, CoalesceExp);
        Func.CoalesceExp := CoalesceExp;
        Func.SQLFunction := sfCoalesce;
      End;
    CURRENT_underscoreDATESym:
      Begin
        Get;
        Func.SQLFunction := sfCurrentDate;
      End;
    CURRENT_underscoreTIMESym:
      Begin
        Get;
        Func.SQLFunction := sfCurrentTime;
      End;
    CURRENT_underscoreTIMESTAMPSym:
      Begin
        Get;
        Func.SQLFunction := sfCurrentTimestamp;
      End;
    USERSym:
      Begin
        Get;
        Func.SQLFunction := sfCurrentUser;
      End;
    ISRECORDLOCKEDSym:
      Begin
        Get;
        Func.SQLFunction := sfISRECORDLOCKED;
      End;
    ISUNDELETEDRECORDSYM:
      Begin
        Get;
        Func.SQLFunction := sfISUNDELETEDRECORD;
      End;
    ISPROTECTDELETERECORDSYM:
      Begin
        Get;
        Func.SQLFunction := sfISPROTECTDELETERECORD;
      End;
    ISPROTECTUPDATERECORDSYM:
      Begin
        Get;
        Func.SQLFunction := sfISPROTECTUPDATERECORD;
      End;
    ISMARKASBADRECORDSYM:
      Begin
        Get;
        Func.SQLFunction := sfISMARKASBADRECORD;
      End;
    LOWERSym:
      Begin
        Get;
        Expect(_lparenSym);
        _SimpleExpression(Func, Exp);
        Expect(_rparenSym);
        Func.SQLFunction := sfLower;
        Func.Arg1 := Exp
      End;
    UPPERSym:
      Begin
        Get;
        Expect(_lparenSym);
        _SimpleExpression(Func, Exp);
        Expect(_rparenSym);
        Func.SQLFunction := sfUpper;
        Func.Arg1 := Exp;
      End;
    POSITIONSym:
      Begin
        Get;
        Expect(_lparenSym);
        _SimpleExpression(Func, Exp);
        Func.SQLFunction := sfPosition;
        Func.Arg1 := Exp;
        If (fCurrentInputSymbol = _commaSym) Then
          Begin
            Get;
          End
        Else If (fCurrentInputSymbol = INSym) Then
          Begin
            Get;
          End
        Else
          Begin
            SynError(211);
          End;
        _SimpleExpression(Func, Exp);
        Func.Arg2 := Exp;
        Expect(_rparenSym);
      End;
    FLAGSsym:
      Begin
        Get;
        Expect(_lparenSym);
        _SimpleExpression(Func, Exp);
        Func.SQLFunction := sfFlags;
        Func.Arg1 := Exp;
        If (fCurrentInputSymbol = _commaSym) Then
          Begin
            Get;
          End
        Else If (fCurrentInputSymbol = INSym) Then
          Begin
            Get;
          End
        Else
          Begin
            SynError(211);
          End;
        _SimpleExpression(Func, Exp);
        Func.Arg2 := Exp;
        Expect(_rparenSym);
      End;
    SUBSTRINGSym:
      Begin
        Get;
        Expect(_lparenSym);
        _SimpleExpression(Func, Exp);
        Func.SQLFunction := sfSubstring;
        Func.Arg1 := Exp;
        Expect(FROMSym);
        _SimpleExpression(Func, Exp);
        Func.Arg2 := Exp;
        If (fCurrentInputSymbol = FORSym) Then
          Begin
            Get;
            _SimpleExpression(Func, Exp);
            Func.Arg3 := Exp;
          End;
        Expect(_rparenSym);
      End;
    WeekNoSym:
      Begin
        Get;
        Expect(_lparenSym);
        Func.SQLFunction := sfWeekNo;
        _SimpleExpression(Func, Exp);
        Func.Arg1 := Exp;
        Expect(_rparenSym);
      End;
    ARRAYSym:
      Begin
        Get;
        Expect(_lparenSym);
        Func.SQLFunction := sfArray;
        _SimpleExpression(Func, Exp);
        Func.Arg1 := Exp; // fieldname
        Expect(_commaSym); //1
        _SimpleExpression(Func, Exp);
        Func.Arg2 := Exp; // position
        If (fCurrentInputSymbol = _commaSym) Then
          Begin
            get;
            _SimpleExpression(Func, Exp);
            Func.Arg3 := Exp; // setvalue
          End;
        Expect(_rparenSym);
        Func.ArrayIndex := True;
      End;
    ROUNDsym:
      Begin
        Get;
        Expect(_lparenSym);
        Func.SQLFunction := sfRound;
        _SimpleExpression(Func, Exp);
        Func.Arg1 := Exp;
        func.Size := 20;
        If (fCurrentInputSymbol = _commaSym) Then
          Begin
            CheckRoundType(fDecimals, fRound);
            func.Decimals := fDecimals;
            Func.RoundType := fRound;
          End
        Else
          Expect(_rparenSym);
      End;
    CASTSym:
      Begin
        Get;
        Expect(_lparenSym);
        Func.SQLFunction := sfCast;
        Func.IsCastNull := False;
        If _In(symSet[2], fCurrentInputSymbol) Then
          Begin
            _SimpleExpression(Func, Exp);
            Func.Arg1 := Exp;
          End
        Else If (fCurrentInputSymbol = NULLSym) Then
          Begin
            Get;
            Func.IsCastNull := True;
          End
        Else
          Begin
            SynError(86);
          End;
        Expect(ASSym);
        CheckDataType(fT, fDecimals, fSize, fRound);
        Func.DataType := ft;
        func.Decimals := fDecimals;
        Func.Size := fSize;
        Func.RoundType := fRound;
        Expect(_rparenSym);
      End;
    TRIMSym:
      Begin
        Get;
        Expect(_lparenSym);
        Func.SQLFunction := sfTrim;
        Func.LTB := ltbBoth;
        If (fCurrentInputSymbol = LEADINGSym) Or
          (fCurrentInputSymbol = TRAILINGSym) Or
          (fCurrentInputSymbol = BOTHSym) Then
          Begin
            If (fCurrentInputSymbol = LEADINGSym) Then
              Begin
                Get;
                Func.LTB := ltbLeading;
              End
            Else If (fCurrentInputSymbol = TRAILINGSym) Then
              Begin
                Get;
                Func.LTB := ltbTrailing;
              End
            Else
              Begin
                Get;
              End;
          End;
        If _In(symSet[1], fCurrentInputSymbol) Then
          Begin
            _SimpleExpression(Func, Exp);
            Func.Arg1 := Exp;
          End;
        If (fCurrentInputSymbol = FROMSym) Then
          Begin
            Get;
            _SimpleExpression(Func, Exp);
            Func.Arg2 := Exp
          End;
        Expect(_rparenSym);
      End;
    EXTRACTSym:
      Begin
        Get;
        Expect(_lparenSym);
        Func.SQLFunction := sfExtract;
        Case fCurrentInputSymbol Of
          YEARSym:
            Begin
              Get;
              Func.xDef := iYear;
            End;
          MONTHSym:
            Begin
              Get;
              Func.xDef := iMonth;
            End;
          DAYSym:
            Begin
              Get;
              Func.xDef := iDay;
            End;
          HOURSym:
            Begin
              Get;
              Func.xDef := iHour;
            End;
          MINUTESym:
            Begin
              Get;
              Func.xDef := iMinute;
            End;
          SECONDSym:
            Begin
              Get;
              Func.xDef := iSecond;
            End;
          Else
            Begin
              SynError(212);
            End;
        End;
        Expect(FROMSym);
        _SimpleExpression(Func, Exp);
        Func.Arg1 := Exp;
        Expect(_rparenSym);
      End;
    NULLIFSym:
      Begin
        Get;
        Expect(_lparenSym);
        Func.SQLFunction := sfNullIf;
        _SimpleExpression(Func, Exp);
        Func.Arg1 := Exp;
        Expect(_commaSym);
        _SimpleExpression(Func, Exp);
        Func.Arg2 := Exp;
        Expect(_rparenSym);
      End;
    ABSSym:
      Begin
        Get;
        Expect(_lparenSym);
        Func.SQLFunction := sfAbs;
        _SimpleExpression(Func, Exp);
        Func.Arg1 := Exp;
        Expect(_rparenSym);
      End;
    ODDSym:
      Begin
        Get;
        Expect(_lparenSym);
        Func.SQLFunction := sfODD;
        _SimpleExpression(Func, Exp);
        Func.Arg1 := Exp;
        Expect(_rparenSym);
      End;
    MODSym:
      Begin
        Get;
        Expect(_lparenSym);
        Func.SQLFunction := sfMOD;
        _SimpleExpression(Func, Exp);
        Func.Arg1 := Exp;
        Expect(_commaSym);
        _SimpleExpression(Func, Exp);
        Func.Arg2 := Exp;
        Expect(_rparenSym);
      End;
    DIVSym:
      Begin
        Get;
        Expect(_lparenSym);
        Func.SQLFunction := sfDIV;
        _SimpleExpression(Func, Exp);
        Func.Arg1 := Exp;
        Expect(_commaSym);
        _SimpleExpression(Func, Exp);
        Func.Arg2 := Exp;
        Expect(_rparenSym);
      End;
    CEILINGSym:
      Begin
        Get;
        Expect(_lparenSym);
        Func.SQLFunction := sfCeil;
        _SimpleExpression(Func, Exp);
        Func.Arg1 := Exp;
        Expect(_rparenSym);
      End;
    FLOORSym:
      Begin
        Get;
        Expect(_lparenSym);
        Func.SQLFunction := sfFloor;
        _SimpleExpression(Func, Exp);
        Func.Arg1 := Exp;
        Expect(_rparenSym);
      End;
    EXPSym:
      Begin
        Get;
        Expect(_lparenSym);
        Func.SQLFunction := sfExp;
        _SimpleExpression(Func, Exp);
        Func.Arg1 := Exp;
        Expect(_rparenSym);
      End;
    LOGSym:
      Begin
        Get;
        Expect(_lparenSym);
        Func.SQLFunction := sfLog;
        _SimpleExpression(Func, Exp);
        Func.Arg1 := Exp;
        Expect(_rparenSym);
      End;
    POWERSym:
      Begin
        Get;
        Expect(_lparenSym);
        Func.SQLFunction := sfPower;
        _SimpleExpression(Func, Exp);
        Func.Arg1 := Exp;
        Expect(_commaSym);
        _SimpleExpression(Func, Exp);
        Func.Arg2 := Exp;
        Expect(_rparenSym);
      End;
    RANDSym:
      Begin
        Get;
        Func.SQLFunction := sfRand;
      End;
    Else
      Begin
        SynError(213);
      End;
  End;
End;

Procedure TfsSql._Param(Parent: TfsSqlNode;
  Var Param: TfsSqlParam);
Begin
  Param := TfsSqlParam.Create(Parent);
  Expect(_querySym);
End;

Procedure TfsSql._Literal(Parent: TfsSqlNode;
  Var Literal: TfsSqlLiteral);
Var
  FloatLiteral: TfsSqlFloatLiteral;
Var
  IntegerLiteral: TfsSqlIntegerLiteral;
Var
  Integer64Literal: TfsSqlInteger64Literal;
Var
  StringLiteral: TfsSqlStringLiteral;
Var
  DateLiteral: TfsSqlDateLiteral;
Var
  TimeLiteral: TfsSqlTimeLiteral;
Var
  TimestampLiteral: TfsSqlTimestampLiteral;
Var
  IntervalLiteral: TfsSqlIntervalLiteral;
Var
  BooleanLiteral: TfsSqlBooleanLiteral;

Var
  Int6: Int64;
  Int3: Longint;
  S: String;

  Function IsValidTimestamp(Const S: ShortString): boolean;
  Begin
    If (length(S) < 19)
      Or Not (S[5] In ['-', '.', '/'])
      Or (S[8] <> S[5])
      Or (S[11] <> ' ')
      Or (S[14] <> ':')
      Or (S[17] <> ':') Then
      Result := False
    Else
      Try
        EncodeDate(
          StrToInt(copy(S, 1, 4)),
          StrToInt(copy(S, 6, 2)),
          StrToInt(copy(S, 9, 2)));
        EncodeTime(
          StrToInt(copy(S, 12, 2)),
          StrToInt(copy(S, 15, 2)),
          StrToInt(copy(S, 18, 2)),
          0);
        Result := True;
      Except
        Result := False;
      End;
  End;

  Function VrStrToTimestamp(Const S: ShortString): TDateTime;
  Begin
    Result := EncodeDate(
      StrToInt(copy(S, 1, 4)),
      StrToInt(copy(S, 6, 2)),
      StrToInt(copy(S, 9, 2)))
      +
      EncodeTime(
      StrToInt(copy(S, 12, 2)),
      StrToInt(copy(S, 15, 2)),
      StrToInt(copy(S, 18, 2)),
      0);
    fsSetMillisecond(Result, 0);
  End;

  Function IsValidDate(Const S: ShortString): Boolean;
  Begin
    If (length(S) < 10)
      Or Not (S[5] In ['-', '.', '/'])
      Or (S[8] <> S[5]) Then
      Result := False
    Else
      Try
        EncodeDate(
          StrToInt(copy(S, 1, 4)),
          StrToInt(copy(S, 6, 2)),
          StrToInt(copy(S, 9, 2)));
        Result := True;
      Except
        Result := False;
      End;
  End;

  Function IsValidTime(Const S: ShortString): Boolean;
  Begin
    If (length(S) < 8)
      Or (S[3] <> ':')
      Or (S[6] <> ':') Then
      Result := False
    Else
      Try
        EncodeTime(
          StrToInt(copy(S, 1, 2)),
          StrToInt(copy(S, 4, 2)),
          StrToInt(copy(S, 7, 2)),
          0);
        Result := True;
      Except
        Result := False;
      End;
  End;

  Procedure RemoveQuotes(Var s: String);
  Begin
    If (s[1] = '"') And (s[Length(s)] = '"') Then
      s := Copy(s, 2, Length(s) - 2);
    If (s[1] = '''') And (s[Length(s)] = '''') Then
      s := Copy(s, 2, Length(s) - 2);
  End;

  Procedure deletesep;
  Var
    i: Integer;
  Begin
    For i := 1 To Length(s) Do
      Begin
        If s[i] In [DecimalSeparator, '.'] Then
          s[i] := DecimalSeparator;
      End;
  End;
Begin
  Literal := TfsSqlLiteral.Create(Parent);
  Case fCurrentInputSymbol Of
    float_Sym:
      Begin
        _FloatLiteral(Literal, FloatLiteral);
        Literal.FloatLiteral := FloatLiteral;
      End;
    integer_Sym:
      Begin
        Expect(integer_Sym);
        S := LexString;
        Int6 := strtoint64(S);
        If (Int6 > High(int3)) Or (Int6 < Low(int3)) Then
          Begin
            _Integer64Literal(Literal, Integer64Literal, S);
            Literal.Integer64Literal := Integer64Literal;
          End
        Else
          Begin
            _IntegerLiteral(Literal, IntegerLiteral, S);
            Literal.IntegerLiteral := IntegerLiteral;
          End;
      End;
    SQLStringSym:
      Begin
        Expect(SQLStringSym);
        S := LexString;
        If IsValidTimestamp(S) Then
          Begin
            _TimestampLiteral(Literal, TimestampLiteral, S);
            Literal.TimestampLiteral := TimestampLiteral;
          End
        Else If IsValidDate(S) Then
          Begin
            _DateLiteral(Literal, DateLiteral, S);
            Literal.DateLiteral := DateLiteral;
          End
        Else If IsValidTime(S) Then
          Begin
            _TimeLiteral(Literal, TimeLiteral, S);
            Literal.TimeLiteral := TimeLiteral;
          End
        Else
          Begin
            _StringLiteral(Literal, StringLiteral, S);
            Literal.StringLiteral := StringLiteral;
          End;
      End;
    DATESym:
      Begin
        _DateLiteral(Literal, DateLiteral);
        Literal.DateLiteral := DateLiteral;
      End;
    TIMESym:
      Begin
        _TimeLiteral(Literal, TimeLiteral);
        Literal.TimeLiteral := TimeLiteral;
      End;
    TIMESTAMPSym:
      Begin
        _TimestampLiteral(Literal, TimestampLiteral);
        Literal.TimestampLiteral := TimestampLiteral;
      End;
    INTERVALSym:
      Begin
        _IntervalLiteral(Literal, IntervalLiteral);
        Literal.IntervalLiteral := IntervalLiteral;
      End;
    TRUESym, FALSESym:
      Begin
        _BooleanLiteral(Literal, BooleanLiteral);
        Literal.BooleanLiteral := BooleanLiteral;
      End;
    {Else If ( fCurrentInputSymbol = BlobStringSym ) Then
  Begin
    _BlobLiteral( Parent, BlobLiteral );
    Literal := BlobLiteral;
  End}
    {NullSym:
    Begin
      _NullLiteral(Literal, NullLiteral);
      Literal.NullLiteral := NullLiteral;
    End;  }
    Else
      Begin
        SynError(214);
      End;
  End;
End;

Procedure TfsSql._Factor(Parent: TfsSqlNode;
  Var Factor: TfsSqlFactor;
  MulOp: TfsSqlMulOp);
Var
  FieldRef: TfsSqlFieldRef;
Var
  CondExp: TfsSqlCondExp;
Var
  Literal: TfsSqlLiteral;
Var
  Param: TfsSqlParam;
Var
  Select: TfsSqlSELECT;
Var
  Agg: TfsSqlAggregate;
Var
  Func: TfsSqlScalarFunc;
Begin
  Factor := TfsSqlFactor.Create(Parent);
  Factor.MulOp := MulOp;
  If (fCurrentInputSymbol = _minusSym) Then
    Begin
      Get;
      Factor.UnaryMinus := True;
    End;
  Case fCurrentInputSymbol Of
    _lparenSym:
      Begin
        Get;
        If _In(symSet[2], fCurrentInputSymbol) Then
          Begin
            _CondExp(Factor, CondExp);
            Factor.CondExp := CondExp;
          End
        Else If (fCurrentInputSymbol = SELECTSym) Then
          Begin
            _SelectStatement(Factor, Select);
            Factor.SubQuery := Select;
          End
        Else
          Begin
            SynError(215);
          End;
        Expect(_rparenSym);
      End;
    identSym, SQLNameStringSym:
      Begin
        _FieldRef(Factor, FieldRef);
        Factor.FieldRef := FieldRef;
      End;
    integer_Sym, float_Sym, SQLStringSym, TRUESym, FALSESym, DATESym, TIMESym,
      TIMESTAMPSym, INTERVALSym:
      Begin
        _Literal(Factor, Literal);
        Factor.Literal := Literal;
      End;
    _querySym:
      Begin
        _Param(Factor, Param);
        Factor.Param := Param;
      End;
    COUNTSym, MINSym, MAXSym, SUMSym, AVGSym:
      Begin
        _Aggregate(Factor, Agg);
        Factor.Aggregate := Agg;
      End;
    CASESym, CHARACTER_underscoreLENGTHSym, FLAGSsym, COALESCESym, CURRENT_underscoreDATESym, CURRENT_underscoreTIMESym,
      CURRENT_underscoreTIMESTAMPSym,
      USERSym, LOWERSym, UPPERSym, POSITIONSym, WeekNoSym, SUBSTRINGSym,
      TRIMSym, EXTRACTSym, NULLIFSym, ABSSym, CEILINGSym, FLOORSym, EXPSym, LOGSym,
      POWERSym, RANDSym, ROUNDSym, CASTSym, MODSym, DIVSym, ODDSym, ARRAYsym,
      LASTAUTOINCSYM, NEXTAUTOINCSYM, READLASTAUTOINCSYM, ISRECORDLOCKEDSYM,
      ISUNDELETEDRECORDSYM,
      ISPROTECTDELETERECORDSYM,
      ISPROTECTUPDATERECORDSYM,
      ISMARKASBADRECORDSYM:
      Begin
        _ScalarFunction(Factor, Func);
        Factor.ScalarFunc := Func;
      End;
    Else
      Begin
        SynError(216);
      End;
  End;
End;

Procedure TfsSql._Term(Parent: TfsSqlNode; Var Term: TfsSqlTerm; AddOp: TfsSqlAddOp);
Var
  Factor: TfsSqlFactor;
Var
  MO: TfsSqlMulOp;
Begin
  Term := TfsSqlTerm.Create(Parent);
  Term.AddOp := AddOp;
  _Factor(Term, Factor, moMul);
  Term.AddFactor(Factor);
  While (fCurrentInputSymbol = _starSym) Or
    (fCurrentInputSymbol = _slashSym) Do
    Begin
      If (fCurrentInputSymbol = _starSym) Then
        Begin
          Get;
          MO := moMul;
        End
      Else
        Begin
          Get;
          MO := moDiv;
        End;
      _Factor(Term, Factor, MO);
      Term.AddFactor(Factor);
    End;
End;

Procedure TfsSql._SimpleExpressionList(Parent: TfsSqlNode;
  Var SimpleExpressionList: TfsSqlSimpleExpressionList);
Var
  SimpleExpression: TfsSqlSimpleExpression;
Begin
  SimpleExpressionList := TfsSqlSimpleExpressionList.Create(Parent);
  _SimpleExpression(SimpleExpressionList, SimpleExpression);
  SimpleExpressionList.AddExpression(SimpleExpression);
  While (fCurrentInputSymbol = _commaSym) Do
    Begin
      Get;
      _SimpleExpression(SimpleExpressionList, SimpleExpression);
      SimpleExpressionList.AddExpression(SimpleExpression);
    End;
End;

Procedure TfsSql._IsTest(Parent: TfsSqlNode;
  Var IsTest: TfsSqlIsTest);
Begin
  Expect(ISSym);
  IsTest := TfsSqlIsTest.Create(Parent);
  If (fCurrentInputSymbol = NOTSym) Then
    Begin
      Get;
      IsTest.UnaryNot := True;
    End;
  If (fCurrentInputSymbol = NULLSym) Then
    Begin
      Get;
      IsTest.IsOp := ioNull;
    End
  Else If (fCurrentInputSymbol = TRUESym) Then
    Begin
      Get;
      IsTest.IsOp := ioTrue;
    End
  Else If (fCurrentInputSymbol = FALSESym) Then
    Begin
      Get;
      IsTest.IsOp := ioFalse;
    End
  Else If (fCurrentInputSymbol = UNKNOWNSym) Then
    Begin
      Get;
      IsTest.IsOp := ioUnknown;
    End
  Else
    Begin
      SynError(217);
    End;
End;

Procedure TfsSql._MatchClause(Parent: TfsSqlNode;
  Var MatchClause: TfsSqlMatchClause);
Var
  Select: TfsSqlSelect;
Begin
  MatchClause := TfsSqlMatchClause.Create(Parent);
  Expect(MATCHSym);
  If (fCurrentInputSymbol = UNIQUESym) Then
    Begin
      Get;
      MatchClause.Unique := True;
    End;
  MatchClause.Option := moUnspec;
  If (fCurrentInputSymbol = FULLSym) Or
    (fCurrentInputSymbol = PARTIALSym) Then
    Begin
      If (fCurrentInputSymbol = PARTIALSym) Then
        Begin
          Get;
          MatchClause.Option := moPartial;
        End
      Else
        Begin
          Get;
          MatchClause.Option := moFull;
        End;
    End;
  Expect(_lparenSym);
  _SelectStatement(MatchClause, Select);
  MatchClause.SubQuery := Select;
  Expect(_rparenSym);
End;

Procedure TfsSql._InClause(Parent: TfsSqlNode;
  Var InClause: TfsSqlInClause;
  Negated: Boolean);
Var
  SimpleExpressionList: TfsSqlSimpleExpressionList;
Var
  Select: TfsSqlSelect;
Begin
  InClause := TfsSqlInClause.Create(Parent);
  InClause.Negated := Negated;
  Expect(INSym);
  Expect(_lparenSym);
  If (fCurrentInputSymbol = SELECTSym) Then
    Begin
      _SelectStatement(InClause, Select);
      InClause.SubQuery := Select;
    End
  Else If _In(symSet[1], fCurrentInputSymbol) Then
    Begin
      _SimpleExpressionList(InClause, SimpleExpressionList);
      Inclause.SimpleExpList := SimpleExpressionList;
    End
  Else
    Begin
      SynError(218);
    End;
  Expect(_rparenSym);
End;

Procedure TfsSql._LikeClause(Parent: TfsSqlNode;
  Var LikeClause: TfsSqlLikeClause;
  Negated: Boolean);
Var
  SimpleExpression: TfsSqlSimpleExpression;
Begin
  LikeClause := TfsSqlLikeClause.Create(Parent);
  LikeClause.Negated := Negated;
  Expect(LIKESym);
  _SimpleExpression(LikeClause, SimpleExpression);
  LikeClause.SimpleExp := SimpleExpression;
  If (fCurrentInputSymbol = ESCAPESym) Then
    Begin
      Get;
      _SimpleExpression(LikeClause, SimpleExpression);
      LikeClause.EscapeExp := SimpleExpression;
    End;
  If (fCurrentInputSymbol = IGNORESym) Then
    Begin
      Get;
      Expect(CASESym);
      LikeClause.IgnoreCase := True;
    End;
End;

Procedure TfsSql._BetweenClause(Parent: TfsSqlNode;
  Var BetweenClause: TfsSqlBetweenClause;
  Negated: Boolean);
Var
  SimpleExpression: TfsSqlSimpleExpression;
Begin
  BetweenClause := TfsSqlBetweenClause.Create(Parent);
  BetweenClause.Negated := Negated;
  Expect(BETWEENSym);
  _SimpleExpression(BetweenClause, SimpleExpression);
  BetweenClause.SimpleLow := SimpleExpression;
  Expect(ANDSym);
  _SimpleExpression(BetweenClause, SimpleExpression);
  BetweenClause.SimpleHigh := SimpleExpression;
End;

Procedure TfsSql._AllOrAnyClause(Parent: TfsSqlNode;
  Var AllOrAny: TfsSqlAllOrAnyClause);
Var
  Select: TfsSqlSelect;
Begin
  AllOrAny := TfsSqlAllOrAnyClause.Create(Parent);
  If (fCurrentInputSymbol = ALLSym) Then
    Begin
      Get;
      AllOrAny.All := True;
    End
  Else If (fCurrentInputSymbol = ANYSym) Then
    Begin
      Get;
    End
  Else If (fCurrentInputSymbol = SOMESym) Then
    Begin
      Get;
    End
  Else
    Begin
      SynError(219);
    End;
  Expect(_lparenSym);
  _SelectStatement(AllOrAny, Select);
  AllOrAny.SubQuery := Select;
  Expect(_rparenSym);
End;

Procedure TfsSql._UniqueClause(Parent: TfsSqlNode;
  Var Unique: TfsSqlUniqueClause);
Var
  TableExp: TfsSqlTableExp;
Begin
  Unique := TfsSqlUniqueClause.Create(Parent);
  Expect(UNIQUESym);
  Expect(_lparenSym);
  _TableExp(Unique, TableExp);
  Unique.SubQuery := TableExp;
  Expect(_rparenSym);
End;

Procedure TfsSql._ExistsClause(Parent: TfsSqlNode;
  Var Exists: TfsSqlExistsClause);
Var
  Select: TfsSqlSelect;
Begin
  Exists := TfsSqlExistsClause.Create(Parent);
  Expect(EXISTSSym);
  Expect(_lparenSym);
  _SelectStatement(Exists, Select);
  Exists.SubQuery := Select;
  Expect(_rparenSym);
End;

Procedure TfsSql._CondPrimary(Parent: TfsSqlNode;
  Var CondPrimary: TfsSqlCondPrimary);
Var
  SimpleExpression: TfsSqlSimpleExpression;
Var
  RelOp: TfsSqlRelop;
Var
  BetweenClause: TfsSqlBetweenClause;
Var
  LikeClause: TfsSqlLikeClause;
Var
  InClause: TfsSqlInClause;
Var
  IsTest: TfsSqlIsTest;
Var
  AllOrAny: TfsSqlAllOrAnyClause;
Var
  ExistsClause: TfsSqlExistsClause;
Var
  UniqueClause: TfsSqlUniqueClause;
Var
  MatchClause: TfsSqlMatchClause;
Begin
  CondPrimary := TfsSqlCondPrimary.Create(Parent);
  RelOp := roNone;
  If (fCurrentInputSymbol = EXISTSSym) Then
    Begin
      _ExistsClause(CondPrimary, ExistsClause);
      CondPrimary.ExistsClause := ExistsClause;
    End
  Else If (fCurrentInputSymbol = UNIQUESym) Then
    Begin
      _UniqueClause(CondPrimary, UniqueClause);
      CondPrimary.UniqueClause := UniqueClause;
    End
  Else If _In(symSet[1], fCurrentInputSymbol) Then
    //Result := x Mod setsize In s[x Div setsize];
    Begin
      _SimpleExpression(CondPrimary, SimpleExpression);
      CondPrimary.SimpleExp1 := SimpleExpression;
      If _In(symSet[3], fCurrentInputSymbol) Then
        Begin
          If _In(symSet[4], fCurrentInputSymbol) Then
            Begin
              Case fCurrentInputSymbol Of
                _equalSym, _less_equalSym, _lessSym, _greaterSym, _greater_equalSym, _less_greaterSym:
                  Begin
                    Case fCurrentInputSymbol Of
                      _equalSym:
                        Begin
                          Get;
                          RelOp := roEQ;
                        End;
                      _less_equalSym:
                        Begin
                          Get;
                          RelOp := roLE;
                        End;
                      _lessSym:
                        Begin
                          Get;
                          RelOp := roL;
                        End;
                      _greaterSym:
                        Begin
                          Get;
                          RelOp := roG;
                        End;
                      _greater_equalSym:
                        Begin
                          Get;
                          RelOp := roGE;
                        End;
                      _less_greaterSym:
                        Begin
                          Get;
                          RelOp := roNE;
                        End;
                      Else
                        Begin
                          SynError(220);
                        End;
                    End;
                    CondPrimary.RelOp := RelOp;
                    If (fCurrentInputSymbol = ALLSym) Or
                      (fCurrentInputSymbol = ANYSym) Or
                      (fCurrentInputSymbol = SOMESym) Then
                      Begin
                        _AllOrAnyClause(CondPrimary, AllOrAny);
                        CondPrimary.AllOrAnyClause := AllOrAny;
                      End
                    Else If _In(symSet[1], fCurrentInputSymbol) Then
                      Begin
                        _SimpleExpression(CondPrimary, SimpleExpression);
                        CondPrimary.SimpleExp2 := SimpleExpression;
                      End
                    Else
                      Begin
                        SynError(221);
                      End;
                  End;
                BETWEENSym:
                  Begin
                    _BetweenClause(CondPrimary, BetweenClause, False);
                    CondPrimary.BetweenClause := BetweenClause;
                  End;
                LIKESym:
                  Begin
                    _LikeClause(CondPrimary, LikeClause, False);
                    CondPrimary.LikeClause := LikeClause;
                  End;
                INSym:
                  Begin
                    _InClause(CondPrimary, InClause, False);
                    CondPrimary.InClause := InClause;
                  End;
                MATCHSym:
                  Begin
                    _MatchClause(CondPrimary, MatchClause);
                    CondPrimary.MatchClause := MatchClause;
                  End;
                NOTSym:
                  Begin
                    Get;
                    If (fCurrentInputSymbol = BETWEENSym) Then
                      Begin
                        _BetweenClause(CondPrimary, BetweenClause, True);
                        CondPrimary.BetweenClause := BetweenClause;
                      End
                    Else If (fCurrentInputSymbol = LIKESym) Then
                      Begin
                        _LikeClause(CondPrimary, LikeClause, True);
                        CondPrimary.LikeClause := LikeClause;
                      End
                    Else If (fCurrentInputSymbol = INSym) Then
                      Begin
                        _InClause(CondPrimary, InClause, True);
                        CondPrimary.InClause := InClause;
                      End
                    Else
                      Begin
                        SynError(222);
                      End;
                  End;
                Else
                  Begin
                    SynError(223);
                  End;
              End;
            End
          Else
            Begin
              _IsTest(CondPrimary, IsTest);
              CondPrimary.IsTest := IsTest;
              CondPrimary.RelOp := RoNone;
            End;
        End;
    End
  Else
    Begin
      SynError(224);
    End;
End;

Procedure TfsSql._CondFactor(Parent: TfsSqlNode;
  Var CondFactor: TfsSqlCondFactor);
Var
  CondPrimary: TfsSqlCondPrimary;
Begin
  CondFactor := TfsSqlCondFactor.Create(Parent);
  If (fCurrentInputSymbol = NOTSym) Then
    Begin
      Get;
      CondFactor.UnaryNot := True;
    End;
  _CondPrimary(CondFactor, CondPrimary);
  CondFactor.CondPrimary := CondPrimary;
End;

Procedure TfsSql._CondTerm(Parent: TfsSqlNode;
  Var CondTerm: TfsSqlCondTerm);
Var
  CondFactor: TfsSqlCondFactor;
Begin
  CondTerm := TfsSqlCondTerm.Create(Parent);
  _CondFactor(CondTerm, CondFactor);
  CondTerm.AddCondFactor(CondFactor);
  While (fCurrentInputSymbol = ANDSym) Do
    Begin
      Get;
      _CondFactor(CondTerm, CondFactor);
      CondTerm.AddCondFactor(CondFactor);
    End;
End;

Procedure TfsSql._GroupColumn(Parent: TfsSqlNode;
  Var Col: TfsSqlGroupColumn);
Var
  aSQLName: String;
Begin
  Col := TfsSqlGroupColumn.Create(Parent);
  aSQLName := '';
  _SQLName(aSQLName);
  If (fCurrentInputSymbol = _pointSym) Then
    Begin
      Get;
      Col.TableName := aSQLName;
      _SQLName(aSQLName);
    End;
  Col.FieldName := aSQLName;
End;

Procedure TfsSql._UnionGroupColumn(UnionParent: TfsSqlNode;
  Var Col: TfsSqlGroupColumn);
Var
  aSQLName: String;
Begin
  Col := TfsSqlGroupColumn.Create(UnionParent);
  aSQLName := '';
  _SQLName(aSQLName);
  If (fCurrentInputSymbol = _pointSym) Then
    Begin
      Get;
      Col.TableName := aSQLName;
      _SQLName(aSQLName);
    End;
  Col.FieldName := aSQLName;
End;

Procedure TfsSql._FieldRef(Parent: TfsSqlNode; Var FieldRef: TfsSqlFieldRef);
Var
  aSQLName: String;
Begin
  FieldRef := TfsSqlFieldRef.Create(Parent);
  aSQLName := '';
  _SQLName(aSQLName);
  If (fCurrentInputSymbol = _pointSym) Then
    Begin
      Get;
      FieldRef.TableName := aSQLName;
      If (fCurrentInputSymbol = identSym) Or
        (fCurrentInputSymbol = SQLNameStringSym) Then
        Begin
          _SQLName(aSQLName);
        End
      Else If (fCurrentInputSymbol = _starSym) Then
        Begin
          Get;
          aSQLName := '';
        End
      Else
        Begin
          SynError(225);
        End;
    End;
  FieldRef.FieldName := aSQLName;
End;

Procedure TfsSql._Aggregate(Parent: TfsSqlNode; Var Aggregate: TfsSqlAggregate);
Var
  SimpleExpression: TfsSqlSimpleExpression;
Begin
  If Parent.OwnerSelect.InWhere Then
    SynError(302);
  Aggregate := TfsSqlAggregate.Create(Parent);
  Aggregate.DistinctOnlyList := False;
  If (fCurrentInputSymbol = COUNTSym) Then
    Begin
      Get;
      Aggregate.AgFunction := agCount;
      Expect(_lparenSym);
      If (fCurrentInputSymbol = _starSym) Then
        Begin
          Get;
        End
      Else If _In(symSet[5], fCurrentInputSymbol) Then
        Begin
          If (fCurrentInputSymbol = ALLSym) Or
            (fCurrentInputSymbol = DISTINCTSym) Then
            Begin
              If (fCurrentInputSymbol = ALLSym) Then
                Begin
                  Get;
                End
              Else If (fCurrentInputSymbol = DISTINCTSym) Then
                Begin
                  Get;
                  Aggregate.Distinct := True;
                  Aggregate.DistinctCase := True;
                  Aggregate.DistinctOnlyList := False;
                  If (fCurrentInputSymbol = _lparenSym) Then
                    Begin
                      Get;
                      Aggregate.DistinctOnlyList := True;
                      // _SimpleExpression(Aggregate, SimpleExpression);
                      // Aggregate.SimpleExpression := SimpleExpression;
                      Expect(_rparenSym);
                    End;
                  If (fCurrentInputSymbol = CaseSym) Then
                    Begin
                      Get;
                      If (fCurrentInputSymbol = FalseSym) Or
                        (fCurrentInputSymbol = TrueSym) Then
                        Begin
                          If (fCurrentInputSymbol = FalseSym) Then
                            Aggregate.DistinctCase := False;
                          Get;
                        End;
                    End;
                End;
            End;
          _SimpleExpression(Aggregate, SimpleExpression);
          Aggregate.SimpleExpression := SimpleExpression;
        End
      Else If (fCurrentInputSymbol = ONLINESym) Then
        Begin
          Get;
        End
      Else
        Begin
          SynError(226);
        End;
      Expect(_rparenSym);
    End
  Else If (fCurrentInputSymbol = MINSym) Or
    (fCurrentInputSymbol = MAXSym) Or
    (fCurrentInputSymbol = SUMSym) Or
    (fCurrentInputSymbol = AVGSym) Then
    Begin
      If (fCurrentInputSymbol = MINSym) Then
        Begin
          Get;
          Aggregate.AgFunction := agMin;
        End
      Else If (fCurrentInputSymbol = MAXSym) Then
        Begin
          Get;
          Aggregate.AgFunction := agMax;
        End
      Else If (fCurrentInputSymbol = SUMSym) Then
        Begin
          Get;
          Aggregate.AgFunction := agSum;
        End
      Else
        Begin
          Get;
          Aggregate.AgFunction := agAvg;
        End;
      Expect(_lparenSym);
      If (fCurrentInputSymbol = ALLSym) Or
        (fCurrentInputSymbol = DISTINCTSym) Then
        Begin
          If (fCurrentInputSymbol = ALLSym) Then
            Begin
              Get;
            End
          Else If (fCurrentInputSymbol = DISTINCTSym) Then
            Begin
              Get;
              Aggregate.Distinct := True;
              Aggregate.DistinctCase := True;
              Aggregate.DistinctOnlyList := False;
              If (fCurrentInputSymbol = _lparenSym) Then
                Begin
                  Get;
                  Aggregate.DistinctOnlyList := True;
                  // _SimpleExpression(Aggregate, SimpleExpression);
                  // Aggregate.SimpleExpression := SimpleExpression;
                  Expect(_rparenSym);
                End;
              If (fCurrentInputSymbol = CaseSym) Then
                Begin
                  Get;
                  If (fCurrentInputSymbol = FalseSym) Or
                    (fCurrentInputSymbol = TrueSym) Then
                    Begin
                      If (fCurrentInputSymbol = FalseSym) Then
                        Aggregate.DistinctCase := False;
                      Get;
                    End;
                End;
            End;
        End;
      If (fCurrentInputSymbol = ONLINESym) Then
        Begin
          Get;
        End;
      _SimpleExpression(Aggregate, SimpleExpression);
      Aggregate.SimpleExpression := SimpleExpression;
      If Aggregate.SimpleExpression.IsAggregateExpression Then
        SynError(301);
      Expect(_rparenSym);
    End
  Else
    Begin
      SynError(227);
    End;
End;

Procedure TfsSql._Column(Parent: TfsSqlNode;
  Var Col: TfsSqlColumn);
Var
  ColumnName: String;
Begin
  Col := TfsSqlColumn.Create(Parent);
  _SQLName(ColumnName);
  Col.ColumnName := ColumnName;
End;

Procedure TfsSql._ColumnAlias(Var Selection: TfsSqlSelection);
Var
  Col: TfsSqlColumn;
Begin
  If (fCurrentInputSymbol = ASSym) Then
    Begin
      Get;
    End;
  _Column(Selection, Col);
  Selection.Column := Col;
End;

Procedure TfsSql._Selection(SelectionList: TfsSqlSelectionList);
Var
  Selection: TfsSqlSelection;
Var
  Exp: TfsSqlSimpleExpression;
Var
  Term: TfsSqlTerm;
Var
  Factor: TfsSqlFactor;
Var
  FieldRef: TfsSqlFieldRef;

Begin
  Selection := TfsSqlSelection.Create(SelectionList);
  If (fCurrentInputSymbol = _starSym) Then
    Begin
      Get;

      Exp := TfsSqlSimpleExpression.Create(Selection);
      Term := TfsSqlTerm.Create(Exp);
      Factor := TfsSqlFactor.Create(Term);
      FieldRef := TfsSqlFieldRef.Create(Factor);
      Factor.FieldRef := FieldRef;
      Term.AddFactor(Factor);
      Exp.AddTerm(Term);
      Selection.SimpleExpression := Exp;

    End
  Else If _In(symSet[1], fCurrentInputSymbol) Then
    Begin
      _SimpleExpression(Selection, Exp);
      Selection.SimpleExpression := Exp;
      If (fCurrentInputSymbol = identSym) Or
        (fCurrentInputSymbol = SQLNameStringSym) Or
        (fCurrentInputSymbol = ASSym) Then
        Begin
          _ColumnAlias(Selection);
        End;
    End
  Else
    Begin
      SynError(228);
    End;
  SelectionList.AddSelection(Selection);
End;

Procedure TfsSql._UnionOrderColumn(Parent: TfsSqlNode; Var Col: TfsSqlOrderColumn);
Var
  aSQLName: String;
Begin
  Col := TfsSqlOrderColumn.Create(Parent);
  aSQLName := '';
  _SQLName(aSQLName);
  If (fCurrentInputSymbol = _pointSym) Then
    Begin
      Get;
      Col.TableName := aSQLName;
      aSQLName := '';
      _SQLName(aSQLName);
    End;
  Col.FieldName := aSQLName;
End;

Procedure TfsSql._OrderColumn(Parent: TfsSqlNode; Var Col: TfsSqlOrderColumn);
Var
  aSQLName: String;
Begin
  Col := TfsSqlOrderColumn.Create(Parent);
  aSQLName := '';
  _SQLName(aSQLName);
  If (fCurrentInputSymbol = _pointSym) Then
    Begin
      Get;
      Col.TableName := aSQLName;
      aSQLName := '';
      _SQLName(aSQLName);
    End;
  Col.FieldName := aSQLName;
End;

Procedure TfsSql._OrderItem(Parent: TfsSqlNode;
  Var OrderItem: TfsSqlOrderItem);
Var
  OrderColumn: TfsSqlOrderColumn;
Begin
  OrderItem := TfsSqlOrderItem.Create(Parent);
  OrderItem.Size := 0;
  OrderItem.NoCase := False;
  OrderItem.NullTop := True;
  If (fCurrentInputSymbol = identSym) Or
    (fCurrentInputSymbol = SQLNameStringSym) Then
    Begin
      _OrderColumn(OrderItem, OrderColumn);
      OrderItem.Column := OrderColumn;
    End
  Else If (fCurrentInputSymbol = integer_Sym) Then
    Begin
      Get;
      OrderItem.Index := LexString;
    End
  Else
    Begin
      SynError(229);
    End;

  If (fCurrentInputSymbol = ASCSym) Or
    (fCurrentInputSymbol = DESCSym) Then
    Begin
      If (fCurrentInputSymbol = ASCSym) Then
        Begin
          Get;
        End
      Else
        Begin
          Get;
          OrderItem.Descending := True;
        End;
    End;

  If (fCurrentInputSymbol = CaseSym) Then
    Begin
      Get;
      If (fCurrentInputSymbol = FalseSym) Or
        (fCurrentInputSymbol = TrueSym) Then
        Begin
          If (fCurrentInputSymbol = FalseSym) Then
            OrderItem.NoCase := True;
          Get;
        End;
    End;

  If (fCurrentInputSymbol = NullSym) Then
    Begin
      Get;
      If (fCurrentInputSymbol = TopSym) Then
        Begin
          Get;
          If (fCurrentInputSymbol = FalseSym) Or
            (fCurrentInputSymbol = TrueSym) Then
            Begin
              If (fCurrentInputSymbol = FalseSym) Then
                OrderItem.NullTop := False;
              Get;
            End;
        End;
    End;

  If (fCurrentInputSymbol = CountSym) Then
    Begin
      Get;
      Expect(integer_Sym);
      Try
        OrderItem.Size := StrToInt(LexString);
      Except
        SynError(229);
      End;
    End;
End;

Procedure TfsSql._UnionOrderItem(Parent: TfsSqlNode;
  Var OrderItem: TfsSqlOrderItem);
Var
  OrderColumn: TfsSqlOrderColumn;
Begin
  OrderItem := TfsSqlOrderItem.Create(Parent);
  OrderItem.Size := 0;
  OrderItem.NoCase := False;
  OrderItem.NullTop := True;
  If (fCurrentInputSymbol = identSym) Or
    (fCurrentInputSymbol = SQLNameStringSym) Then
    Begin
      _OrderColumn(OrderItem, OrderColumn);
      OrderItem.Column := OrderColumn;
    End
  Else If (fCurrentInputSymbol = integer_Sym) Then
    Begin
      Get;
      OrderItem.Index := LexString;
    End
  Else
    Begin
      SynError(229);
    End;
  If (fCurrentInputSymbol = ASCSym) Or
    (fCurrentInputSymbol = DESCSym) Then
    Begin
      If (fCurrentInputSymbol = ASCSym) Then
        Begin
          Get;
        End
      Else
        Begin
          Get;
          OrderItem.Descending := True;
        End;
    End;

  If (fCurrentInputSymbol = CaseSym) Then
    Begin
      Get;
      If (fCurrentInputSymbol = FalseSym) Or
        (fCurrentInputSymbol = TrueSym) Then
        Begin
          If (fCurrentInputSymbol = FalseSym) Then
            OrderItem.NoCase := True;
          Get;
        End;
    End;

  If (fCurrentInputSymbol = NullSym) Then
    Begin
      Get;
      If (fCurrentInputSymbol = TopSym) Then
        Begin
          Get;
          If (fCurrentInputSymbol = FalseSym) Or
            (fCurrentInputSymbol = TrueSym) Then
            Begin
              If (fCurrentInputSymbol = FalseSym) Then
                OrderItem.NullTop := False;
              Get;
            End;
        End;
    End;

  If (fCurrentInputSymbol = CountSym) Then
    Begin
      Get;
      Expect(integer_Sym);
      Try
        OrderItem.Size := StrToInt(LexString);
      Except
        SynError(229);
      End;
    End;
End;

Procedure TfsSql._UpdateItem(Parent: TfsSqlNode;
  Var UpdateItem: TfsSqlUpdateItem);
Var
  Simplex: TfsSqlSimpleExpression;
Var
  aSQLName: String;
Begin
  UpdateItem := TfsSqlUpdateItem.Create(Parent);
  _SQLName(aSQLName);
  UpdateItem.ColumnName := aSQLName;
  Expect(_equalSym);
  If (fCurrentInputSymbol = DEFAULTSym) Then
    Begin
      Get;
      UpdateItem.Default := True;
    End
  Else If (fCurrentInputSymbol = NULLSym) Then
    Begin
      Get;
      UpdateItem.IsNull := True;
    End
  Else If _In(symSet[1], fCurrentInputSymbol) Then
    Begin
      _SimpleExpression(UpdateItem, Simplex);
      UpdateItem.Simplex := Simplex;
    End
  Else
    Begin
      SynError(230);
    End;
End;

Procedure TfsSql._UpdateList(Parent: TfsSqlNode;
  Var UpdateList: TfsSqlUpdateList);
Var
  UpdateItem: TfsSqlUpdateItem;
Begin
  UpdateList := TfsSqlUpdateList.Create(Parent);
  _UpdateItem(UpdateList, UpdateItem);
  UpdateList.AddItem(UpdateItem);
  While (fCurrentInputSymbol = _commaSym) Do
    Begin
      Get;
      _UpdateItem(UpdateList, UpdateItem);
      UpdateList.AddItem(UpdateItem);
    End;
End;

Procedure TfsSql._SimpleTableRef(Parent: TfsSqlNode; Var TableRef: TfsSqlTableRef);
Var
  aSQLName, indx: String;
Begin
  TableRef := TfsSqlTableRef.Create(Parent);
  _SQLName(aSQLName, True);
  TableRef.TableName := aSQLName;
  If (fCurrentInputSymbol = _pointSym) Then
    Begin
      Get;
      _SQLName(aSQLName);
      TableRef.DataBaseName := TableRef.TableName;
      TableRef.TableName := aSQLName;
    End;

  If (fCurrentInputSymbol = INDEXNAMESym) Then
    Begin
      Get;
      If (fCurrentInputSymbol = identSym) Or
        (fCurrentInputSymbol = SQLNameStringSym) Then
        Begin
          indx := '';
          _SQLName(indx);
          TableRef.IndexName := Trim(indx);
        End;
    End;

  If (fCurrentInputSymbol = identSym) Or
    (fCurrentInputSymbol = SQLNameStringSym) Or
    (fCurrentInputSymbol = ASSym) Then
    Begin
      _SimpleAlias(TableRef);
    End;
End;

Procedure TfsSql._SimpleExpression(Parent: TfsSqlNode;
  Var SimpleExpression: TfsSqlSimpleExpression);
Var
  Term: TfsSqlTerm;
Var
  AO: TfsSqlAddOp;
Begin
  SimpleExpression := TfsSqlSimpleExpression.Create(Parent);
  _Term(SimpleExpression, Term, aoPlus);
  SimpleExpression.AddTerm(Term);
  While (fCurrentInputSymbol = _plusSym) Or
    (fCurrentInputSymbol = _minusSym) Or
    (fCurrentInputSymbol = _bar_barSym) Do
    Begin
      If (fCurrentInputSymbol = _plusSym) Then
        Begin
          Get;
          AO := aoPlus;
        End
      Else If (fCurrentInputSymbol = _minusSym) Then
        Begin
          Get;
          AO := aoMinus;
        End
      Else
        Begin
          Get;
          AO := aoConcat;
        End;
      _Term(SimpleExpression, Term, AO);
      SimpleExpression.AddTerm(Term);
    End;
End;

Procedure TfsSql._ValueItem(Parent: TfsSqlNode;
  Var ValueItem: TfsSqlValueItem);
Var
  Simplex: TfsSqlSimpleExpression;
Begin
  ValueItem := TfsSqlValueItem.Create(Parent);
  If (fCurrentInputSymbol = DEFAULTSym) Then
    Begin
      Get;
      ValueItem.Default := True;
    End
  Else If (fCurrentInputSymbol = NULLSym) Then
    Begin
      Get;
      ValueItem.IsNull := True;
    End
  Else If _In(symSet[1], fCurrentInputSymbol) Then
    Begin
      _SimpleExpression(ValueItem, Simplex);
      ValueItem.Simplex := Simplex;
    End
  Else
    Begin
      SynError(231);
    End;
End;

Procedure TfsSql._InsertItem(Parent: TfsSqlNode;
  Var InsertItem: TfsSqlInsertItem);
Var
  aSQLName: String;
Begin
  InsertItem := TfsSqlInsertItem.Create(Parent);
  _SQLName(aSQLName);
  InsertItem.ColumnName := aSQLName;
End;

Procedure TfsSql._ValueList(Parent: TfsSqlNode;
  Var ValueList: TfsSqlValueList);
Var
  ValueItem: TfsSqlValueItem;
Begin
  ValueList := TfsSqlValueList.Create(Parent);
  _ValueItem(ValueList, ValueItem);
  ValueList.AddItem(ValueItem);
  While (fCurrentInputSymbol = _commaSym) Do
    Begin
      Get;
      _ValueItem(ValueList, ValueItem);
      ValueList.AddItem(ValueItem);
    End;
End;

Procedure TfsSql._TableConstructor(Parent: TfsSqlNode; Var ValueList: TfsSqlValueList);
Begin
  Expect(VALUESSym);
  Expect(_lparenSym);
  _ValueList(Parent, ValueList);
  Expect(_rparenSym);
End;

Procedure TfsSql._NonJoinTablePrimary(Parent: TfsSqlNode; Var NonJoinTablePrimary: TfsSqlNonJoinTablePrimary);
Var
  ValueList: TfsSqlValueList;
Var
  NonJoinTableExp: TfsSqlNonJoinTableExp;
Var
  TableRef: TfsSqlTableRef;
Var
  SelectSt: TfsSqlSELECT;
Begin
  NonJoinTablePrimary := TfsSqlNonJoinTablePrimary.Create(Parent);
  If IsParenNonJoinTableExp Then
    Begin
      Expect(_lparenSym);
      _NonJoinTableExp(NonJoinTablePrimary, NonJoinTableExp);
      NonJoinTablePrimary.NonJoinTableExp := NonJoinTableExp;
      Expect(_rparenSym);
    End
  Else If (fCurrentInputSymbol = SELECTSym) Then
    Begin
      _SelectStatement(NonJoinTablePrimary, SelectSt);
      NonJoinTablePrimary.SelectSt := SelectSt;
    End
  Else If (fCurrentInputSymbol = TABLESym) Then
    Begin
      Get;
      _TableRef(NonJoinTablePrimary, TableRef);
      NonJoinTablePrimary.TableRef := TableRef;
    End
  Else If (fCurrentInputSymbol = VALUESSym) Then
    Begin
      _TableConstructor(NonJoinTablePrimary, ValueList);
      NonJoinTablePrimary.ValueList := ValueList;
    End
  Else
    Begin
      SynError(232);
    End;
End;

Procedure TfsSql._NonJoinTableTerm(Parent: TfsSqlNode; Var NonJoinTableTerm: TfsSqlNonJoinTableTerm);
Var
  NonJoinTablePrimary: TfsSqlNonJoinTablePrimary;
Begin
  NonJoinTableTerm := TfsSqlNonJoinTableTerm.Create(Parent);
  _NonJoinTablePrimary(NonJoinTableTerm, NonJoinTablePrimary);
  NonJoinTableTerm.NonJoinTablePrimary := NonJoinTablePrimary;
End;

Procedure TfsSql._UsingItem(Parent: TfsSqlNode;
  Var UsingItem: TfsSqlUsingItem);
Var
  aSQLName: String;
Begin
  UsingItem := TfsSqlUsingItem.Create(Parent);
  _SQLName(aSQLName);
  UsingItem.ColumnName := aSQLName;
End;

Procedure TfsSql._UsingList(Parent: TfsSqlNode;
  Var UsingList: TfsSqlUsingList);
Var
  UsingItem: TfsSqlUsingItem;
Begin
  UsingList := TfsSqlUsingList.Create(Parent);
  _UsingItem(UsingList, UsingItem);
  UsingList.AddItem(UsingItem);
  While (fCurrentInputSymbol = _commaSym) Do
    Begin
      Get;
      _UsingItem(UsingList, UsingItem);
      UsingList.AddItem(UsingItem);
    End;
End;

Procedure TfsSql._TableRef(Parent: TfsSqlNode; Var TableRef: TfsSqlTableRef);
Var
  aSQLName: String;
Var
  TableExp: TfsSqlTableExp;
Var
  ColumnList: TfsSqlInsertColumnList;
  indx: String;
Begin
  TableRef := TfsSqlTableRef.Create(Parent);
  TableRef.IndexName := '';
  If IsTableExp Then
    Begin
      _TableExp(TableRef, TableExp);
      TableRef.TableExp := TableExp;
      If (fCurrentInputSymbol = identSym) Or
        (fCurrentInputSymbol = SQLNameStringSym) Or
        (fCurrentInputSymbol = ASSym) Then
        Begin
          _SimpleAlias(TableRef);
        End;
      If (fCurrentInputSymbol = _lparenSym) Then
        Begin
          Get;
          _InsertColumnList(TableRef, ColumnList);
          Expect(_rparenSym);
          TableRef.ColumnList := ColumnList;
        End;
    End
  Else
    Begin
      _SQLName(aSQLName, True);
      TableRef.TableName := aSQLName;
      If (fCurrentInputSymbol = _pointSym) Then
        Begin
          Get;
          _SQLName(aSQLName);
          TableRef.DataBaseName := TableRef.TableName;
          TableRef.TableName := aSQLName;
        End;

      If (fCurrentInputSymbol = INDEXNAMESym) Then
        Begin
          Get;
          If (fCurrentInputSymbol = identSym) Or
            (fCurrentInputSymbol = SQLNameStringSym) Then
            Begin
              indx := '';
              _SQLName(indx);
              TableRef.IndexName := Trim(indx);
            End;
        End;

      If (fCurrentInputSymbol = identSym) Or
        (fCurrentInputSymbol = SQLNameStringSym) Or
        (fCurrentInputSymbol = ASSym) Then
        Begin
          _SimpleAlias(TableRef);
        End;
    End;
End;

Procedure TfsSql._NonJoinTableExp(Parent: TfsSqlNode; Var NonJoinTableExp: TfsSqlNonJoinTableExp);
Var
  NonJoinTableTerm: TfsSqlNonJoinTableTerm;
Begin
  NonJoinTableExp := TfsSqlNonJoinTableExp.Create(Parent);
  _NonJoinTableTerm(NonJoinTableExp, NonJoinTableTerm);
  NonJoinTableExp.NonJoinTableTerm := NonJoinTableTerm;
End;

Procedure TfsSql._JoinTableExp(Parent: TfsSqlNode; Const JoinTableExp: TfsSqlJoinTableExp);
Var
  TableRef: TfsSqlTableRef;
Var
  CondExp: TfsSqlCondExp;
Var
  UsingList: TfsSqlUsingList;

Begin
  If (fCurrentInputSymbol = CROSSSym) Then
    Begin
      Get;
      Expect(JOINSym);
      _TableRef(JoinTableExp, TableRef);
      JoinTableExp.JoinType := jtCross;
      JoinTableExp.TableRef2 := TableRef;
    End
  Else If _In(symSet[6], fCurrentInputSymbol) Then
    Begin
      If (fCurrentInputSymbol = NATURALSym) Then
        Begin
          Get;
          JoinTableExp.Natural := True;
        End;
      JoinTableExp.JoinType := jtInner;
      If (fCurrentInputSymbol = INNERSym) Or
        (fCurrentInputSymbol = LEFTSym) Or
        (fCurrentInputSymbol = RIGHTSym) Or
        (fCurrentInputSymbol = FULLSym) Or
        (fCurrentInputSymbol = UNIONSym) Then
        Begin
          If (fCurrentInputSymbol = INNERSym) Then
            Begin
              Get;
            End
          Else If (fCurrentInputSymbol = LEFTSym) Then
            Begin
              Get;
              If (fCurrentInputSymbol = OUTERSym) Then
                Begin
                  Get;
                End;
              JoinTableExp.JoinType := jtLeftOuter;
            End
          Else If (fCurrentInputSymbol = RIGHTSym) Then
            Begin
              Get;
              If (fCurrentInputSymbol = OUTERSym) Then
                Begin
                  Get;
                End;
              JoinTableExp.JoinType := jtRightOuter;
            End
          Else If (fCurrentInputSymbol = FULLSym) Then
            Begin
              Get;
              If (fCurrentInputSymbol = OUTERSym) Then
                Begin
                  Get;
                End;
              JoinTableExp.JoinType := jtFullOuter;
            End
          Else
            Begin
              Get;
              JoinTableExp.JoinType := jtUnion;
            End;
        End;
      Expect(JOINSym);
      _SimpleTableRefOrParenTableExp(JoinTableExp, TableRef);
      JoinTableExp.TableRef2 := TableRef;
      If (fCurrentInputSymbol = ONSym) Or
        (fCurrentInputSymbol = USINGSym) Then
        Begin
          If (fCurrentInputSymbol = ONSym) Then
            Begin
              Get;
              _CondExp(JoinTableExp, CondExp);
              JoinTableExp.CondExp := CondExp;
            End
          Else
            Begin
              Get;
              Expect(_lparenSym);
              _UsingList(JoinTableExp, UsingList);
              Expect(_rparenSym);
              JoinTableExp.UsingList := UsingList;
            End;
        End;
    End
  Else
    Begin
      SynError(233);
    End;
End;

Procedure TfsSql._SimpleTableRefOrParenTableExp(Parent: TfsSqlNode; Var TableRef: TfsSqlTableRef);
Var
  TableExp: TfsSqlTableExp;
Var
  aSQLName: String;
Begin
  TableRef := TfsSqlTableRef.Create(Parent);
  If (fCurrentInputSymbol = identSym) Or
    (fCurrentInputSymbol = SQLNameStringSym) Then
    Begin
      _SQLName(aSQLName, True);
      TableRef.TableName := aSQLName;
      If (fCurrentInputSymbol = _pointSym) Then
        Begin
          Get;
          _SQLName(aSQLName);
          TableRef.DataBaseName := TableRef.TableName;
          TableRef.TableName := aSQLName;
        End;
      If (fCurrentInputSymbol = identSym) Or
        (fCurrentInputSymbol = SQLNameStringSym) Or
        (fCurrentInputSymbol = ASSym) Then
        Begin
          _SimpleAlias(TableRef);
        End;
    End
  Else If (fCurrentInputSymbol = _lparenSym) Then
    Begin
      Get;
      _TableExp(TableRef, TableExp);
      TableRef.TableExp := TableExp;
      Expect(_rparenSym);
      If (fCurrentInputSymbol = identSym) Or
        (fCurrentInputSymbol = SQLNameStringSym) Or
        (fCurrentInputSymbol = ASSym) Then
        Begin
          _SimpleAlias(TableRef);
        End;
    End
  Else
    Begin
      SynError(234);
    End;
End;

Procedure TfsSql._InsertColumnList(Parent: TfsSqlNode;
  Var InsertColumnList: TfsSqlInsertColumnList);
Var
  InsertItem: TfsSqlInsertItem;
Begin
  InsertColumnList := TfsSqlInsertColumnList.Create(Parent);
  _InsertItem(InsertColumnList, InsertItem);
  InsertColumnList.AddItem(InsertItem);
  While (fCurrentInputSymbol = _commaSym) Do
    Begin
      Get;
      _InsertItem(InsertColumnList, InsertItem);
      InsertColumnList.AddItem(InsertItem);
    End;
End;

Procedure TfsSql._SQLName(Var aName: String; TableN: boolean = False);
Begin
  If (fCurrentInputSymbol = identSym) Then
    Begin
      Get(TableN);
      aName := LexString;
    End
  Else If (fCurrentInputSymbol = SQLNameStringSym) Then
    Begin
      Get;
      aName := CheckSQLName(LexString);
    End
  Else
    Begin
      SynError(235);
    End;
End;

Procedure TfsSql._OrderList(Parent: TfsSqlNode;
  Var OrderList: TfsSqlOrderList);
Var
  OrderItem: TfsSqlOrderItem;
Begin
  OrderList := TfsSqlOrderList.Create(Parent);
  _OrderItem(OrderList, OrderItem);
  OrderList.AddOrderItem(OrderItem);
  While (fCurrentInputSymbol = _commaSym) Do
    Begin
      Get;
      _OrderItem(OrderList, OrderItem);
      OrderList.AddOrderItem(OrderItem);
    End;
End;

Procedure TfsSql._UnionOrderList(UnionParent: TfsSqlNode;
  Var UnionOrderList: TfsSqlOrderList);
Var
  UnionOrderItem: TfsSqlOrderItem;
Begin
  UnionOrderList := TfsSqlOrderList.Create(UnionParent);
  _UnionOrderItem(UnionOrderList, UnionOrderItem);
  UnionOrderList.AddOrderItem(UnionOrderItem);
  While (fCurrentInputSymbol = _commaSym) Do
    Begin
      Get;
      _UnionOrderItem(UnionOrderList, UnionOrderItem);
      UnionOrderList.AddOrderItem(UnionOrderItem);
    End;
End;

Procedure TfsSql._GroupColumnList(Parent: TfsSqlNode;
  Var ColumnList: TfsSqlGroupColumnList);
Var
  Col: TfsSqlGroupColumn;
Begin
  ColumnList := TfsSqlGroupColumnList.Create(Parent);
  _GroupColumn(Parent, Col);
  ColumnList.AddColumn(Col);
  While (fCurrentInputSymbol = _commaSym) Do
    Begin
      Get;
      _GroupColumn(Parent, Col);
      ColumnList.AddColumn(Col);
    End;
End;

Procedure TfsSql._UnionGroupColumnList(UnionParent: TfsSqlNode;
  Var ColumnList: TfsSqlGroupColumnList);
Var
  Col: TfsSqlGroupColumn;
Begin
  ColumnList := TfsSqlGroupColumnList.Create(UnionParent);
  _GroupColumn(UnionParent, Col);
  ColumnList.AddColumn(Col);
  While (fCurrentInputSymbol = _commaSym) Do
    Begin
      Get;
      _GroupColumn(UnionParent, Col);
      ColumnList.AddColumn(Col);
    End;
End;

Procedure TfsSql._CondExp(Parent: TfsSqlNode;
  Var CondExp: TfsSqlCondExp);
Var
  CondTerm: TfsSqlCondTerm;
Begin
  CondExp := TfsSqlCondExp.Create(Parent);
  _CondTerm(CondExp, CondTerm);
  CondExp.AddCondTerm(CondTerm);
  While (fCurrentInputSymbol = ORSym) Do
    Begin
      Get;
      _CondTerm(CondExp, CondTerm);
      CondExp.AddCondTerm(CondTerm);
    End;
End;

Procedure TfsSql._TableRefList(Parent: TfsSqlNode;
  Var TableRefList: TfsSqlTableRefList);
Var
  TableRef: TfsSqlTableRef;
Begin
  TableRefList := TfsSqlTableRefList.Create(Parent);
  _TableRef(TableRefList, TableRef);
  TableRefList.AddTableRef(TableRef);
  While (fCurrentInputSymbol = _commaSym) Do
    Begin
      Get(True);
      _TableRef(TableRefList, TableRef);
      TableRefList.AddTableRef(TableRef);
    End;
End;

Procedure TfsSql._SelectionList(Parent: TfsSqlSELECT; Var SelectionList: TfsSqlSelectionList);
Begin
  SelectionList := TfsSqlSelectionList.Create(Parent);
  _Selection(SelectionList);
  While (fCurrentInputSymbol = _commaSym) Do
    Begin
      Get;
      _Selection(SelectionList);
    End;
End;

Procedure TfsSql._SelectStatement(Parent: TfsSqlNode;
  Var Select: TfsSqlSELECT);
Var
  SelectionList: TfsSqlSelectionList;
  DistinctList: TfsSqlSelectionList;
Var
  CondExp: TfsSqlCondExp;
Var
  GroupColumnList: TfsSqlGroupColumnList;
  UnionGroupColumnList: TfsSqlGroupColumnList;
Var
  TableRefList: TfsSqlTableRefList;
Var
  OrderList: TfsSqlOrderList;
  UnionOrderList: TfsSqlOrderList;
  _min: Boolean;

  Procedure s_OrderColumn;
  Var
    aSQLName: String;
  Begin
    aSQLName := '';
    _SQLName(aSQLName);
    If (fCurrentInputSymbol = _pointSym) Then
      Begin
        Get;
        aSQLName := '';
        _SQLName(aSQLName);
      End;
  End;

  Procedure s_OrderItem;
  Begin
    If (fCurrentInputSymbol = identSym) Or
      (fCurrentInputSymbol = SQLNameStringSym) Then
      Begin
        s_OrderColumn;
      End
    Else If (fCurrentInputSymbol = integer_Sym) Then
      Begin
        Get;
      End
    Else
      Begin
        //SynError( 229 );
      End;
    If (fCurrentInputSymbol = ASCSym) Or
      (fCurrentInputSymbol = DESCSym) Then
      Begin
        If (fCurrentInputSymbol = ASCSym) Then
          Begin
            Get;
          End
        Else
          Begin
            Get;
          End;
      End;
  End;

  Procedure s_OrderList;
  Begin
    s_OrderItem;
    While (fCurrentInputSymbol = _commaSym) Do
      Begin
        Get;
        s_OrderItem;
      End;
  End;

Begin
  Expect(SELECTSym);
  Select := TfsSqlSELECT.Create(Parent);
  Select.DistinctOnlyList := False;

  If (fCurrentInputSymbol = ONLINESym) Then
    Begin
      Get;
      Select.IsOnline := True;
    End;

  If (fCurrentInputSymbol In [DOWNSym, TOPSym, TOPDOWNSym,
    CENTERSym, TOPCENTERDOWNSym, TOPCENTERSym, CENTERDOWNSym]) Then
    Begin
      Case fCurrentInputSymbol Of
        DOWNSym: Select.TopDirection := tdDOWN;
        TOPSym: Select.TopDirection := tdTOP;
        TOPDOWNSym: Select.TopDirection := tdTOPDOWN;
        CENTERSym: Select.TopDirection := tdCENTER;
        TOPCENTERDOWNSym: Select.TopDirection := tdTOPCENTERDOWN;
        TOPCENTERSym: Select.TopDirection := tdTOPCENTER;
        CENTERDOWNSym: Select.TopDirection := tdCENTERDOWN;
      End;
      Get;
      _min := False;
      If (fCurrentInputSymbol = FIRSTSym) Then
        Begin
          Select.LimitFirst := True;
          Get;
        End;
      If (fCurrentInputSymbol = _minussym) Then
        Begin
          _min := True;
          Get;
        End;
      Expect(integer_Sym);
      Try
        Select.LimitCount := StrToInt(LexString);
        If _min Then Select.LimitCount := -Select.LimitCount;
        If Select.LimitCount >= -1 Then Select.Islimit := True;
      Except
        SynError(91);
      End;
      If (fCurrentInputSymbol = PERCENTSym) Then
        Begin
          Get;
          Select.LimitPrct := True;
        End;
      If (fCurrentInputSymbol = STARTFROMSym) Then
        Begin
          Get;
          Expect(integer_Sym);
          Try
            Select.LimitStart := StrToInt(LexString);
          Except
            SynError(237);
          End;
          If (fCurrentInputSymbol = PERCENTSym) Then
            Begin
              Get;
              Select.LimitPrctStart := True;
            End;
        End;
      If (fCurrentInputSymbol = DIVBYSym) Then
        Begin
          Get;
          Expect(integer_Sym);
          Try
            Select.LimitDivBy := StrToInt(LexString);
          Except
            SynError(164);
          End;
          If (fCurrentInputSymbol = PERCENTSym) Then
            Begin
              Get;
              Select.LimitPrctDiv := True;
            End;
          If (fCurrentInputSymbol = ATFIRSTSym) Then
            Begin
              Get;
              Select.LimitDivAtOne := True;
            End;
        End;
      If (fCurrentInputSymbol = DISTINCTSym) Then
        Begin
          Get;
          Select.LimitDistinct := True;
          Select.DistinctCase := True;
          Select.DistinctOnlyList := False;
          If (fCurrentInputSymbol = _lparenSym) Then
            Begin
              Get;
              Select.DistinctOnlyList := True;
              Expect(_rparenSym);
            End;
          If (fCurrentInputSymbol = CaseSym) Then
            Begin
              Get;
              If (fCurrentInputSymbol = FalseSym) Or
                (fCurrentInputSymbol = TrueSym) Then
                Begin
                  If (fCurrentInputSymbol = FalseSym) Then
                    Select.DistinctCase := False;
                  Get;
                End;
            End;
        End;
    End;

  If (fCurrentInputSymbol = ALLSym) Or
    (fCurrentInputSymbol = DISTINCTSym) Then
    Begin
      If (fCurrentInputSymbol = ALLSym) Then
        Begin
          Get;
        End
      Else If (fCurrentInputSymbol = DISTINCTSym) Then
        Begin
          Get;
          Select.Distinct := True;
          Select.DistinctCase := True;
          Select.DistinctOnlyList := False;
          If (fCurrentInputSymbol = _lparenSym) Then
            Begin
              Get;
              Select.DistinctOnlyList := True;
              _SelectionList(Select, DistinctList);
              Select.DistinctList := DistinctList;
              Expect(_rparenSym);
            End;
          If (fCurrentInputSymbol = CaseSym) Then
            Begin
              Get;
              If (fCurrentInputSymbol = FalseSym) Or
                (fCurrentInputSymbol = TrueSym) Then
                Begin
                  If (fCurrentInputSymbol = FalseSym) Then
                    Select.DistinctCase := False;
                  Get;
                End;
            End;
        End;
    End;

  If (fCurrentInputSymbol = ONLINESym) Then
    Begin
      Get;
      Select.IsOnline := True;
    End;

  If (fCurrentInputSymbol In [DOWNSym, TOPSym, TOPDOWNSym,
    CENTERSym, TOPCENTERDOWNSym, TOPCENTERSym, CENTERDOWNSym]) Then
    Begin
      Case fCurrentInputSymbol Of
        DOWNSym: Select.TopDirection := tdDOWN;
        TOPSym: Select.TopDirection := tdTOP;
        TOPDOWNSym: Select.TopDirection := tdTOPDOWN;
        CENTERSym: Select.TopDirection := tdCENTER;
        TOPCENTERDOWNSym: Select.TopDirection := tdTOPCENTERDOWN;
        TOPCENTERSym: Select.TopDirection := tdTOPCENTER;
        CENTERDOWNSym: Select.TopDirection := tdCENTERDOWN;
      End;
      Get;
      _min := False;
      If (fCurrentInputSymbol = FIRSTSym) Then
        Begin
          Select.LimitFirst := True;
          Get;
        End;
      If (fCurrentInputSymbol = _minussym) Then
        Begin
          _min := True;
          Get;
        End;
      Expect(integer_Sym);
      Try
        Select.LimitCount := StrToInt(LexString);
        If _min Then Select.LimitCount := -Select.LimitCount;
        If Select.LimitCount >= -1 Then Select.Islimit := True;
      Except
        SynError(91);
      End;
      If (fCurrentInputSymbol = PERCENTSym) Then
        Begin
          Get;
          Select.LimitPrct := True;
        End;
      If (fCurrentInputSymbol = STARTFROMSym) Then
        Begin
          Get;
          Expect(integer_Sym);
          Try
            Select.LimitStart := StrToInt(LexString);
          Except
            SynError(237);
          End;
          If (fCurrentInputSymbol = PERCENTSym) Then
            Begin
              Get;
              Select.LimitPrctStart := True;
            End;
        End;
      If (fCurrentInputSymbol = DIVBYSym) Then
        Begin
          Get;
          Expect(integer_Sym);
          Try
            Select.LimitDivBy := StrToInt(LexString);
          Except
            SynError(164);
          End;
          If (fCurrentInputSymbol = PERCENTSym) Then
            Begin
              Get;
              Select.LimitPrctDiv := True;
            End;
          If (fCurrentInputSymbol = ATFIRSTSym) Then
            Begin
              Get;
              Select.LimitDivAtOne := True;
            End;
        End;
      If (fCurrentInputSymbol = DISTINCTSym) Then
        Begin
          Get;
          Select.LimitDistinct := True;
          Select.DistinctCase := True;
          Select.DistinctOnlyList := False;
          If (fCurrentInputSymbol = _lparenSym) Then
            Begin
              Get;
              Select.DistinctOnlyList := True;
              Expect(_rparenSym);
            End;
          If (fCurrentInputSymbol = CaseSym) Then
            Begin
              Get;
              If (fCurrentInputSymbol = FalseSym) Or
                (fCurrentInputSymbol = TrueSym) Then
                Begin
                  If (fCurrentInputSymbol = FalseSym) Then
                    Select.DistinctCase := False;
                  Get;
                End;
            End;
        End;
    End;

  _SelectionList(Select, SelectionList);
  Select.SelectionList := SelectionList;
  Expect(FROMSym);
  _TableRefList(Select, TableRefList);
  Select.TableRefList := TableRefList;
  If (fCurrentInputSymbol = WHERESym) Then
    Begin
      Get;
      Select.InWhere := True;
      _CondExp(Select, CondExp);
      Select.CondExpWhere := CondExp;
      Select.InWhere := False;
    End;
  If (fCurrentInputSymbol = GROUPSym) Then
    Begin
      Get;
      Expect(BYSym);
      Select.GroupCase := True;
      _GroupColumnList(Select, GroupColumnList);
      Select.GroupColumnList := GroupColumnList;
      If (fCurrentInputSymbol = CaseSym) Then
        Begin
          Get;
          If (fCurrentInputSymbol = FalseSym) Or
            (fCurrentInputSymbol = TrueSym) Then
            Begin
              If (fCurrentInputSymbol = FalseSym) Then
                Select.GroupCase := False;
              Get;
            End;
        End;

    End;
  If (fCurrentInputSymbol = HAVINGSym) Then
    Begin
      Get;
      _CondExp(Select, CondExp);
      Select.CondExpHaving := CondExp;
    End;
  If (fCurrentInputSymbol = ORDERSym) Then
    Begin
      Get;
      Expect(BYSym);
      _OrderList(Select, OrderList);
      Select.OrderList := OrderList;
    End;

  If (fCurrentInputSymbol In [GROUPSym, GROUPUNIONSym]) Then
    Begin
      Get;
      Expect(BYSym);
      Select.GroupUnionCase := True;
      _UnionGroupColumnList(Select, UnionGroupColumnList);
      Select.UnionGroupColumnList := UnionGroupColumnList;
      If (fCurrentInputSymbol = CaseSym) Then
        Begin
          Get;
          If (fCurrentInputSymbol = FalseSym) Or
            (fCurrentInputSymbol = TrueSym) Then
            Begin
              If (fCurrentInputSymbol = FalseSym) Then
                Select.GroupUnionCase := False;
              Get;
            End;
        End;
    End;
  // for union order by
  If (fCurrentInputSymbol In [ORDERSym, ORDERUNIONSym]) Then
    Begin
      Get;
      Expect(BYSym);
      _OrderList(Select, UnionOrderList);
      Select.UnionOrderList := UnionOrderList;
      Select.UnionOrderList.UOrder := True;
    End;
End;

Procedure TfsSql._DeleteStatement(Parent: TfsSqlNode;
  Var DeleteSt: TfsSqlDELETE);
Var
  TableRef: TfsSqlTableRef;
Var
  CondExp: TfsSqlCondExp;
  _min: Boolean;
  IC: Longword;
  fIslimit, fLimitFirst: Boolean;
  fTopDirection: TTopDirection;
  fLimitCount, fLimitDivBy: Longint;
  fLimitPrct, fLimitDivAtOne, fLimitPrctDiv: Boolean;
  fLimitStart: Longint;
  fLimitPrctStart: Boolean;
  fLimitDistinct: Boolean;
Begin
  Expect(DELETESym);
  Ic := 0;
  _min := False;
  If (fCurrentInputSymbol = COMMITBYSym) Then
    Begin
      Get;
      If (fCurrentInputSymbol = _minussym) Then
        Begin
          _min := True;
          Get;
        End;
      Expect(integer_Sym);
      Try
        Ic := StrToInt(LexString);
        If _min Then Ic := 0;
        If Ic < 1 Then Ic := 0;
      Except
        SynError(91);
      End;
    End;
  If (fCurrentInputSymbol In [DOWNSym, TOPSym, TOPDOWNSym,
    CENTERSym, TOPCENTERDOWNSym, TOPCENTERSym, CENTERDOWNSym]) Then
    Begin
      Case fCurrentInputSymbol Of
        DOWNSym: fTopDirection := tdDOWN;
        TOPSym: fTopDirection := tdTOP;
        TOPDOWNSym: fTopDirection := tdTOPDOWN;
        CENTERSym: fTopDirection := tdCENTER;
        TOPCENTERDOWNSym: fTopDirection := tdTOPCENTERDOWN;
        TOPCENTERSym: fTopDirection := tdTOPCENTER;
        CENTERDOWNSym: fTopDirection := tdCENTERDOWN;
      End;
      Get;
      _min := False;
      If (fCurrentInputSymbol = FIRSTSym) Then
        Begin
          fLimitFirst := True;
          Get;
        End;
      If (fCurrentInputSymbol = _minussym) Then
        Begin
          _min := True;
          Get;
        End;
      Expect(integer_Sym);
      Try
        fLimitCount := StrToInt(LexString);
        If _min Then fLimitCount := -fLimitCount;
        If fLimitCount >= -1 Then fIslimit := True;
      Except
        SynError(91);
      End;
      If (fCurrentInputSymbol = PERCENTSym) Then
        Begin
          Get;
          fLimitPrct := True;
        End;
      If (fCurrentInputSymbol = STARTFROMSym) Then
        Begin
          Get;
          Expect(integer_Sym);
          Try
            fLimitStart := StrToInt(LexString);
          Except
            SynError(237);
          End;
          If (fCurrentInputSymbol = PERCENTSym) Then
            Begin
              Get;
              fLimitPrctStart := True;
            End;
        End;
      If (fCurrentInputSymbol = DIVBYSym) Then
        Begin
          Get;
          Expect(integer_Sym);
          Try
            fLimitDivBy := StrToInt(LexString);
          Except
            SynError(164);
          End;
          If (fCurrentInputSymbol = PERCENTSym) Then
            Begin
              Get;
              fLimitPrctDiv := True;
            End;
          If (fCurrentInputSymbol = ATFIRSTSym) Then
            Begin
              Get;
              fLimitDivAtOne := True;
            End;
        End;
      If (fCurrentInputSymbol = DISTINCTSym) Then
        Begin
          Get;
          fLimitDistinct := True;
        End;
    End;
  Expect(FROMSym);
  DeleteSt := TfsSqlDELETE.Create(Parent);
  DeleteSt.CommitBy := IC;
  DeleteSt.LimitCount := fLimitCount;
  DeleteSt.LimitPrct := fLimitPrct;
  DeleteSt.LimitPrctStart := fLimitPrctStart;
  DeleteSt.LimitStart := fLimitStart;
  DeleteSt.TopDirection := fTopDirection;
  DeleteSt.LimitDivBy := fLimitDivBy;
  DeleteSt.LimitDivAtOne := fLimitDivAtOne;
  DeleteSt.LimitPrctDiv := fLimitPrctDiv;
  DeleteSt.LimitDistinct := fLimitDistinct;
  DeleteSt.Islimit := fIslimit;
  DeleteSt.LimitFirst := fLimitFirst;

  _SimpleTableRef(DeleteSt, TableRef);
  DeleteSt.TableRef := TableRef;
  If (fCurrentInputSymbol = WHERESym) Then
    Begin
      Get;
      _CondExp(DeleteSt, CondExp);
      DeleteSt.CondExpWhere := CondExp;
    End;
End;

Procedure TfsSql._UpdateStatement(Parent: TfsSqlNode;
  Var UpdateSt: TfsSqlUPDATE);
Var
  TableRef: TfsSqlTableRef;
Var
  CondExp: TfsSqlCondExp;
Var
  UpdateList: TfsSqlUpdateList;
  _min: Boolean;
  fIslimit, fLimitFirst: Boolean;
  fTopDirection: TTopDirection;
  fLimitCount, fLimitDivBy: Longint;
  fLimitPrct, fLimitDivAtOne, fLimitPrctDiv: Boolean;
  fLimitStart: Longint;
  fLimitPrctStart: Boolean;
  fLimitDistinct: Boolean;

Begin
  Expect(UPDATESym);
  UpdateSt := TfsSqlUPDATE.Create(Parent);
  UpdateSt.CommitBy := 0;
  _min := False;
  If (fCurrentInputSymbol = COMMITBYSym) Then
    Begin
      Get;
      If (fCurrentInputSymbol = _minussym) Then
        Begin
          _min := True;
          Get;
        End;
      Expect(integer_Sym);
      Try
        UpdateSt.CommitBy := StrToInt(LexString);
        If _min Then UpdateSt.CommitBy := 0;
        If UpdateSt.CommitBy < 1 Then UpdateSt.CommitBy := 0;
      Except
        SynError(91);
      End;
    End;

  If (fCurrentInputSymbol In [DOWNSym, TOPSym, TOPDOWNSym,
    CENTERSym, TOPCENTERDOWNSym, TOPCENTERSym, CENTERDOWNSym]) Then
    Begin
      Case fCurrentInputSymbol Of
        DOWNSym: fTopDirection := tdDOWN;
        TOPSym: fTopDirection := tdTOP;
        TOPDOWNSym: fTopDirection := tdTOPDOWN;
        CENTERSym: fTopDirection := tdCENTER;
        TOPCENTERDOWNSym: fTopDirection := tdTOPCENTERDOWN;
        TOPCENTERSym: fTopDirection := tdTOPCENTER;
        CENTERDOWNSym: fTopDirection := tdCENTERDOWN;
      End;
      Get;
      _min := False;
      If (fCurrentInputSymbol = FIRSTSym) Then
        Begin
          fLimitFirst := True;
          Get;
        End;
      If (fCurrentInputSymbol = _minussym) Then
        Begin
          _min := True;
          Get;
        End;
      Expect(integer_Sym);
      Try
        fLimitCount := StrToInt(LexString);
        If _min Then fLimitCount := -fLimitCount;
        If fLimitCount >= -1 Then fIslimit := True;
      Except
        SynError(91);
      End;
      If (fCurrentInputSymbol = PERCENTSym) Then
        Begin
          Get;
          fLimitPrct := True;
        End;
      If (fCurrentInputSymbol = STARTFROMSym) Then
        Begin
          Get;
          Expect(integer_Sym);
          Try
            fLimitStart := StrToInt(LexString);
          Except
            SynError(237);
          End;
          If (fCurrentInputSymbol = PERCENTSym) Then
            Begin
              Get;
              fLimitPrctStart := True;
            End;
        End;
      If (fCurrentInputSymbol = DIVBYSym) Then
        Begin
          Get;
          Expect(integer_Sym);
          Try
            fLimitDivBy := StrToInt(LexString);
          Except
            SynError(164);
          End;
          If (fCurrentInputSymbol = PERCENTSym) Then
            Begin
              Get;
              fLimitPrctDiv := True;
            End;
          If (fCurrentInputSymbol = ATFIRSTSym) Then
            Begin
              Get;
              fLimitDivAtOne := True;
            End;
        End;
      If (fCurrentInputSymbol = DISTINCTSym) Then
        Begin
          Get;
          fLimitDistinct := True;
        End;
    End;

  UpdateSt.LimitCount := fLimitCount;
  UpdateSt.LimitPrct := fLimitPrct;
  UpdateSt.LimitPrctStart := fLimitPrctStart;
  UpdateSt.LimitStart := fLimitStart;
  UpdateSt.TopDirection := fTopDirection;
  UpdateSt.LimitDivBy := fLimitDivBy;
  UpdateSt.LimitDivAtOne := fLimitDivAtOne;
  UpdateSt.LimitPrctDiv := fLimitPrctDiv;
  UpdateSt.LimitDistinct := fLimitDistinct;
  UpdateSt.Islimit := fIslimit;
  UpdateSt.LimitFirst := fLimitFirst;

  _SimpleTableRef(UpdateSt, TableRef);
  UpdateSt.TableRef := TableRef;
  Expect(SETSym);
  _UpdateList(UpdateSt, UpdateList);
  UpdateSt.UpdateList := UpdateList;
  If (fCurrentInputSymbol = WHERESym) Then
    Begin
      Get;
      _CondExp(UpdateSt, CondExp);
      UpdateSt.CondExpWhere := CondExp;
    End;
End;

Procedure TfsSql._InsertStatement(Parent: TfsSqlNode;
  Var InsertSt: TfsSqlINSERT);
Var
  aSQLName: String;
Var
  InsertColumnList: TfsSqlInsertColumnList;
Var
  TableExp: TfsSqlTableExp;
  _min: Boolean;
  IC: Longword;
Begin
  Expect(INSERTSym);
  Ic := 0;
  _min := False;
  If (fCurrentInputSymbol = COMMITBYSym) Then
    Begin
      Get;
      If (fCurrentInputSymbol = _minussym) Then
        Begin
          _min := True;
          Get;
        End;
      Expect(integer_Sym);
      Try
        Ic := StrToInt(LexString);
        If _min Then Ic := 0;
        If Ic < 1 Then Ic := 0;
      Except
        SynError(91);
      End;
    End;

  Expect(INTOSym);
  InsertSt := TfsSqlINSERT.Create(Parent);
  InsertSt.CommitBy := Ic;

  _SQLName(aSQLName);
  InsertSt.TableName := aSQLName;
  If (fCurrentInputSymbol = DEFAULTSym) Then
    Begin
      Get;
      Expect(VALUESSym);
      InsertSt.DefaultValues := True;
    End
  Else If IsColumnList Then
    Begin
      Expect(_lparenSym);
      _InsertColumnList(InsertSt, InsertColumnList);
      InsertSt.InsertColumnList := InsertColumnList;
      Expect(_rparenSym);
      _TableExp(InsertSt, TableExp);
      InsertSt.TableExp := TableExp;
    End
  Else If (fCurrentInputSymbol = SELECTSym) Or
    (fCurrentInputSymbol = VALUESSym) Or
    (fCurrentInputSymbol = _lparenSym) Or
    (fCurrentInputSymbol = TABLESym) Then
    Begin
      _TableExp(InsertSt, TableExp);
      InsertSt.TableExp := TableExp;
    End
  Else
    Begin
      SynError(236);
    End;
End;

Procedure TfsSql._TableExp(Parent: TfsSqlNode; Var TableExp: TfsSqlTableExp;
  CreateUnion: boolean = True);
Var
  NestedTableExp: TfsSqlTableExp;
Var
  JoinTableExp: TfsSqlJoinTableExp;
Var
  TmpJoinTableExp: TfsSqlJoinTableExp;
Var
  TmpTableExp: TfsSqlTableExp;
Var
  TableRef, TmpTableRef: TfsSqlTableRef;
Var
  NonJoinTableExp: TfsSqlNonJoinTableExp;
  atUnion: TfsUnionType;
  aUnionCase: boolean;
Var
  NonJoinTableTerm: TfsSqlNonJoinTableTerm;
Begin
  TableExp := TfsSqlTableExp.Create(Parent);
  If IsJoinTableExp Then
    Begin
      JoinTableExp := TfsSqlJoinTableExp.Create(TableExp);
      TableExp.JoinTableExp := JoinTableExp;
      _SimpleTableRefOrParenTableExp(JoinTableExp, TableRef);
      JoinTableExp.TableRef1 := TableRef;
      _JoinTableExp(TableExp, JoinTableExp);
      While _In(symSet[7], fCurrentInputSymbol) Do
        Begin
          TmpJoinTableExp := JoinTableExp;
          JoinTableExp := TfsSqlJoinTableExp.Create(TableExp);
          TableExp.JoinTableExp := JoinTableExp;
          TmpTableRef := TfsSqlTableRef.Create(JoinTableExp);
          TmpTableExp := TfsSqlTableExp.Create(TmpTableRef);
          TmpJoinTableExp.Parent := TmpTableExp;
          TmpTableExp.JoinTableExp := TmpJoinTableExp;
          TmpTableRef.TableExp := TmpTableExp;
          JoinTableExp.TableRef1 := TmpTableRef;
          _JoinTableExp(TableExp, JoinTableExp);
        End;
    End
  Else If (fCurrentInputSymbol = SELECTSym) Or
    (fCurrentInputSymbol = VALUESSym) Or
    (fCurrentInputSymbol = TABLESym) Then
    Begin
      _NonJoinTableExp(TableExp, NonJoinTableExp);
      TableExp.NonJoinTableExp := NonJoinTableExp;
    End
  Else If (fCurrentInputSymbol = _lparenSym) Then
    Begin
      Get;
      _TableExp(TableExp, NestedTableExp);
      TableExp.NestedTableExp := NestedTableExp;
      Expect(_rparenSym);
    End
  Else
    Begin
      SynError(237);
    End;

  If CreateUnion Then
    If (fCurrentInputSymbol = UNIONSym) Then
      Begin
        Get;
        atUnion := utNormal;
        If (fCurrentInputSymbol = ALLSym) Then
          Begin
            Get;
            atUnion := utAll;
          End;
        aUnionCase := True;
        If (fCurrentInputSymbol = CaseSym) Then
          Begin
            Get;
            If (fCurrentInputSymbol = FalseSym) Or
              (fCurrentInputSymbol = TrueSym) Then
              Begin
                If (fCurrentInputSymbol = FalseSym) Then
                  aUnionCase := False;
                Get;
              End;
          End;
        _NonJoinTableTerm(TableExp, NonJoinTableTerm);
        NonJoinTableTerm.Union := atUnion;
        NonJoinTableTerm.UnionCase := aUnionCase;
        TableExp.UnionTerm := NonJoinTableTerm;
        TableExp.UnionCase := aUnionCase;
      End;
End;

Procedure TfsSql._FSSQL;
Var
  TableExp: TfsSqlTableExp;
Var
  InsertSt: TfsSqlINSERT;
Var
  UpdateSt: TfsSqlUPDATE;
Var
  DeleteSt: TfsSqlDELETE;
Var
  NonJoinTableExp: TfsSqlNonJoinTableExp;
  aUnion: TfsUnionType;
Var
  NonJoinTableTerm: TfsSqlNonJoinTableTerm;
Begin
  Init;
  If (fCurrentInputSymbol = NOINDEXSym) Then
    Begin
      Get;
      fRootNode.UseIndex := False
    End;
  If (fCurrentInputSymbol = NOREDUCESym) Then
    Begin
      Get;
      fRootNode.Reduce := False
    End;
  If IsTableExp Then
    Begin
      // NOT YET - MULTI UNION
      _TableExp(fRootNode, TableExp);
      TableExp.Union := utNone;
      TableExp.UnionCase := True;
      fRootNode.AddTableExp(TableExp);
      While (fCurrentInputSymbol = UNIONSym) Do
        Begin
          get;
          aUnion := utNormal;
          If (fCurrentInputSymbol = ALLSym) Then
            Begin
              Get;
              aUnion := utAll;
            End;

          TableExp.UnionCase := True;
          If (fCurrentInputSymbol = CaseSym) Then
            Begin
              Get;
              If (fCurrentInputSymbol = FalseSym) Or
                (fCurrentInputSymbol = TrueSym) Then
                Begin
                  If (fCurrentInputSymbol = FalseSym) Then
                    TableExp.UnionCase := False;
                  Get;
                End;
            End;

          TableExp.Union := aUnion;
          _TableExp(fRootNode, TableExp, False);
          TableExp.Union := aUnion;
          fRootNode.AddTableExp(TableExp);
        End;
    End
  Else If (fCurrentInputSymbol = SELECTSym) Then
    Begin
      Get;
    End
  Else If (fCurrentInputSymbol = INSERTSym) Then
    Begin
      _InsertStatement(fRootNode, InsertSt);
      fRootNode.Insert := InsertSt;
    End
  Else If (fCurrentInputSymbol = UPDATESym) Then
    Begin
      _UpdateStatement(fRootNode, UpdateSt);
      fRootNode.Update := UpdateSt;
    End
  Else If (fCurrentInputSymbol = DELETESym) Then
    Begin
      _DeleteStatement(fRootNode, DeleteSt);
      fRootNode.Delete := DeleteSt;
    End
      // Start DDL
  Else If (fCurrentInputSymbol = CREATESym) Then
    Begin

    End
  Else If (fCurrentInputSymbol = DROPSym) Then
    Begin

    End
  Else If (fCurrentInputSymbol = ALTERSym) Then
    Begin

    End
  Else If (fCurrentInputSymbol = ASSERTSym) Then
    Begin

    End
  Else If (fCurrentInputSymbol = TRIGGERSym) Then
    Begin

    End
  Else If (fCurrentInputSymbol = FOREGEINSym) Then
    Begin

    End
      // End DDL
  Else
    Begin
      SynError(238);
    End;
  If (fCurrentInputSymbol = _semicolonSym) Then
    Begin
      Get;
    End;
  If fCurrentInputSymbol <> EOFSYMB Then
    SynError(300);
  Final;
End;

Function TfsSql.GetBuildDate: TDateTime;
Const
  BDate = 37579;
  Hour = 14;
  Min = 45;
Begin
  Result := BDate + EncodeTime(Hour, Min, 0, 0);
End;

Function TfsSql.GetVersion: String;
Begin
  Result := '0.0.0.103';
End;

Function TfsSql.GetVersionStr: String;
Begin
  Result := '0.0.0.103';
End;

Function TfsSql.GetVersionInfo: String;
Begin
  Result := '';
End;

Procedure TfsSql.SetVersion(Const Value: String);
Begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
End;

Procedure TfsSql.Parse;
Begin
  errDist := minErrDist;
  GetScanner._Reset;
  Get;
  _FSSQL;
End; {Parse}

Procedure TfsSql.InitSymSet;
Begin
  symSet[0, 0] := [EOFSYMB];
  symSet[0, 1] := [];
  symSet[0, 2] := [];
  symSet[0, 3] := [];
  symSet[0, 4] := [];
  symSet[0, 5] := [];
  symSet[0, 6] := [];
  symSet[0, 7] := [];
  symSet[1, 0] := [identSym, integer_Sym, float_Sym, SQLStringSym,
    SQLNameStringSym];
  symSet[1, 1] := [_lparenSym - 16];
  symSet[1, 2] := [COUNTSym - 32];
  symSet[1, 3] := [MINSym - 48, MAXSym - 48, SUMSym - 48, AVGSym - 48];
  symSet[1, 4] := [TRUESym - 64, FALSESym - 64, CASESym - 64, _minusSym - 64];
  symSet[1, 5] := [CHARACTER_underscoreLENGTHSym - 80,
    FLAGSsym - 80, COALESCESym - 80,
    CURRENT_underscoreDATESym - 80, CURRENT_underscoreTIMESym - 80,
    CURRENT_underscoreTIMESTAMPSym - 80,
    CASTSym - 80, USERSym - 80, LOWERSym - 80,
    UPPERSym - 80, POSITIONSym - 80, WeekNoSym - 80,
    SUBSTRINGSym - 80, TRIMSym - 80];
  symSet[1, 6] := [EXTRACTSym - 96, NULLIFSym - 96, ABSSym - 96, CEILINGSym - 96,
    FLOORSym - 96, EXPSym - 96, LOGSym - 96];
  symSet[1, 7] := [POWERSym - 112, RANDSym - 112, ROUNDSym - 112, _querySym - 112,
    DATESym - 112, TIMESym - 112, TIMESTAMPSym - 112, INTERVALSym - 112];
  symSet[1, 8] := [];
  symSet[1, 9] := [];
  symSet[1, 10] := [MODSym - 160, DIVSym - 160, ODDSym - 160, ONLINESym - 160, FIRSTSym - 160, INDEXNAMESym - 160, COMMITBYSym - 160];
  // 172 / 16 = 10(symset1,10) 172 mod 16 = 12 MODSym - 160=12
  //Result := x Mod setsize In s[x Div setsize];
  // Else If _In(symSet[1], fCurrentInputSymbol) Then
  symSet[1, 11] := [ARRAYsym - 176, LASTAUTOINCSYM - 176, NEXTAUTOINCSYM - 176, READLASTAUTOINCSYM - 176,
    ISRECORDLOCKEDSYM - 176, ISUNDELETEDRECORDSYM - 176, ISPROTECTDELETERECORDSYM - 176,
    ISPROTECTUPDATERECORDSYM - 176, ISMARKASBADRECORDSYM - 176];
  symSet[2, 0] := [identSym, integer_Sym, float_Sym, SQLStringSym,
    SQLNameStringSym, _minusSym];
  symSet[2, 1] := [_lparenSym - 16];
  symSet[2, 2] := [COUNTSym - 32];
  symSet[2, 3] := [MINSym - 48, MAXSym - 48, SUMSym - 48, AVGSym - 48, NOTSym - 48,
    EXISTSSym - 48, UNIQUESym - 48];
  symSet[2, 4] := [TRUESym - 64, FALSESym - 64, CASESym - 64, _minusSym - 64];
  symSet[2, 5] := [CHARACTER_underscoreLENGTHSym - 80,
    FLAGSsym - 80, COALESCESym - 80,
    CURRENT_underscoreDATESym - 80, CURRENT_underscoreTIMESym - 80,
    CURRENT_underscoreTIMESTAMPSym - 80,
    CASTSym - 80, USERSym - 80, LOWERSym - 80,
    UPPERSym - 80, POSITIONSym - 80, WeekNoSym - 80,
    SUBSTRINGSym - 80, TRIMSym - 80];
  symSet[2, 6] := [EXTRACTSym - 96, NULLIFSym - 96, ABSSym - 96, CEILINGSym - 96,
    FLOORSym - 96, EXPSym - 96, LOGSym - 96];
  symSet[2, 7] := [POWERSym - 112, RANDSym - 112, ROUNDSym - 112, _querySym - 112,
    DATESym - 112, TIMESym - 112, TIMESTAMPSym - 112, INTERVALSym - 112];
  symSet[2, 8] := [];
  symSet[2, 9] := [MODSym - 160, DIVSym - 160, ODDSym - 160, ONLINESym - 160, FIRSTSym - 160, INDEXNAMESym - 160, COMMITBYSym - 160];
  symSet[2, 10] := [ARRAYsym - 176, LASTAUTOINCSYM - 176, NEXTAUTOINCSYM - 176, READLASTAUTOINCSYM - 176, ISRECORDLOCKEDSYM - 176,
    ISUNDELETEDRECORDSYM - 176, ISPROTECTDELETERECORDSYM - 176,
    ISPROTECTUPDATERECORDSYM - 176, ISMARKASBADRECORDSYM - 176];

  symSet[3, 0] := [];
  symSet[3, 1] := [];
  symSet[3, 2] := [_equalSym - 32];
  symSet[3, 3] := [NOTSym - 48, _less_equalSym - 48, _lessSym - 48, _greaterSym - 48,
    _greater_equalSym - 48, _less_greaterSym - 48];
  symSet[3, 4] := [ISSym - 64, BETWEENSym - 64, LIKESym - 64, INSym - 64, MATCHSym - 64];
  symSet[3, 5] := [];
  symSet[3, 6] := [];
  symSet[3, 7] := [];
  symSet[4, 0] := [];
  symSet[4, 1] := [];
  symSet[4, 2] := [_equalSym - 32];
  symSet[4, 3] := [NOTSym - 48, _less_equalSym - 48, _lessSym - 48, _greaterSym - 48,
    _greater_equalSym - 48, _less_greaterSym - 48];
  symSet[4, 4] := [BETWEENSym - 64, LIKESym - 64, INSym - 64, MATCHSym - 64];
  symSet[4, 5] := [];
  symSet[4, 6] := [];
  symSet[4, 7] := [];
  symSet[5, 0] := [identSym, integer_Sym, float_Sym, SQLStringSym,
    SQLNameStringSym, ALLSym, DISTINCTSym, _minusSym];
  symSet[5, 1] := [_lparenSym - 16];
  symSet[5, 2] := [COUNTSym - 32];
  symSet[5, 3] := [MINSym - 48, MAXSym - 48, SUMSym - 48, AVGSym - 48];
  symSet[5, 4] := [TRUESym - 64, FALSESym - 64, CASESym - 64, _minusSym - 64];
  symSet[5, 5] := [CHARACTER_underscoreLENGTHSym - 80,
    FLAGSsym - 80, COALESCESym - 80,
    CURRENT_underscoreDATESym - 80, CURRENT_underscoreTIMESym - 80,
    CURRENT_underscoreTIMESTAMPSym - 80,
    CASTSym - 80, USERSym - 80, LOWERSym - 80,
    UPPERSym - 80, POSITIONSym - 80, WeekNoSym - 80,
    SUBSTRINGSym - 80, TRIMSym - 80];
  symSet[5, 6] := [EXTRACTSym - 96, NULLIFSym - 96, ABSSym - 96, CEILINGSym - 96,
    FLOORSym - 96, EXPSym - 96, LOGSym - 96];
  symSet[5, 7] := [POWERSym - 112, RANDSym - 112, ROUNDSym - 112, _querySym - 112,
    DATESym - 112, TIMESym - 112, TIMESTAMPSym - 112, INTERVALSym - 112];
  symSet[5, 8] := [];
  symSet[5, 9] := [MODSym - 160, DIVSym - 160, ODDSym - 160, ONLINESym - 160, FIRSTSym - 160, INDEXNAMESym - 160, COMMITBYSym - 160];
  symSet[5, 10] := [ARRAYsym - 176, LASTAUTOINCSYM - 176, NEXTAUTOINCSYM - 176, READLASTAUTOINCSYM - 176, ISRECORDLOCKEDSYM - 176,
    ISUNDELETEDRECORDSYM - 176, ISPROTECTDELETERECORDSYM - 176,
    ISPROTECTUPDATERECORDSYM - 176, ISMARKASBADRECORDSYM - 176];
  symSet[6, 0] := [];
  symSet[6, 1] := [UNIONSym - 16, JOINSym - 16, NATURALSym - 16, INNERSym - 16, LEFTSym - 16,
    RIGHTSym - 16, FULLSym - 16];
  symSet[6, 2] := [UNIONSym - 32];
  symSet[6, 3] := [];
  symSet[6, 4] := [];
  symSet[6, 5] := [];
  symSet[6, 6] := [];
  symSet[6, 7] := [];
  symSet[7, 0] := [];
  symSet[7, 1] := [UNIONSym - 16, CROSSSym - 16, JOINSym - 16, NATURALSym - 16, INNERSym - 16,
    LEFTSym - 16, RIGHTSym - 16, FULLSym - 16];
  symSet[7, 2] := [UNIONSym - 32];
  symSet[7, 3] := [];
  symSet[7, 4] := [];
  symSet[7, 5] := [];
  symSet[7, 6] := [];
  symSet[7, 7] := [];
End; {InitSymSet}

End { FFSQL }.

