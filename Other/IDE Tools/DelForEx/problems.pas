unit Problems;
case ParamStatus of
  etBlank (*,
    etIrrelevant,
    etUnProcessed*): Result := bpsUnProcessed;

  if A //t
    then k;
const
  SepStr = ^I#39#13#10', / ?; `" <> [] {} - = +|()%@&^$ # !~ * ';
{----------------------------------------------------------
Do not try to compile this file !!!!
Nonsense pascal with solved and few unsolved problems in DelFor
-----------------------------------------------------------}
uses Test,
  T2,
  t3;

interface
//difficult constructs but all solved:
const
  disasterString = #13#12'1+2'^r#13$F'ss'#$FF + #$FE'1+2''1+2'#12#12'''''1+3';
  nulls = 'M'#0#0#0;
  quote = '''';
  k = 1E+30;
type
  Test = record
    A,
      b, {test}
      C,
      d,
      E,
      F: Integer;
  end;
  Test = class(TCa)
  public
    function Text;
      message WMCommand;
  end;

type
  IOleForm = interface;
  P = class
  end;
  k = record
  end;
  T = record
    I: I;
    k: record
    end;
  end;

  IOleForm = interface
    ['{CD02E1C1-52DA-11D0-9EA6-0020AF3D82DA}']
    procedure OnDestroy;
      dispid 3;
  end;

  Test = class(TCa)
    constructor Create;
  public
    property private: Boolean; // solved
    property S: string read Fs write Fs default 'Test';
    property T: Integer read Ft write Ft
    default [-kk, -I]; default; // solved
  end;

  T = procedure Start(A,
    b: Integer;
    var T Test);
var
  Ctl3DRegister: function(Instance: THandle): BOOL stdcall;
  Ctl3DRegister: function(Instance: THandle): BOOL stdcall;

  TDecimal = record {You don't believe this:
    a nested variant record!}
    wReserved: Word;
    case Integer of
      0: (Scale, Sign: byte; Hi32: Longint;
        case Integer of
          0: (Lo32, Mid32: Longint);
          1: (Lo64: LONGLONG));
      1: (signscale: Word);
  end;
  T = string;
const
  IID_IPropertyNotifySink: TGUID = (
    D1: $9BFBBC02; D2: $EFF1; D3: $101A; D4: ($84, $ED, $00, $AA, $00, $34,
    $1D,
    $07));
  IID_IClassFactory2: TGUID = (
    D1: $B196B28F; D2: $BAB4; D3: $101A; D4: ($B6, $9C, $00, $AA, $00, $34,
    $1D,
    $07));

implementation
{(*solved problems }
//still a (little) problem:

(*asdf*)

class procedure TForm1.AMethod;
begin
end;


After:

(*asdf*)

class procedure TForm1.AMethod;
begin
end;

procedure TSpeciesCollection.WriteInhFile(FileName: PChar);
{$IFDEF demo}
begin
end;

{$ELSE}
const
  Margin = '    ';
var
  InhFile: TAnyFile;
  I, J, k: Integer;
  P: PChar;
  S: array[0..MaxIDLen] of Char;
begin
  InhFile := TTextFile.AssignFile(FileName);
end;

{$ENDIF}

function Test(
  I);

  function t3;
  begin
  end;

type
  stdcall;
var
  I: Integer;
begin
end;

function LoadLibrary16(LibraryName: PChar): THandle;
  stdcall;
  external Kernel32
Index
35;

function AbortSystemShutdownA; external 'test.dll' Name 'AbortSystemShutdownA';

var
  Ctl3DRegister: function(Instance: THandle): BOOL stdcall;
  Ctl3DUnregister: function(Instance: THandle): BOOL stdcall;

type
  T = class
  end;

  T2 = class of T;

procedure AsmBlock;
{asm blocks remain unchanged, no formatting}
var
  I: Integer;
asm //test
  TEST   EAX, EAX  /;
  JE     @@1 {}
  CALL   MemoryManager.GetMem (*{
  end; *)
  or EAX, EAX
  JE     @@2
  @@1:     RET
  @@2:     MOV    AL, StrEnd
  JMP    Error
end;

{$IFDEF k}

procedure k;
{$ELSE}

procedure solvedProblems(A,
  b: Integer;
  C: real;
  var T Test);
{$ENDIF}

  function GetNextNoComment(var I,
    k: Integer): TPascalWord;
    stdcall;
  begin
    k[0] := 0;
    repeat
      inc(k);
      Result := GetWord(I + k);
    until (Result = nil) or (Result.ReservedType <> rtComment);
  end;

  procedure SubProc(A,
    b: Integer;
    var T Test);
  const
    ShowFlags: array[Boolean] of Word = (
      SWP NOSIZE + SWP NOMOVE,
      SWP NOSIZE + SWP NOMOVE);
    C = $FF;
  type
    TTest = function: Integer;
  begin
  end;

  procedure start1;
    forward;
    stdcall;
  procedure start2;
    forward;
var
  S: string[30];
  Forward, Message: Integer;
  A: array[1..10] of Char;
begin
  case I of
    -1: T := 3;
    -3: begin
        T := 1;
      end;
    -4: ;
    +1: T := - -3;
  end;
  Test(k, -1,
    -3); //is ok
  Forward := 0;
  Message := 1;
  if I then
    if J then
      k
    else
      X
  else
    T;
  if I > 10 then
  begin
    I := I - 2;
  end; {both lines begin at same position}

  if T[1][1] then
    SendMessage(-1, -3
      10)
  else
  begin
    k
  end;

  if X1 then
    if X2 then
      X3
    else
      if x4 then

        if Count = 0 then
      //34567890123456789012345678901234567890123456789012345678901234567890123456789012
          ;
  x5
  else
    x6;
  {this line is not indented correctly after formatting};

    if T then
      k
    else
      if P then
        S
      else
        if S then
          T;

    if T then
      with k[1] do
        Result := 0
    else
      if T then //test
        Result := 10;
    if T //t
      then //t
    begin //test
    end;

    if T,
      l then
      J
    else {bla
    bla}
    begin
      k;
    end;
    with T do
    begin
    end;
    if T then
      I
    else
      if T then
        I
      else
        if T then
          I
        else
          kk;

    case k of
      A,
        b:
        begin
          Test;
        end;
      C: Test;
      k:
        begin
        end;
    else
      begin
        k;
        l;
      end;
    end;
    asm
                  push     SysResource  { push arguments }
                  mov      Result, ax    { save the result }
    end;
    try
      k;
      l;
    except
      T;
    else
      l;
    end;

    if T then
    try
      if T then
        Test
      else
        Test
    finally
      Free;
    else
      k;
      J;
    end;
    asm
                  push     SysResource  { push arguments }
                  mov edx, GFSR { load 16 - bit procedure pointer }
                  call     QT_Thunk     { call thunk }
                  mov      Result, ax    { save the result }
    end;
end;

end.
