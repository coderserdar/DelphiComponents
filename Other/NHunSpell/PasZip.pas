/// ZIP/LZ77 Deflate/Inflate Compression in pure pascal
// - this unit is a part of the freeware Synopse framekork,
// licensed in the LGPL v3; version 1.5
unit PasZip;

{
  This file is part of Synopse SQLite3 database framework.

  Synopse SQLite3 database framework. Copyright (C) 2010 Arnaud Bouchez
  Synopse Informatique - http://synopse.info

  This library is free software; you can redistribute it and/or modify it
  under the terms of the GNU Lesser General Public License as published by
  the Free Software Foundation; either version 3 of the License, or (at
  your option) any later version.

  This library is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this library. If not, see <http://www.gnu.org/licenses/>.



  PasZip.pas from madZip.pas  - original version: 0.1b, date: 2003-06-09
  ------------------------------------------------------------------------
  compression stuff compatible with LZ77 Deflate/Inflate

  Improvements by A.Bouchez on 2006-2010 - http://bouchez.info
  - CRC32 table can be generated by code (safe 1KB in executable)
  - Inflate made 50% faster than MadLib's original by tuned Move() usage
  and some critical part rewrite
  - included .zip archive reading from file, resource or direct memory
  - included .zip archive write into a file (new .zip creation, not update)

}
{$WARNINGS OFF}
{$Q-,R-}  // Turn range checking and overflow checking off

{ $D-,L- }

interface

uses
{$IFDEF WIN32}
  Windows,
{$ELSE}
  LibC, Types,
{$ENDIF}
  SysUtils;

/// compress memory using the ZLib DEFLATE algorithm
function CompressMem(src, dst: Pointer; srcLen, dstLen: Integer): Integer;

/// uncompress memory using the ZLib INFLATE algorithm
function UnCompressMem(src, dst: Pointer; srcLen, dstLen: Integer): Integer;

/// compress memory using the ZLib DEFLATE algorithm
function CompressString(const data: String;
  failIfGrow: Boolean = false): String;

/// uncompress memory using the ZLib INFLATE algorithm
function UncompressString(const data: String): String;
{$IFDEF WIN32} { use Windows MapFile }
function CompressFile(const srcFile, dstFile: String;
  failIfGrow: Boolean = false): Boolean;
function UncompressFile(const srcFile, dstFile: String;
  lastWriteTime: int64 = 0; attr: dword = 0): Boolean;

function GetCompressedFileInfo(const comprFile: String; var Size: int64;
  var crc32: dword): Boolean;
function GetUncompressedFileInfo(const uncomprFile: String; var Size: int64;
  var crc32: dword): Boolean;
function IsCompressedFileEqual(const uncomprFile, comprFile: String): Boolean;

{ { You can create a "zip" compatible archive by calling the "Zip" function.
  The first parameter is the full file path of the new zip archive.
  The second parameter must be an array of the files you want to have zipped
  into the archive (full file path again, please).
  The third array (only file names, please) allows you to store the files into
  the zip under a different name.
  Generally the resulting zip archive should not contain any directory structure:
  all zipped files are directly stored in the archive's root, if NoSubDirectories
  is set to TRUE. }
function Zip(const Zip: String; const files, zipAs: array of String;
  NoSubDirectories: Boolean = false): Boolean;
{$ENDIF}
/// create a void .zip file
procedure CreateVoidZip(const AFileName: String);

/// create a compatible .gz file (returns file Size)
function GzCompress(src: Pointer; srcLen: Integer;
  const fName: String): cardinal;

/// calculate the CRC32 hash of a specified memory buffer
function UpdateCrc32(acrc32: cardinal; inBuf: Pointer;
  inLen: Integer): cardinal;
{$DEFINE DYNAMIC_CRC_TABLE}
{ if defined, the crc32Tab[] is created on staturp: save 1KB of code Size }

/// the static buffer used for fast CRC32 hashing
{$IFDEF DYNAMIC_CRC_TABLE}

var
  crc32Tab: array [0 .. 255] of cardinal;
{$ELSE}

const
  crc32Tab: array [0 .. 255] of cardinal = ($00000000, $77073096, $EE0E612C,
    $990951BA, $076DC419, $706AF48F, $E963A535, $9E6495A3, $0EDB8832,
    $79DCB8A4, $E0D5E91E, $97D2D988, $09B64C2B, $7EB17CBD, $E7B82D07,
    $90BF1D91, $1DB71064, $6AB020F2, $F3B97148, $84BE41DE, $1ADAD47D,
    $6DDDE4EB, $F4D4B551, $83D385C7, $136C9856, $646BA8C0, $FD62F97A,
    $8A65C9EC, $14015C4F, $63066CD9, $FA0F3D63, $8D080DF5, $3B6E20C8,
    $4C69105E, $D56041E4, $A2677172, $3C03E4D1, $4B04D447, $D20D85FD,
    $A50AB56B, $35B5A8FA, $42B2986C, $DBBBC9D6, $ACBCF940, $32D86CE3,
    $45DF5C75, $DCD60DCF, $ABD13D59, $26D930AC, $51DE003A, $C8D75180,
    $BFD06116, $21B4F4B5, $56B3C423, $CFBA9599, $B8BDA50F, $2802B89E,
    $5F058808, $C60CD9B2, $B10BE924, $2F6F7C87, $58684C11, $C1611DAB,
    $B6662D3D, $76DC4190, $01DB7106, $98D220BC, $EFD5102A, $71B18589,
    $06B6B51F, $9FBFE4A5, $E8B8D433, $7807C9A2, $0F00F934, $9609A88E,
    $E10E9818, $7F6A0DBB, $086D3D2D, $91646C97, $E6635C01, $6B6B51F4,
    $1C6C6162, $856530D8, $F262004E, $6C0695ED, $1B01A57B, $8208F4C1,
    $F50FC457, $65B0D9C6, $12B7E950, $8BBEB8EA, $FCB9887C, $62DD1DDF,
    $15DA2D49, $8CD37CF3, $FBD44C65, $4DB26158, $3AB551CE, $A3BC0074,
    $D4BB30E2, $4ADFA541, $3DD895D7, $A4D1C46D, $D3D6F4FB, $4369E96A,
    $346ED9FC, $AD678846, $DA60B8D0, $44042D73, $33031DE5, $AA0A4C5F,
    $DD0D7CC9, $5005713C, $270241AA, $BE0B1010, $C90C2086, $5768B525,
    $206F85B3, $B966D409, $CE61E49F, $5EDEF90E, $29D9C998, $B0D09822,
    $C7D7A8B4, $59B33D17, $2EB40D81, $B7BD5C3B, $C0BA6CAD, $EDB88320,
    $9ABFB3B6, $03B6E20C, $74B1D29A, $EAD54739, $9DD277AF, $04DB2615,
    $73DC1683, $E3630B12, $94643B84, $0D6D6A3E, $7A6A5AA8, $E40ECF0B,
    $9309FF9D, $0A00AE27, $7D079EB1, $F00F9344, $8708A3D2, $1E01F268,
    $6906C2FE, $F762575D, $806567CB, $196C3671, $6E6B06E7, $FED41B76,
    $89D32BE0, $10DA7A5A, $67DD4ACC, $F9B9DF6F, $8EBEEFF9, $17B7BE43,
    $60B08ED5, $D6D6A3E8, $A1D1937E, $38D8C2C4, $4FDFF252, $D1BB67F1,
    $A6BC5767, $3FB506DD, $48B2364B, $D80D2BDA, $AF0A1B4C, $36034AF6,
    $41047A60, $DF60EFC3, $A867DF55, $316E8EEF, $4669BE79, $CB61B38C,
    $BC66831A, $256FD2A0, $5268E236, $CC0C7795, $BB0B4703, $220216B9,
    $5505262F, $C5BA3BBE, $B2BD0B28, $2BB45A92, $5CB36A04, $C2D7FFA7,
    $B5D0CF31, $2CD99E8B, $5BDEAE1D, $9B64C2B0, $EC63F226, $756AA39C,
    $026D930A, $9C0906A9, $EB0E363F, $72076785, $05005713, $95BF4A82,
    $E2B87A14, $7BB12BAE, $0CB61B38, $92D28E9B, $E5D5BE0D, $7CDCEFB7,
    $0BDBDF21, $86D3D2D4, $F1D4E242, $68DDB3F8, $1FDA836E, $81BE16CD,
    $F6B9265B, $6FB077E1, $18B74777, $88085AE6, $FF0F6A70, $66063BCA,
    $11010B5C, $8F659EFF, $F862AE69, $616BFFD3, $166CCF45, $A00AE278,
    $D70DD2EE, $4E048354, $3903B3C2, $A7672661, $D06016F7, $4969474D,
    $3E6E77DB, $AED16A4A, $D9D65ADC, $40DF0B66, $37D83BF0, $A9BCAE53,
    $DEBB9EC5, $47B2CF7F, $30B5FFE9, $BDBDF21C, $CABAC28A, $53B39330,
    $24B4A3A6, $BAD03605, $CDD70693, $54DE5729, $23D967BF, $B3667A2E,
    $C4614AB8, $5D681B02, $2A6F2B94, $B40BBE37, $C30C8EA1, $5A05DF1B,
    $2D02EF8D);
{$ENDIF}

type
  PFileInfo = ^TFileInfo;

  { { generic file information structure, as used in .zip file format
    - used in any header, contains info about following block }
  TFileInfo = packed record
    neededVersion: word; // $14
    flags: word; // 0
    zzipMethod: word; // 8 (deflate)
    zlastModTime: word; // dos format
    zlastModDate: word; // dos format
    zcrc32: dword;
    zzipSize: dword;
    zfullSize: dword;
    nameLen: word; // length(name)
    extraLen: word; // 0
  end;

  { { internal file information structure, as used in .zip file format
    - used locally inside the file stream, followed by the name and then the data }
  TLocalFileHeader = packed record
    signature: dword; // $04034b50
    fileInfo: TFileInfo;
  end;

  { { directory file information structure, as used in .zip file format
    - used at the end of the zip file to recap all entries }
  TFileHeader = packed record
    signature: dword; // $02014b50
    madeBy: word; // $14
    fileInfo: TFileInfo;
    commentLen: word; // 0
    firstDiskNo: word; // 0
    intFileAttr: word; // 0 = binary; 1 = text
    extFileAttr: dword; // dos file attributes
    localHeadOff: dword; // @TLocalFileHeader
  end;

  { { last header structure, as used in .zip file format
    - this header ends the file and is used to find the TFileHeader entries }
  TLastHeader = packed record
    signature: dword; // $06054b50
    thisDisk: word; // 0
    headerDisk: word; // 0
    thisFiles: word; // 1
    totalFiles: word; // 1
    headerSize: dword; // sizeOf(TFileHeaders + names)
    headerOffset: dword; // @TFileHeader
    commentLen: word; // 0
  end;
{$IFDEF WIN32}

type
  /// stores an entry of a file inside a .zip archive
  TZipEntry = packed record

    /// the information of this file, as stored in the .zip archive

    info: PFileInfo;

    /// points to the compressed data in the .zip archive, mapped in memory

    data: PAnsiChar;

    /// ASCIIZ name of the file inside the .zip archive

    // - not a String, but a fixed-length array of char

    Name: array [0 .. 127 - 8] of AnsiChar;
  end;

  /// read-only access to a .zip archive file
  // - can open directly a specified .zip file (will be memory mapped for fast access)
  // - can open a .zip archive file content from a resource (embedded in the executable)
  // - can open a .zip archive file content from memory
  TZipRead = class
  private
    file_, map: dword; // we use a memory mapped file to access the zip content
    Buf: PByteArray;
    fZipStartOffset: cardinal;
    procedure UnMap;
  public
    /// the number of files inside a .zip archive
    Count: Integer;
    /// the files inside the .zip archive
    Entry: array of TZipEntry;

    /// open a .zip archive file as Read Only
    constructor Create(const AFileName: TFileName;
      ZipStartOffset: cardinal = 0; Size: cardinal = 0;
      ShowMessageBoxOnError: Boolean = true); overload;
    /// open a .zip archive file directly from a resource
    constructor Create(Instance: THandle; const ResName: String;
      ResType: PChar); overload;
    /// open a .zip archive file directly from memory
    constructor Create(BufZip: PByteArray; Size: cardinal); overload;
    /// release associated memory
    destructor Destroy; override;

    /// get the index of a file inside the .zip archive
    function NameToIndex(const aName: AnsiString): Integer;
    /// uncompress a file stored inside the .zip archive into a destination folder
    function UnZipFile(AIndex: Integer; DestPath: String; ForceWriteFlush: Boolean): Boolean;
    /// uncompress a file stored inside the .zip archive into memory
    function UnZip(AIndex: Integer): AnsiString; overload;
    /// read the file from the supplied folder, and check its content according
    // to the crc32 stored inside the .zip archive header (no decompression is made)
    function CheckFile(AIndex: Integer; DestPath: String): Boolean;
    /// get any initial .exe file
    function GetInitialExeContent: AnsiString;
    /// the starting offset of the .zip content, after the initial .exe, if any
    // - can be used to copy the initial .exe file
    property ZipStartOffset: cardinal read fZipStartOffset;
  end;
{$ENDIF}

  /// write-only access for creating a .zip archive file
  // - not to be used to update a .zip file, but to create a new one
  // - update can be done manualy by using a TZipRead instance and the
  // AddFromZip() method
  TZipWrite = class
  protected
    fAppendOffset: cardinal;
    fFileName: TFileName;
    fMagic: cardinal;
  public
    /// the associated file handle
    Handle: Integer;
    /// the total number of entries
    Count: Integer;
    /// the resulting file entries
    Entry: array of record
    /// the file name
      name: AnsiString;
    /// the corresponding file header
    fhr: TFileHeader;
  end;

  /// initialize the .zip file
constructor Create(const AFileName: TFileName); overload;
/// compress (using the deflate method) a memory buffer, and add it to the zip file
// - by default, the 1st of January, 2010 is used if not date is supplied
procedure AddDeflated(const AFileName: AnsiString; Buf: Pointer; Size: Integer;
  CompressLevel: Integer = 6; FileAge: Integer = 1 + 1 shl 5 + 30 shl 9);
  overload;
/// compress (using the deflate method) a file, and add it to the zip file
procedure AddDeflated(const AFileName: AnsiString; RemovePath: Boolean = true;
  CompressLevel: Integer = 6); overload;
/// add a memory buffer to the zip file, without compression
// - content is stored, not deflated
// (in that case, no deflate code is added to the executable)
// - by default, the 1st of January, 2010 is used if not date is supplied
procedure AddStored(const AFileName: AnsiString; Buf: Pointer; Size: Integer;
  FileAge: Integer = 1 + 1 shl 5 + 30 shl 9);
/// add a file from an already compressed zip entry
procedure AddFromZip(const ZipEntry: TZipEntry);
/// append a file content into the destination file
// - usefull to add the initial Setup.exe file, e.g.
procedure Append(const Content: AnsiString);
/// release associated memory, and close destination file
destructor Destroy; override;
end;

implementation

procedure MoveWithOverlap(src: PByte; dst: PByte; Count: Integer);
// special tuned Move() routine, including data overlap bug correction
{$IFDEF PUREPASCAL}
var
  i: Integer;
begin // should be fast enough in practice
  for i := 1 to Count do
  begin
    dst^ := src^;
    inc(dst);
    inc(src);
  end;
end;
{$ELSE}
asm // eax=source edx=dest ecx=count
  push edx
  sub edx,eax
  cmp edx,ecx // avoid move error if dest and source overlaps
  pop edx     // restore original edx=dest
  ja System.Move // call FastMove() routine for normal code
  or ecx,ecx
  jz @@Exit
  push edi
  mov edi,edx // restore original edi=dest
@@overlap: // byte by byte slower but accurate move routine
  mov dl,[eax]
  inc eax
  mov [edi],dl
  inc edi
  dec ecx
  jnz @@overlap
  pop edi
@@Exit:
end;
{$ENDIF}

// ----------------- general library stuff
const
  CMemLevel = 8;
  CWindowBits = 15;

type
  TPInt64 = ^int64;
  TPCardinal = ^cardinal;
  TPWord = ^word;
  TAByte = array [0 .. maxInt - 1] of byte;
  TPAByte = ^TAByte;
  TAWord = array [0 .. maxInt shr 1 - 1] of word;
  TPAWord = ^TAWord;
  TAInteger = array [0 .. maxInt shr 2 - 1] of Integer;
  TPAInteger = ^TAInteger;
  TACardinal = array [0 .. maxInt shr 2 - 1] of cardinal;
  TPACardinal = ^TACardinal;
  TAInt64 = array [0 .. maxInt shr 3 - 1] of int64;
  TPAInt64 = ^TAInt64;

  PInflateHuft = ^TInflateHuft;

  TInflateHuft = record
    Exop, // number of extra bits or operation
    Bits: byte; // number of bits in this code or subcode
    Base: cardinal; // literal, Length base, or distance base or table offset
  end;

  THuftField = array [0 .. (maxInt div SizeOf(TInflateHuft)) - 1]
    of TInflateHuft;
  PHuftField = ^THuftField;
  PPInflateHuft = ^PInflateHuft;

  TInflateCodesMode = ( // waiting for "I:"=input, "O:"=output, "X:"=nothing
    icmStart, // X: set up for Len
    icmLen, // I: get length/literal/eob next
    icmLenNext, // I: getting length extra (have base)
    icmDistance, // I: get distance next
    icmDistExt, // I: getting distance extra
    icmCopy, // O: copying bytes in window, waiting for space
    icmLit, // O: got literal, waiting for output space
    icmWash, // O: got eob, possibly still output waiting
    icmZEnd, // X: got eob and all data flushed
    icmBadCode // X: got error
    );

  // inflate codes private state
  PInflateCodesState = ^TInflateCodesState;

  TInflateCodesState = record
    Mode: TInflateCodesMode; // current inflate codes mode
    // mode dependent information
    Len: cardinal;
    sub: record // submode
      case byte of 0: (Code: record // if Len or Distance, where in tree
        Tree: PInflateHuft; // Pointer into tree
      need: cardinal; // bits needed
      end);
    1: (lit: cardinal); // if icmLit, literal
    2: (copy: record // if EXT or icmCopy, where and how much
        get: cardinal; // bits to get for extra
      Distance: cardinal; // distance back to copy from
      end);
  end;

  // mode independent information
LiteralTreeBits :
byte; // LiteralTree bits decoded per branch
DistanceTreeBits :
byte; // DistanceTree bits decoder per branch
LiteralTree :
PInflateHuft; // literal/length/eob tree
DistanceTree :
PInflateHuft; // distance tree
end;

TInflateBlockMode = (ibmZType, // get type bits (3, including end bit)
  ibmLens, // get lengths for stored
  ibmStored, // processing stored block
  ibmTable, // get table lengths
  ibmBitTree, // get bit lengths tree for a dynamic block
  ibmDistTree, // get length, distance trees for a dynamic block
  ibmCodes, // processing fixed or dynamic block
  ibmDry, // output remaining window bytes
  ibmBlockDone, // finished last block, done
  ibmBlockBad // got a data error -> stuck here
  );

// inflate blocks semi-private state
PInflateBlocksState = ^TInflateBlocksState;
TInflateBlocksState = record Mode: TInflateBlockMode;
// current inflate block mode
// mode dependent information
sub :
record // submode
case byte of
  0:
    (left: cardinal); // if ibmStored, bytes left to copy
  1:
    (Trees: record // if DistanceTree, decoding info for trees
        Table: cardinal; // table lengths (14 Bits)
      Index: cardinal; // index into blens (or BitOrder)
      blens: TPACardinal; // bit lengths of codes
      BB: cardinal; // bit length tree depth
      TB: PInflateHuft; // bit length decoding tree
      end);
  2:
    (decode: record // if ibmCodes, current state
        TL: PInflateHuft;
      TD: PInflateHuft; // trees to free
      codes: PInflateCodesState;
      end);
end;
Last :
Boolean; // True if this block is the last block

// mode independent information
bitk :
cardinal; // bits in bit buffer
bitb :
cardinal; // bit buffer
hufts :
PHuftField; // single allocation for tree space
window :
PByte; // sliding window
zend :
PByte; // one byte after sliding window
read :
PByte; // window read Pointer
write :
PByte; // window write Pointer
end;

// The application must update NextInput and AvailableInput when AvailableInput has dropped to zero. It must update
// NextOutput and AvailableOutput when AvailableOutput has dropped to zero. All other fields are set by the
// compression library and must not be updated by the application.
//
// The fields TotalInput and TotalOutput can be used for statistics or progress reports. After compression, TotalInput
// holds the total Size of the uncompressed data and may be saved for use in the decompressor
// (particularly if the decompressor wants to decompress everything in a single step).

PZState = ^TZState;
TZState = record NextInput: PByte; // next input byte
AvailableInput :
cardinal; // number of bytes available at NextInput
TotalInput :
cardinal; // total number of input bytes read so far
NextOutput :
PByte; // next output byte should be put there
AvailableOutput :
cardinal; // remaining free space at NextOutput
TotalOutput :
cardinal; // total number of bytes output so far
State :
PInflateBlocksState; // not visible by applications
end;

const
  // Return codes for the compression/decompression functions. Negative
  // values are errors, positive values are used for special but normal events.
  Z_OK = 0;
  Z_STREAM_END = 1;
  Z_STREAM_ERROR = -2;
  Z_DATA_ERROR = -3;
  Z_MEM_ERROR = -4;
  Z_BUF_ERROR = -5;

  // three kinds of block type
  STORED_BLOCK = 0;
  STATIC_TREES = 1;
  DYN_TREES = 2;

  // minimum and maximum match lengths
  MIN_MATCH = 3;
  MAX_MATCH = 258;


  // ----------------- deflation support

const
  LENGTH_CODES = 29; // number of length codes, not counting the special END_BLOCK code
  LITERALS = 256; // number of literal bytes 0..255
  L_CODES = (LITERALS + 1 + LENGTH_CODES);
  // number of literal or length codes, including the END_BLOCK code
  D_CODES = 30; // number of distance codes
  BL_CODES = 19; // number of codes used to transfer the bit lengths
  HEAP_SIZE = (2 * L_CODES + 1); // maximum heap Size
  MAX_BITS = 15; // all codes must not exceed MAX_BITS bits

type
  // data structure describing a single value and its code String
  PTreeEntry = ^TTreeEntry;

  TTreeEntry = record
    fc: record case byte of 0: (Frequency: word); // frequency count
    1: (Code: word); // bit String
  end;

dl :
record
case byte of
  0:
    (dad: word); // father node in Huffman tree
  1:
    (Len: word); // length of bit String
end;
end;

TLiteralTree = array [0 .. HEAP_SIZE - 1] of TTreeEntry;
// literal and length tree
TDistanceTree = array [0 .. 2 * D_CODES] of TTreeEntry; // distance tree
THuffmanTree = array [0 .. 2 * BL_CODES] of TTreeEntry;
// Huffman tree for bit lengths

PTree = ^TTree;
TTree = array [0 .. (maxInt div SizeOf(TTreeEntry)) - 1] of TTreeEntry;
// generic tree type

PStaticTreeDescriptor = ^TStaticTreeDescriptor;
TStaticTreeDescriptor = record StaticTree: PTree; // static tree or nil
ExtraBits :
TPAInteger; // extra bits for each code or nil
ExtraBase :
Integer; // base index for ExtraBits
Elements :
Integer; // max number of elements in the tree
MaxLength :
Integer; // max bit length for the codes
end;

PTreeDescriptor = ^TTreeDescriptor;
TTreeDescriptor = record DynamicTree: PTree;
MaxCode :
Integer; // largest code with non zero frequency
StaticDescriptor :
PStaticTreeDescriptor; // the corresponding static tree
end;

PDeflateState = ^TDeflateState;
TDeflateState = record ZState: PZState; // Pointer back to this zlib stream
PendingBuffer :
TPAByte; // output still pending
PendingBufferSize :
Integer;
PendingOutput :
PByte; // next pending byte to output to the stream
Pending :
Integer; // nb of bytes in the pending buffer
WindowSize :
cardinal; // LZ77 window Size (32K by default)
WindowBits :
cardinal; // log2(WindowSize) (8..16)
WindowMask :
cardinal; // WindowSize - 1

// Sliding window. Input bytes are read into the second half of the window,
// and move to the first half later to keep a dictionary of at least WSize
// bytes. With this organization, matches are limited to a distance of
// WSize - MAX_MATCH bytes, but this ensures that IO is always
// performed with a length multiple of the block Size. Also, it limits
// the window Size to 64K, which is quite useful on MSDOS.
// To do: use the user input buffer as sliding window.
window :
TPAByte;

// Actual Size of Window: 2 * WSize, except when the user input buffer
// is directly used as sliding window.
CurrentWindowSize :
Integer;

// Link to older String with same hash index. to limit the Size of this
// array to 64K, this link is maintained only for the last 32K strings.
// An index in this array is thus a window index modulo 32K.
Previous :
TPAWord;

Head :
TPAWord; // heads of the hash chains or nil

InsertHash :
cardinal; // hash index of String to be inserted
HashSize :
cardinal; // number of elements in hash table
HashBits :
cardinal; // log2(HashSize)
HashMask :
cardinal; // HashSize - 1

// Number of bits by which InsertHash must be shifted at each input step.
// It must be such that after MIN_MATCH steps, the oldest byte no longer
// takes part in the hash key, that is:
// HashShift * MIN_MATCH >= HashBits
HashShift :
cardinal;

// Window position at the beginning of the current output block. Gets
// negative when the window is moved backwards.
BlockStart :
Integer;

MatchLength :
cardinal; // length of best match
PreviousMatch :
cardinal; // previous match
MatchAvailable :
Boolean; // set if previous match exists
StringStart :
cardinal; // start of String to insert
MatchStart :
cardinal; // start of matching String
Lookahead :
cardinal; // number of valid bytes ahead in window

// Length of the best match at previous step. Matches not greater than this
// are discarded. This is used in the lazy match evaluation.
PreviousLength :
cardinal;

LiteralTree :
TLiteralTree; // literal and length tree
DistanceTree :
TDistanceTree; // distance tree
BitLengthTree :
THuffmanTree; // Huffman tree for bit lengths

LiteralDescriptor :
TTreeDescriptor; // Descriptor for literal tree
DistanceDescriptor :
TTreeDescriptor; // Descriptor for distance tree
BitLengthDescriptor :
TTreeDescriptor; // Descriptor for bit length tree

BitLengthCounts :
array [0 .. MAX_BITS] of word; // number of codes at each bit length for an optimal tree

Heap :
array [0 .. 2 * L_CODES] of Integer; // heap used to build the Huffman trees
HeapLength :
Integer; // number of elements in the heap
HeapMaximum :
Integer; // element of largest frequency
// The sons of Heap[N] are Heap[2 * N] and Heap[2 * N + 1]. Heap[0] is not used.
// The same heap array is used to build all trees.

Depth :
array [0 .. 2 * L_CODES] of byte; // depth of each subtree used as tie breaker for trees of equal frequency

LiteralBuffer :
TPAByte; // buffer for literals or lengths

// Size of match buffer for literals/lengths. There are 4 reasons for limiting LiteralBufferSize to 64K:
// - frequencies can be kept in 16 bit counters
// - If compression is not successful for the first block, all input
// data is still in the window so we can still emit a stored block even
// when input comes from standard input. This can also be done for
// all blocks if LiteralBufferSize is not greater than 32K.
// - if compression is not successful for a file smaller than 64K, we can
// even emit a stored file instead of a stored block (saving 5 bytes).
// This is applicable only for zip (not gzip or zlib).
// - creating new Huffman trees less frequently may not provide fast
// adaptation to changes in the input data statistics. (Take for
// example a binary file with poorly compressible code followed by
// a highly compressible String table.) Smaller buffer sizes give
// fast adaptation but have of course the overhead of transmitting
// trees more frequently.
// - I can't count above 4
LiteralBufferSize :
cardinal;

LastLiteral :
cardinal; // running index in LiteralBuffer

// Buffer for distances. To simplify the code, DistanceBuffer and LiteralBuffer have
// the same number of elements. To use different lengths, an extra flag array would be necessary.
DistanceBuffer :
TPAWord;

OptimalLength :
Integer; // bit length of current block with optimal trees
StaticLength :
Integer; // bit length of current block with static trees
CompressedLength :
Integer; // total bit length of compressed file
Matches :
cardinal; // number of String matches in current block
LastEOBLength :
Integer; // bit length of EOB code for last block
BitsBuffer :
word; // Output buffer. Bits are inserted starting at the bottom (least significant bits).
ValidBits :
Integer; // Number of valid bits in BitsBuffer. All Bits above the last valid bit are always zero.
end;

// ----------------- Huffmann trees

const
  DIST_CODE_LEN = 512; // see definition of array dist_code below

  // The static literal tree. Since the bit lengths are imposed, there is no need for the L_CODES Extra codes used
  // during heap construction. However the codes 286 and 287 are needed to build a canonical tree (see TreeInit below).
  StaticLiteralTree: array [0 .. L_CODES + 1] of TTreeEntry =
    ((fc: (Frequency: 12); dl: (Len: 8)), (fc: (Frequency: 140);
      dl: (Len: 8)), (fc: (Frequency: 76); dl: (Len: 8)),
    (fc: (Frequency: 204); dl: (Len: 8)), (fc: (Frequency: 44); dl: (Len: 8)),
    (fc: (Frequency: 172); dl: (Len: 8)), (fc: (Frequency: 108); dl: (Len: 8)),
    (fc: (Frequency: 236); dl: (Len: 8)), (fc: (Frequency: 28); dl: (Len: 8)),
    (fc: (Frequency: 156); dl: (Len: 8)), (fc: (Frequency: 92); dl: (Len: 8)),
    (fc: (Frequency: 220); dl: (Len: 8)), (fc: (Frequency: 60); dl: (Len: 8)),
    (fc: (Frequency: 188); dl: (Len: 8)), (fc: (Frequency: 124);
      dl: (Len: 8)), (fc: (Frequency: 252); dl: (Len: 8)),
    (fc: (Frequency: 2); dl: (Len: 8)), (fc: (Frequency: 130); dl: (Len: 8)),
    (fc: (Frequency: 66); dl: (Len: 8)), (fc: (Frequency: 194); dl: (Len: 8)),
    (fc: (Frequency: 34); dl: (Len: 8)), (fc: (Frequency: 162); dl: (Len: 8)),
    (fc: (Frequency: 98); dl: (Len: 8)), (fc: (Frequency: 226); dl: (Len: 8)),
    (fc: (Frequency: 18); dl: (Len: 8)), (fc: (Frequency: 146); dl: (Len: 8)),
    (fc: (Frequency: 82); dl: (Len: 8)), (fc: (Frequency: 210); dl: (Len: 8)),
    (fc: (Frequency: 50); dl: (Len: 8)), (fc: (Frequency: 178); dl: (Len: 8)),
    (fc: (Frequency: 114); dl: (Len: 8)), (fc: (Frequency: 242);
      dl: (Len: 8)), (fc: (Frequency: 10); dl: (Len: 8)),
    (fc: (Frequency: 138); dl: (Len: 8)), (fc: (Frequency: 74); dl: (Len: 8)),
    (fc: (Frequency: 202); dl: (Len: 8)), (fc: (Frequency: 42); dl: (Len: 8)),
    (fc: (Frequency: 170); dl: (Len: 8)), (fc: (Frequency: 106);
      dl: (Len: 8)), (fc: (Frequency: 234); dl: (Len: 8)),
    (fc: (Frequency: 26); dl: (Len: 8)), (fc: (Frequency: 154); dl: (Len: 8)),
    (fc: (Frequency: 90); dl: (Len: 8)), (fc: (Frequency: 218); dl: (Len: 8)),
    (fc: (Frequency: 58); dl: (Len: 8)), (fc: (Frequency: 186); dl: (Len: 8)),
    (fc: (Frequency: 122); dl: (Len: 8)), (fc: (Frequency: 250); dl: (Len: 8)),
    (fc: (Frequency: 6); dl: (Len: 8)), (fc: (Frequency: 134); dl: (Len: 8)),
    (fc: (Frequency: 70); dl: (Len: 8)), (fc: (Frequency: 198); dl: (Len: 8)),
    (fc: (Frequency: 38); dl: (Len: 8)), (fc: (Frequency: 166); dl: (Len: 8)),
    (fc: (Frequency: 102); dl: (Len: 8)), (fc: (Frequency: 230);
      dl: (Len: 8)), (fc: (Frequency: 22); dl: (Len: 8)),
    (fc: (Frequency: 150); dl: (Len: 8)), (fc: (Frequency: 86); dl: (Len: 8)),
    (fc: (Frequency: 214); dl: (Len: 8)), (fc: (Frequency: 54); dl: (Len: 8)),
    (fc: (Frequency: 182); dl: (Len: 8)), (fc: (Frequency: 118);
      dl: (Len: 8)), (fc: (Frequency: 246); dl: (Len: 8)),
    (fc: (Frequency: 14); dl: (Len: 8)), (fc: (Frequency: 142); dl: (Len: 8)),
    (fc: (Frequency: 78); dl: (Len: 8)), (fc: (Frequency: 206); dl: (Len: 8)),
    (fc: (Frequency: 46); dl: (Len: 8)), (fc: (Frequency: 174); dl: (Len: 8)),
    (fc: (Frequency: 110); dl: (Len: 8)), (fc: (Frequency: 238); dl: (Len: 8)),
    (fc: (Frequency: 30); dl: (Len: 8)), (fc: (Frequency: 158); dl: (Len: 8)),
    (fc: (Frequency: 94); dl: (Len: 8)), (fc: (Frequency: 222); dl: (Len: 8)),
    (fc: (Frequency: 62); dl: (Len: 8)), (fc: (Frequency: 190); dl: (Len: 8)),
    (fc: (Frequency: 126); dl: (Len: 8)), (fc: (Frequency: 254);
      dl: (Len: 8)), (fc: (Frequency: 1); dl: (Len: 8)),
    (fc: (Frequency: 129); dl: (Len: 8)), (fc: (Frequency: 65); dl: (Len: 8)),
    (fc: (Frequency: 193); dl: (Len: 8)), (fc: (Frequency: 33); dl: (Len: 8)),
    (fc: (Frequency: 161); dl: (Len: 8)), (fc: (Frequency: 97); dl: (Len: 8)),
    (fc: (Frequency: 225); dl: (Len: 8)), (fc: (Frequency: 17); dl: (Len: 8)),
    (fc: (Frequency: 145); dl: (Len: 8)), (fc: (Frequency: 81); dl: (Len: 8)),
    (fc: (Frequency: 209); dl: (Len: 8)), (fc: (Frequency: 49); dl: (Len: 8)),
    (fc: (Frequency: 177); dl: (Len: 8)), (fc: (Frequency: 113);
      dl: (Len: 8)), (fc: (Frequency: 241); dl: (Len: 8)),
    (fc: (Frequency: 9); dl: (Len: 8)), (fc: (Frequency: 137); dl: (Len: 8)),
    (fc: (Frequency: 73); dl: (Len: 8)), (fc: (Frequency: 201); dl: (Len: 8)),
    (fc: (Frequency: 41); dl: (Len: 8)), (fc: (Frequency: 169); dl: (Len: 8)),
    (fc: (Frequency: 105); dl: (Len: 8)), (fc: (Frequency: 233);
      dl: (Len: 8)), (fc: (Frequency: 25); dl: (Len: 8)),
    (fc: (Frequency: 153); dl: (Len: 8)), (fc: (Frequency: 89); dl: (Len: 8)),
    (fc: (Frequency: 217); dl: (Len: 8)), (fc: (Frequency: 57); dl: (Len: 8)),
    (fc: (Frequency: 185); dl: (Len: 8)), (fc: (Frequency: 121);
      dl: (Len: 8)), (fc: (Frequency: 249); dl: (Len: 8)),
    (fc: (Frequency: 5); dl: (Len: 8)), (fc: (Frequency: 133); dl: (Len: 8)),
    (fc: (Frequency: 69); dl: (Len: 8)), (fc: (Frequency: 197); dl: (Len: 8)),
    (fc: (Frequency: 37); dl: (Len: 8)), (fc: (Frequency: 165); dl: (Len: 8)),
    (fc: (Frequency: 101); dl: (Len: 8)), (fc: (Frequency: 229);
      dl: (Len: 8)), (fc: (Frequency: 21); dl: (Len: 8)),
    (fc: (Frequency: 149); dl: (Len: 8)), (fc: (Frequency: 85); dl: (Len: 8)),
    (fc: (Frequency: 213); dl: (Len: 8)), (fc: (Frequency: 53); dl: (Len: 8)),
    (fc: (Frequency: 181); dl: (Len: 8)), (fc: (Frequency: 117);
      dl: (Len: 8)), (fc: (Frequency: 245); dl: (Len: 8)),
    (fc: (Frequency: 13); dl: (Len: 8)), (fc: (Frequency: 141); dl: (Len: 8)),
    (fc: (Frequency: 77); dl: (Len: 8)), (fc: (Frequency: 205); dl: (Len: 8)),
    (fc: (Frequency: 45); dl: (Len: 8)), (fc: (Frequency: 173); dl: (Len: 8)),
    (fc: (Frequency: 109); dl: (Len: 8)), (fc: (Frequency: 237); dl: (Len: 8)),
    (fc: (Frequency: 29); dl: (Len: 8)), (fc: (Frequency: 157); dl: (Len: 8)),
    (fc: (Frequency: 93); dl: (Len: 8)), (fc: (Frequency: 221); dl: (Len: 8)),
    (fc: (Frequency: 61); dl: (Len: 8)), (fc: (Frequency: 189); dl: (Len: 8)),
    (fc: (Frequency: 125); dl: (Len: 8)), (fc: (Frequency: 253);
      dl: (Len: 8)), (fc: (Frequency: 19); dl: (Len: 9)),
    (fc: (Frequency: 275); dl: (Len: 9)), (fc: (Frequency: 147);
      dl: (Len: 9)), (fc: (Frequency: 403); dl: (Len: 9)),
    (fc: (Frequency: 83); dl: (Len: 9)), (fc: (Frequency: 339); dl: (Len: 9)),
    (fc: (Frequency: 211); dl: (Len: 9)), (fc: (Frequency: 467); dl: (Len: 9)),
    (fc: (Frequency: 51); dl: (Len: 9)), (fc: (Frequency: 307); dl: (Len: 9)),
    (fc: (Frequency: 179); dl: (Len: 9)), (fc: (Frequency: 435);
      dl: (Len: 9)), (fc: (Frequency: 115); dl: (Len: 9)),
    (fc: (Frequency: 371); dl: (Len: 9)), (fc: (Frequency: 243);
      dl: (Len: 9)), (fc: (Frequency: 499); dl: (Len: 9)),
    (fc: (Frequency: 11); dl: (Len: 9)), (fc: (Frequency: 267); dl: (Len: 9)),
    (fc: (Frequency: 139); dl: (Len: 9)), (fc: (Frequency: 395); dl: (Len: 9)),
    (fc: (Frequency: 75); dl: (Len: 9)), (fc: (Frequency: 331); dl: (Len: 9)),
    (fc: (Frequency: 203); dl: (Len: 9)), (fc: (Frequency: 459);
      dl: (Len: 9)), (fc: (Frequency: 43); dl: (Len: 9)),
    (fc: (Frequency: 299); dl: (Len: 9)), (fc: (Frequency: 171);
      dl: (Len: 9)), (fc: (Frequency: 427); dl: (Len: 9)),
    (fc: (Frequency: 107); dl: (Len: 9)), (fc: (Frequency: 363);
      dl: (Len: 9)), (fc: (Frequency: 235); dl: (Len: 9)),
    (fc: (Frequency: 491); dl: (Len: 9)), (fc: (Frequency: 27);
      dl: (Len: 9)), (fc: (Frequency: 283); dl: (Len: 9)),
    (fc: (Frequency: 155); dl: (Len: 9)), (fc: (Frequency: 411);
      dl: (Len: 9)), (fc: (Frequency: 91); dl: (Len: 9)),
    (fc: (Frequency: 347); dl: (Len: 9)), (fc: (Frequency: 219);
      dl: (Len: 9)), (fc: (Frequency: 475); dl: (Len: 9)),
    (fc: (Frequency: 59); dl: (Len: 9)), (fc: (Frequency: 315); dl: (Len: 9)),
    (fc: (Frequency: 187); dl: (Len: 9)), (fc: (Frequency: 443); dl: (Len: 9)),
    (fc: (Frequency: 123); dl: (Len: 9)), (fc: (Frequency: 379); dl: (Len: 9)),
    (fc: (Frequency: 251); dl: (Len: 9)), (fc: (Frequency: 507); dl: (Len: 9)),
    (fc: (Frequency: 7); dl: (Len: 9)), (fc: (Frequency: 263); dl: (Len: 9)),
    (fc: (Frequency: 135); dl: (Len: 9)), (fc: (Frequency: 391);
      dl: (Len: 9)), (fc: (Frequency: 71); dl: (Len: 9)),
    (fc: (Frequency: 327); dl: (Len: 9)), (fc: (Frequency: 199);
      dl: (Len: 9)), (fc: (Frequency: 455); dl: (Len: 9)),
    (fc: (Frequency: 39); dl: (Len: 9)), (fc: (Frequency: 295); dl: (Len: 9)),
    (fc: (Frequency: 167); dl: (Len: 9)), (fc: (Frequency: 423); dl: (Len: 9)),
    (fc: (Frequency: 103); dl: (Len: 9)), (fc: (Frequency: 359); dl: (Len: 9)),
    (fc: (Frequency: 231); dl: (Len: 9)), (fc: (Frequency: 487); dl: (Len: 9)),
    (fc: (Frequency: 23); dl: (Len: 9)), (fc: (Frequency: 279); dl: (Len: 9)),
    (fc: (Frequency: 151); dl: (Len: 9)), (fc: (Frequency: 407);
      dl: (Len: 9)), (fc: (Frequency: 87); dl: (Len: 9)),
    (fc: (Frequency: 343); dl: (Len: 9)), (fc: (Frequency: 215);
      dl: (Len: 9)), (fc: (Frequency: 471); dl: (Len: 9)),
    (fc: (Frequency: 55); dl: (Len: 9)), (fc: (Frequency: 311); dl: (Len: 9)),
    (fc: (Frequency: 183); dl: (Len: 9)), (fc: (Frequency: 439); dl: (Len: 9)),
    (fc: (Frequency: 119); dl: (Len: 9)), (fc: (Frequency: 375); dl: (Len: 9)),
    (fc: (Frequency: 247); dl: (Len: 9)), (fc: (Frequency: 503); dl: (Len: 9)),
    (fc: (Frequency: 15); dl: (Len: 9)), (fc: (Frequency: 271); dl: (Len: 9)),
    (fc: (Frequency: 143); dl: (Len: 9)), (fc: (Frequency: 399);
      dl: (Len: 9)), (fc: (Frequency: 79); dl: (Len: 9)),
    (fc: (Frequency: 335); dl: (Len: 9)), (fc: (Frequency: 207);
      dl: (Len: 9)), (fc: (Frequency: 463); dl: (Len: 9)),
    (fc: (Frequency: 47); dl: (Len: 9)), (fc: (Frequency: 303); dl: (Len: 9)),
    (fc: (Frequency: 175); dl: (Len: 9)), (fc: (Frequency: 431); dl: (Len: 9)),
    (fc: (Frequency: 111); dl: (Len: 9)), (fc: (Frequency: 367); dl: (Len: 9)),
    (fc: (Frequency: 239); dl: (Len: 9)), (fc: (Frequency: 495); dl: (Len: 9)),
    (fc: (Frequency: 31); dl: (Len: 9)), (fc: (Frequency: 287); dl: (Len: 9)),
    (fc: (Frequency: 159); dl: (Len: 9)), (fc: (Frequency: 415);
      dl: (Len: 9)), (fc: (Frequency: 95); dl: (Len: 9)),
    (fc: (Frequency: 351); dl: (Len: 9)), (fc: (Frequency: 223);
      dl: (Len: 9)), (fc: (Frequency: 479); dl: (Len: 9)),
    (fc: (Frequency: 63); dl: (Len: 9)), (fc: (Frequency: 319); dl: (Len: 9)),
    (fc: (Frequency: 191); dl: (Len: 9)), (fc: (Frequency: 447); dl: (Len: 9)),
    (fc: (Frequency: 127); dl: (Len: 9)), (fc: (Frequency: 383); dl: (Len: 9)),
    (fc: (Frequency: 255); dl: (Len: 9)), (fc: (Frequency: 511); dl: (Len: 9)),
    (fc: (Frequency: 0); dl: (Len: 7)), (fc: (Frequency: 64); dl: (Len: 7)),
    (fc: (Frequency: 32); dl: (Len: 7)), (fc: (Frequency: 96); dl: (Len: 7)),
    (fc: (Frequency: 16); dl: (Len: 7)), (fc: (Frequency: 80); dl: (Len: 7)),
    (fc: (Frequency: 48); dl: (Len: 7)), (fc: (Frequency: 112); dl: (Len: 7)),
    (fc: (Frequency: 8); dl: (Len: 7)), (fc: (Frequency: 72); dl: (Len: 7)),
    (fc: (Frequency: 40); dl: (Len: 7)), (fc: (Frequency: 104);
      dl: (Len: 7)), (fc: (Frequency: 24); dl: (Len: 7)),
    (fc: (Frequency: 88); dl: (Len: 7)), (fc: (Frequency: 56); dl: (Len: 7)),
    (fc: (Frequency: 120); dl: (Len: 7)), (fc: (Frequency: 4); dl: (Len: 7)),
    (fc: (Frequency: 68); dl: (Len: 7)), (fc: (Frequency: 36); dl: (Len: 7)),
    (fc: (Frequency: 100); dl: (Len: 7)), (fc: (Frequency: 20); dl: (Len: 7)),
    (fc: (Frequency: 84); dl: (Len: 7)), (fc: (Frequency: 52); dl: (Len: 7)),
    (fc: (Frequency: 116); dl: (Len: 7)), (fc: (Frequency: 3); dl: (Len: 8)),
    (fc: (Frequency: 131); dl: (Len: 8)), (fc: (Frequency: 67); dl: (Len: 8)),
    (fc: (Frequency: 195); dl: (Len: 8)), (fc: (Frequency: 35); dl: (Len: 8)),
    (fc: (Frequency: 163); dl: (Len: 8)), (fc: (Frequency: 99); dl: (Len: 8)),
    (fc: (Frequency: 227); dl: (Len: 8)));

  // The static distance tree. (Actually a trivial tree since all lens use 5 Bits.)
  StaticDescriptorTree: array [0 .. D_CODES - 1] of TTreeEntry =
    ((fc: (Frequency: 0); dl: (Len: 5)), (fc: (Frequency: 16); dl: (Len: 5)),
    (fc: (Frequency: 8); dl: (Len: 5)), (fc: (Frequency: 24); dl: (Len: 5)),
    (fc: (Frequency: 4); dl: (Len: 5)), (fc: (Frequency: 20); dl: (Len: 5)),
    (fc: (Frequency: 12); dl: (Len: 5)), (fc: (Frequency: 28); dl: (Len: 5)),
    (fc: (Frequency: 2); dl: (Len: 5)), (fc: (Frequency: 18); dl: (Len: 5)),
    (fc: (Frequency: 10); dl: (Len: 5)), (fc: (Frequency: 26); dl: (Len: 5)),
    (fc: (Frequency: 6); dl: (Len: 5)), (fc: (Frequency: 22); dl: (Len: 5)),
    (fc: (Frequency: 14); dl: (Len: 5)), (fc: (Frequency: 30); dl: (Len: 5)),
    (fc: (Frequency: 1); dl: (Len: 5)), (fc: (Frequency: 17); dl: (Len: 5)),
    (fc: (Frequency: 9); dl: (Len: 5)), (fc: (Frequency: 25); dl: (Len: 5)),
    (fc: (Frequency: 5); dl: (Len: 5)), (fc: (Frequency: 21); dl: (Len: 5)),
    (fc: (Frequency: 13); dl: (Len: 5)), (fc: (Frequency: 29); dl: (Len: 5)),
    (fc: (Frequency: 3); dl: (Len: 5)), (fc: (Frequency: 19); dl: (Len: 5)),
    (fc: (Frequency: 11); dl: (Len: 5)), (fc: (Frequency: 27); dl: (Len: 5)),
    (fc: (Frequency: 7); dl: (Len: 5)), (fc: (Frequency: 23); dl: (Len: 5)));

  // Distance codes. The first 256 values correspond to the distances 3 .. 258, the last 256 values correspond to the
  // top 8 Bits of the 15 bit distances.
  DistanceCode: array [0 .. DIST_CODE_LEN - 1] of byte = (0, 1, 2, 3, 4, 4, 5,
    5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17,
    18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
    22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
    26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
    26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
    27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29);

  // length code for each normalized match length (0 = MIN_MATCH)
  LengthCode: array [0 .. MAX_MATCH - MIN_MATCH] of byte = (0, 1, 2, 3, 4, 5,
    6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14,
    14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17,
    17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21,
    21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23,
    23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26,
    26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
    26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
    27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
    27, 28);

  // first normalized length for each code (0 = MIN_MATCH)
  BaseLength: array [0 .. LENGTH_CODES - 1] of byte = (0, 1, 2, 3, 4, 5, 6, 7,
    8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160,
    192, 224, 0);

  // first normalized distance for each code (0 = distance of 1)
  BaseDistance: array [0 .. D_CODES - 1] of Integer = (0, 1, 2, 3, 4, 6, 8, 12,
    16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048,
    3072, 4096, 6144, 8192, 12288, 16384, 24576);

  MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);
  MAX_BL_BITS = 7; // bit length codes must not exceed MAX_BL_BITS bits
  END_BLOCK = 256; // end of block literal code
  REP_3_6 = 16; // repeat previous bit length 3-6 times (2 Bits of repeat count)
  REPZ_3_10 = 17; // repeat a zero length 3-10 times  (3 Bits of repeat count)
  REPZ_11_138 = 18; // repeat a zero length 11-138 times  (7 Bits of repeat count)

  // extra bits for each length code
  ExtraLengthBits: array [0 .. LENGTH_CODES - 1] of Integer = (0, 0, 0, 0, 0,
    0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0);

  // extra bits for each distance code
  ExtraDistanceBits: array [0 .. D_CODES - 1] of Integer = (0, 0, 0, 0, 1, 1,
    2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12,
    13, 13);

  // extra bits for each bit length code
  ExtraBitLengthBits: array [0 .. BL_CODES - 1] of Integer = (0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7);

  // The lengths of the bit length codes are sent in order of decreasing probability,
  // to avoid transmitting the lengths for unused bit length codes.
  BitLengthOrder: array [0 .. BL_CODES - 1] of byte = (16, 17, 18, 0, 8, 7, 9,
    6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15);

  // Number of bits used within BitsBuffer. (BitsBuffer might be implemented on more than 16 bits on some systems.)
  BufferSize = 16;

  StaticLiteralDescriptor: TStaticTreeDescriptor =
    (StaticTree: @StaticLiteralTree; // Pointer to array of TTreeEntry
    ExtraBits: @ExtraLengthBits; // Pointer to array of Integer
    ExtraBase: LITERALS + 1; Elements: L_CODES; MaxLength: MAX_BITS);

  StaticDistanceDescriptor: TStaticTreeDescriptor =
    (StaticTree: @StaticDescriptorTree; ExtraBits: @ExtraDistanceBits;
    ExtraBase: 0; Elements: D_CODES; MaxLength: MAX_BITS);

  StaticBitLengthDescriptor: TStaticTreeDescriptor = (StaticTree: nil;
    ExtraBits: @ExtraBitLengthBits; ExtraBase: 0; Elements: BL_CODES;
    MaxLength: MAX_BL_BITS);

  // ----------------- Inflate support

const
  InflateMask: array [0 .. 16] of cardinal = ($0000, $0001, $0003, $0007,
    $000F, $001F, $003F, $007F, $00FF, $01FF, $03FF, $07FF, $0FFF, $1FFF,
    $3FFF, $7FFF, $FFFF);

function InflateFlush(var S: TInflateBlocksState; var Z: TZState;
  R: Integer): Integer;
// copies as much as possible from the sliding window to the output area
var
  N: cardinal;
  P: PByte;
  Q: PByte;
begin
  // local copies of source and destination pointers
  P := Z.NextOutput;
  Q := S.Read;

  // compute number of bytes to copy as far as end of window
  if cardinal(Q) <= cardinal(S.Write) then
    N := cardinal(S.Write) - cardinal(Q)
  else
    N := cardinal(S.zend) - cardinal(Q);
  if N > Z.AvailableOutput then
    N := Z.AvailableOutput;
  if (N <> 0) and (R = Z_BUF_ERROR) then
    R := Z_OK;

  // update counters
  dec(Z.AvailableOutput, N);
  inc(Z.TotalOutput, N);

  // copy as far as end of Window
  Move(Q^, P^, N);
  inc(P, N);
  inc(Q, N);

  // see if more to copy at beginning of window
  if Q = S.zend then
  begin
    // wrap pointers
    Q := S.window;
    if S.write = S.zend then
      S.write := S.window;
    // compute bytes to copy
    N := cardinal(S.write) - cardinal(Q);
    if N > Z.AvailableOutput then
      N := Z.AvailableOutput;
    if (N <> 0) and (R = Z_BUF_ERROR) then
      R := Z_OK;
    // update counters
    dec(Z.AvailableOutput, N);
    inc(Z.TotalOutput, N);
    // copy
    Move(Q^, P^, N);
    inc(P, N);
    inc(Q, N);
  end;

  // update pointers
  Z.NextOutput := P;
  S.Read := Q;

  Result := R;
end;

function InflateFast(LiteralBits, DistanceBits: cardinal; TL, TD: PInflateHuft;
  var S: TInflateBlocksState; var Z: TZState): Integer;
// Called with number of bytes left to write in window at least 258 (the maximum String length) and number of input
// bytes available at least ten. The ten bytes are six bytes for the longest length/distance pair plus four bytes for
// overloading the bit buffer.
var
  Temp: PInflateHuft;
  Extra: cardinal; // extra bits or operation
  BitsBuffer: cardinal;
  K: cardinal; // bits in bit buffer
  P: PByte; // input data Pointer
  N: cardinal; // bytes available there
  Q: PByte; // output window write Pointer
  M: cardinal; // bytes to end of window or read Pointer
  ml: cardinal; // mask for literal/length tree
  md: cardinal; // mask for distance tree
  C: cardinal; // bytes to copy
  D: cardinal; // distance back to copy from
  R: PByte; // copy source Pointer
begin
  // load input, output, bit values
  P := Z.NextInput;
  N := Z.AvailableInput;
  BitsBuffer := S.bitb;
  K := S.bitk;
  Q := S.write;
  if cardinal(Q) < cardinal(S.Read) then
    M := cardinal(S.read) - cardinal(Q) - 1
  else
    M := cardinal(S.zend) - cardinal(Q);
  // initialize masks
  ml := InflateMask[LiteralBits];
  md := InflateMask[DistanceBits];

  // do until not enough input or output space for fast loop,
  // assume called with (M >= 258) and (N >= 10)
  repeat
    // get literal/length Code
    while K < 20 do
    begin
      dec(N);
      BitsBuffer := BitsBuffer or (cardinal(P^) shl K);
      inc(K, 8);
      inc(P);
    end;

    Temp := @PHuftField(TL)[BitsBuffer and ml];

    Extra := Temp.Exop;
    if Extra = 0 then
    begin
      BitsBuffer := BitsBuffer shr Temp.Bits;
      dec(K, Temp.Bits);
      Q^ := Temp.Base;
      inc(Q);
      dec(M);
      if (M >= 258) and (N >= 10) then
        continue
      else
        break;
    end;

    repeat
      BitsBuffer := BitsBuffer shr Temp.Bits;
      dec(K, Temp.Bits);

      if (Extra and 16) <> 0 then
      begin
        // get extra bits for length
        Extra := Extra and 15;
        C := Temp.Base + (BitsBuffer and InflateMask[Extra]);
        BitsBuffer := BitsBuffer shr Extra;
        dec(K, Extra);
        // decode distance base of block to copy
        while K < 15 do
        begin
          dec(N);
          BitsBuffer := BitsBuffer or (cardinal(P^) shl K);
          inc(P);
          inc(K, 8);
        end;

        Temp := @PHuftField(TD)[BitsBuffer and md];
        Extra := Temp.Exop;
        repeat
          BitsBuffer := BitsBuffer shr Temp.Bits;
          dec(K, Temp.Bits);
          if (Extra and 16) <> 0 then
          begin
            // get extra bits to add to distance base
            Extra := Extra and 15;
            while K < Extra do
            begin
              dec(N);
              BitsBuffer := BitsBuffer or (cardinal(P^) shl K);
              inc(P);
              inc(K, 8);
            end;
            D := Temp.Base + (BitsBuffer and InflateMask[Extra]);
            BitsBuffer := BitsBuffer shr Extra;
            dec(K, Extra);
            // do the copy
            dec(M, C);
            // offset before Dest
            if (cardinal(Q) - cardinal(S.window)) >= D then
            begin
              // copy without extra
              R := Q;
              dec(R, D);
            end
            else
            begin
              // offset after destination,
              // bytes from offset to end
              Extra := D - (cardinal(Q) - cardinal(S.window));
              R := S.zend;
              // Pointer to offset
              dec(R, Extra);
              if C > Extra then
              begin
                // copy to end of window
                dec(C, Extra);
                MoveWithOverlap(R, Q, Extra);
 {?? R wird 2 Zeilen weiter berschrieben}             //  inc(R, Extra);
                inc(Q, Extra);
                // copy rest from start of window
                R := S.window;
              end;
            end;
            // copy all or what's left
            Extra := C; // optimize generated code
            MoveWithOverlap(R, Q, Extra);
            inc(R, Extra);
            inc(Q, Extra);
            break;
          end
          else if (Extra and 64) = 0 then
          begin
            inc(Temp, Temp.Base + (BitsBuffer and InflateMask[Extra]));
            Extra := Temp.Exop;
          end
          else
          begin
            C := Z.AvailableInput - N;
            if (K shr 3) < C then
              C := K shr 3;
            inc(N, C);
            dec(P, C);
            dec(K, C shl 3);
            S.bitb := BitsBuffer;
            S.bitk := K;
            Z.AvailableInput := N;
            inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
            Z.NextInput := P;
            S.write := Q;
            Result := Z_DATA_ERROR;
            Exit;
          end;
        until false;
        break;
      end;

      if (Extra and 64) = 0 then
      begin
        inc(Temp, Temp.Base + (BitsBuffer and InflateMask[Extra]));
        Extra := Temp.Exop;
        if Extra = 0 then
        begin
          BitsBuffer := BitsBuffer shr Temp.Bits;
          dec(K, Temp.Bits);
          Q^ := Temp.Base;
          inc(Q);
          dec(M);
          break;
        end;
      end
      else if (Extra and 32) <> 0 then
      begin
        C := Z.AvailableInput - N;
        if (K shr 3) < C then
          C := K shr 3;
        inc(N, C);
        dec(P, C);
        dec(K, C shl 3);
        S.bitb := BitsBuffer;
        S.bitk := K;
        Z.AvailableInput := N;
        inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
        Z.NextInput := P;
        S.write := Q;
        Result := Z_STREAM_END;
        Exit;
      end
      else
      begin
        C := Z.AvailableInput - N;
        if (K shr 3) < C then
          C := K shr 3;
        inc(N, C);
        dec(P, C);
        dec(K, C shl 3);
        S.bitb := BitsBuffer;
        S.bitk := K;
        Z.AvailableInput := N;
        inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
        Z.NextInput := P;
        S.write := Q;
        Result := Z_DATA_ERROR;
        Exit;
      end;
    until false;
    if (M < 258) or (N < 10) then
      break;
  until false;

  // not enough input or output -> restore pointers and return
  C := Z.AvailableInput - N;
  if (K shr 3) < C then
    C := K shr 3;
  inc(N, C);
  dec(P, C);
  dec(K, C shl 3);
  S.bitb := BitsBuffer;
  S.bitk := K;
  Z.AvailableInput := N;
  inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
  Z.NextInput := P;
  S.write := Q;
  Result := Z_OK;
end;

function InflateCodesNew(LiteralBits: cardinal; DistanceBits: cardinal;
  TL, TD: PInflateHuft; var Z: TZState): PInflateCodesState;
begin
  GetMem(Result, SizeOf(TInflateCodesState));
  Result.Mode := icmStart;
  Result.LiteralTreeBits := LiteralBits;
  Result.DistanceTreeBits := DistanceBits;
  Result.LiteralTree := TL;
  Result.DistanceTree := TD;
end;

function InflateCodes(var S: TInflateBlocksState; var Z: TZState;
  R: Integer): Integer;
var
  J: cardinal; // temporary storage
  Temp: PInflateHuft;
  Extra: cardinal; // extra bits or operation
  BitsBuffer: cardinal;
  K: cardinal; // bits in bit buffer
  P: PByte; // input data Pointer
  N: cardinal; // bytes available there
  Q: PByte; // output window write Pointer
  M: cardinal; // bytes to end of window or read Pointer
  F: PByte; // Pointer to copy strings from
  C: PInflateCodesState;
begin
  C := S.sub.decode.codes; // codes state

  // copy input/output information to locals
  P := Z.NextInput;
  N := Z.AvailableInput;
  BitsBuffer := S.bitb;
  K := S.bitk;
  Q := S.write;
  if cardinal(Q) < cardinal(S.read) then
    M := cardinal(S.read) - cardinal(Q) - 1
  else
    M := cardinal(S.zend) - cardinal(Q);

  // process input and output based on current state
  while true do
  begin
    case C.Mode of
      icmStart:
        begin
          if (M >= 258) and (N >= 10) then
          begin
            S.bitb := BitsBuffer;
            S.bitk := K;
            Z.AvailableInput := N;
            inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
            Z.NextInput := P;
            S.write := Q;

            R := InflateFast(C.LiteralTreeBits, C.DistanceTreeBits,
              C.LiteralTree, C.DistanceTree, S, Z);
            P := Z.NextInput;
            N := Z.AvailableInput;
            BitsBuffer := S.bitb;
            K := S.bitk;
            Q := S.write;
            if cardinal(Q) < cardinal(S.read) then
              M := cardinal(S.read) - cardinal(Q) - 1
            else
              M := cardinal(S.zend) - cardinal(Q);
            if R <> Z_OK then
            begin
              if R = Z_STREAM_END then
                C.Mode := icmWash
              else
                C.Mode := icmBadCode;
              continue;
            end;
          end;
          C.sub.Code.need := C.LiteralTreeBits;
          C.sub.Code.Tree := C.LiteralTree;
          C.Mode := icmLen;
        end;
      icmLen: // I: get length/literal/eob next
        begin
          J := C.sub.Code.need;
          while K < J do
          begin
            if N <> 0 then
              R := Z_OK
            else
            begin
              S.bitb := BitsBuffer;
              S.bitk := K;
              Z.AvailableInput := N;
              inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
              Z.NextInput := P;
              S.write := Q;
              Result := InflateFlush(S, Z, R);
              Exit;
            end;
            dec(N);
            BitsBuffer := BitsBuffer or (cardinal(P^) shl K);
            inc(P);
            inc(K, 8);
          end;
          Temp := C.sub.Code.Tree;
          inc(Temp, cardinal(BitsBuffer) and InflateMask[J]);
          BitsBuffer := BitsBuffer shr Temp.Bits;
          dec(K, Temp.Bits);

          Extra := Temp.Exop;
          // literal
          if Extra = 0 then
          begin
            C.sub.lit := Temp.Base;
            C.Mode := icmLit;
            continue;
          end;
          // length
          if (Extra and 16) <> 0 then
          begin
            C.sub.copy.get := Extra and 15;
            C.Len := Temp.Base;
            C.Mode := icmLenNext;
            continue;
          end;
          // next table
          if (Extra and 64) = 0 then
          begin
            C.sub.Code.need := Extra;
            C.sub.Code.Tree := @PHuftField(Temp)[Temp.Base];
            continue;
          end;
          // end of block
          if (Extra and 32) <> 0 then
          begin
            C.Mode := icmWash;
            continue;
          end;
          // invalid code
          C.Mode := icmBadCode;
          R := Z_DATA_ERROR;
          S.bitb := BitsBuffer;
          S.bitk := K;
          Z.AvailableInput := N;
          inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
          Z.NextInput := P;
          S.write := Q;
          Result := InflateFlush(S, Z, R);
          Exit;
        end;
      icmLenNext: // I: getting length extra (have base)
        begin
          J := C.sub.copy.get;
          while K < J do
          begin
            if N <> 0 then
              R := Z_OK
            else
            begin
              S.bitb := BitsBuffer;
              S.bitk := K;
              Z.AvailableInput := N;
              inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
              Z.NextInput := P;
              S.write := Q;
              Result := InflateFlush(S, Z, R);
              Exit;
            end;
            dec(N);
            BitsBuffer := BitsBuffer or (cardinal(P^) shl K);
            inc(P);
            inc(K, 8);
          end;
          inc(C.Len, cardinal(BitsBuffer and InflateMask[J]));
          BitsBuffer := BitsBuffer shr J;
          dec(K, J);
          C.sub.Code.need := C.DistanceTreeBits;
          C.sub.Code.Tree := C.DistanceTree;
          C.Mode := icmDistance;
        end;
      icmDistance: // I: get distance next
        begin
          J := C.sub.Code.need;
          while K < J do
          begin
            if N <> 0 then
              R := Z_OK
            else
            begin
              S.bitb := BitsBuffer;
              S.bitk := K;
              Z.AvailableInput := N;
              inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
              Z.NextInput := P;
              S.write := Q;
              Result := InflateFlush(S, Z, R);
              Exit;
            end;
            dec(N);
            BitsBuffer := BitsBuffer or (cardinal(P^) shl K);
            inc(P);
            inc(K, 8);
          end;
          Temp := @PHuftField(C.sub.Code.Tree)[BitsBuffer and InflateMask[J]];
          BitsBuffer := BitsBuffer shr Temp.Bits;
          dec(K, Temp.Bits);

          Extra := Temp.Exop;
          // distance
          if (Extra and 16) <> 0 then
          begin
            C.sub.copy.get := Extra and 15;
            C.sub.copy.Distance := Temp.Base;
            C.Mode := icmDistExt;
            continue;
          end;
          // next table
          if (Extra and 64) = 0 then
          begin
            C.sub.Code.need := Extra;
            C.sub.Code.Tree := @PHuftField(Temp)[Temp.Base];
            continue;
          end;
          // invalid code
          C.Mode := icmBadCode;
          R := Z_DATA_ERROR;
          S.bitb := BitsBuffer;
          S.bitk := K;
          Z.AvailableInput := N;
          inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
          Z.NextInput := P;
          S.write := Q;
          Result := InflateFlush(S, Z, R);
          Exit;
        end;
      icmDistExt: // I: getting distance extra
        begin
          J := C.sub.copy.get;
          while K < J do
          begin
            if N <> 0 then
              R := Z_OK
            else
            begin
              S.bitb := BitsBuffer;
              S.bitk := K;
              Z.AvailableInput := N;
              inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
              Z.NextInput := P;
              S.write := Q;
              Result := InflateFlush(S, Z, R);
              Exit;
            end;
            dec(N);
            BitsBuffer := BitsBuffer or (cardinal(P^) shl K);
            inc(P);
            inc(K, 8);
          end;
          inc(C.sub.copy.Distance, cardinal(BitsBuffer) and InflateMask[J]);
          BitsBuffer := BitsBuffer shr J;
          dec(K, J);
          C.Mode := icmCopy;
        end;
      icmCopy: // O: copying bytes in window, waiting for space
        begin
          F := Q;
          dec(F, C.sub.copy.Distance);
          if (cardinal(Q) - cardinal(S.window)) < C.sub.copy.Distance then
          begin
            F := S.zend;
            dec(F, C.sub.copy.Distance - (cardinal(Q) - cardinal(S.window)));
          end;

          while C.Len <> 0 do
          begin
            if M = 0 then
            begin
              if (Q = S.zend) and (S.read <> S.window) then
              begin
                Q := S.window;
                if cardinal(Q) < cardinal(S.read) then
                  M := cardinal(S.read) - cardinal(Q) - 1
                else
                  M := cardinal(S.zend) - cardinal(Q);
              end;
              if M = 0 then
              begin
                S.write := Q;
                R := InflateFlush(S, Z, R);
                Q := S.write;
                if cardinal(Q) < cardinal(S.read) then
                  M := cardinal(S.read) - cardinal(Q) - 1
                else
                  M := cardinal(S.zend) - cardinal(Q);
                if (Q = S.zend) and (S.read <> S.window) then
                begin
                  Q := S.window;
                  if cardinal(Q) < cardinal(S.read) then
                    M := cardinal(S.read) - cardinal(Q) - 1
                  else
                    M := cardinal(S.zend) - cardinal(Q);
                end;
                if M = 0 then
                begin
                  S.bitb := BitsBuffer;
                  S.bitk := K;
                  Z.AvailableInput := N;
                  inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
                  Z.NextInput := P;
                  S.write := Q;
                  Result := InflateFlush(S, Z, R);
                  Exit;
                end;
              end;
            end;
            R := Z_OK;

            Q^ := F^;
            inc(Q);
            inc(F);
            dec(M);

            if (F = S.zend) then
              F := S.window;
            dec(C.Len);
          end;
          C.Mode := icmStart;
        end;
      icmLit: // O: got literal, waiting for output space
        begin
          if M = 0 then
          begin
            if (Q = S.zend) and (S.read <> S.window) then
            begin
              Q := S.window;
              if cardinal(Q) < cardinal(S.read) then
                M := cardinal(S.read) - cardinal(Q) - 1
              else
                M := cardinal(S.zend) - cardinal(Q);
            end;
            if M = 0 then
            begin
              S.write := Q;
              R := InflateFlush(S, Z, R);
              Q := S.write;
              if cardinal(Q) < cardinal(S.read) then
                M := cardinal(S.read) - cardinal(Q) - 1
              else
                M := cardinal(S.zend) - cardinal(Q);
              if (Q = S.zend) and (S.read <> S.window) then
              begin
                Q := S.window;
                if cardinal(Q) < cardinal(S.read) then
                  M := cardinal(S.read) - cardinal(Q) - 1
                else
                  M := cardinal(S.zend) - cardinal(Q);
              end;
              if M = 0 then
              begin
                S.bitb := BitsBuffer;
                S.bitk := K;
                Z.AvailableInput := N;
                inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
                Z.NextInput := P;
                S.write := Q;
                Result := InflateFlush(S, Z, R);
                Exit;
              end;
            end;
          end;
          R := Z_OK;
          Q^ := C.sub.lit;
          inc(Q);
          dec(M);
          C.Mode := icmStart;
        end;
      icmWash: // O: got eob, possibly More output
        begin
          // return unused byte, if any
          if K > 7 then
          begin
            dec(K, 8);
            inc(N);
            dec(P);
            // can always return one
          end;
          S.write := Q;
          R := InflateFlush(S, Z, R);
          Q := S.write;
          if cardinal(Q) < cardinal(S.read) then
            M := cardinal(S.read) - cardinal(Q) - 1
          else
            M := cardinal(S.zend) - cardinal(Q);
          if S.read <> S.write then
          begin
            S.bitb := BitsBuffer;
            S.bitk := K;
            Z.AvailableInput := N;
            inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
            Z.NextInput := P;
            S.write := Q;
            Result := InflateFlush(S, Z, R);
            Exit;
          end;
          C.Mode := icmZEnd;
        end;
      icmZEnd:
        begin
          R := Z_STREAM_END;
          S.bitb := BitsBuffer;
          S.bitk := K;
          Z.AvailableInput := N;
          inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
          Z.NextInput := P;
          S.write := Q;
          Result := InflateFlush(S, Z, R);
          Exit;
        end;
      icmBadCode: // X: got error
        begin
          R := Z_DATA_ERROR;
          S.bitb := BitsBuffer;
          S.bitk := K;
          Z.AvailableInput := N;
          inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
          Z.NextInput := P;
          S.write := Q;
          Result := InflateFlush(S, Z, R);
          Exit;
        end;
    else

      begin
        R := Z_STREAM_ERROR;
        S.bitb := BitsBuffer;
        S.bitk := K;
        Z.AvailableInput := N;
        inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
        Z.NextInput := P;
        S.write := Q;
        Result := InflateFlush(S, Z, R);
        Exit;
      end;
    end;
  end;

  Result := Z_STREAM_ERROR;
end;

const
  // Maximum Size of dynamic tree. The maximum found in an Integer but non-exhaustive search was 1004 huft structures
  // (850 for length/literals and 154 for distances, the latter actually the result of an exhaustive search).
  // The actual maximum is not known, but the value below is more than safe.
  MANY = 1440;

  // Tables for deflate from PKZIP'S appnote.txt
  // copy lengths for literal codes 257..285 (actually lengths - 2; also see note #13 above about 258)
  CopyLengths: array [0 .. 30] of cardinal = (3, 4, 5, 6, 7, 8, 9, 10, 11, 13,
    15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195,
    227, 258, 0, 0);

  INVALID_CODE = 112;
  // extra bits for literal codes 257..285
  CopyLiteralExtra: array [0 .. 30] of cardinal = (0, 0, 0, 0, 0, 0, 0, 0, 1,
    1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, INVALID_CODE,
    INVALID_CODE);

  // copy offsets for distance codes 0..29
  CopyOffsets: array [0 .. 29] of cardinal = (1, 2, 3, 4, 5, 7, 9, 13, 17, 25,
    33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097,
    6145, 8193, 12289, 16385, 24577);

  // extra bits for distance codes
  CopyExtra: array [0 .. 29] of cardinal = (0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4,
    5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13);

  // Huffman code decoding is performed using a multi-Level table lookup.
  // Fastest way to decode is to simply build a lookup table whose
  // Size is determined by the longest code. However, the time it takes
  // to build this table can also be a factor if the data being decoded
  // is not very Integer. The most common codes are necessarily the
  // shortest codes so those codes dominate the decoding time and hence
  // the speed. The idea is you can have a shorter table that decodes the
  // shorter, More probable codes, and then point to subsidiary tables for
  // the longer codes. The time it costs to decode the longer codes is
  // then traded against the time it takes to make longer tables.
  //
  // This results of this trade are in the variables LiteralTreeBits and DistanceTreeBits
  // below. LiteralTreeBits is the number of bits the first level table for literal/
  // length codes can decode in one step, and DistanceTreeBits is the same thing for
  // the distance codes. Subsequent tables are also less than or equal to those sizes.
  // These values may be adjusted either when all of the
  // codes are shorter than that, in which case the longest code length in
  // bits is used, or when the shortest code is *longer* than the requested
  // table Size, in which case the length of the shortest code in bits is used.
  //
  // There are two different values for the two tables, since they code a
  // different number of possibilities each. The literal/length table
  // codes 286 possible values, or in a flat code, a little over eight
  // bits. The distance table codes 30 possible values, or a little less
  // than five bits, flat. The optimum values for speed end up being
  // about one bit more than those, so LiteralTreeBits is 8 + 1 and DistanceTreeBits is 5 + 1.
  // The optimum values may differ though from machine to machine, and possibly even between compilers.

const
  // maximum bit length of any code,
  // If BMAX needs to be larger than 16, then H and X[] should be Cardinal.
  BMAX = 15;

function BuildHuffmanTables(const B: array of cardinal; N, S: cardinal;
  const D, Extra: array of cardinal; Temp: PPInflateHuft; var M: cardinal;
  var HP: array of TInflateHuft; var HN: cardinal;
  var V: array of cardinal): Integer;

// Given a list of code lengths and a maximum table Size, make a set of tables to decode that set of codes. Returns Z_OK
// on success, Z_BUF_ERROR if the given code set is incomplete (the tables are still built in this case), Z_DATA_ERROR
// if the input is invalid (an over-subscribed set of lengths), or Z_MEM_ERROR if not enough memory.
//
// Input pareters:
// B contains the code lenths in bits (all assumed <= BMAX)
// N is the number of codes (<= NMAX)
// S is the number of simple valued codes (0..S - 1)
// D contains a list of base values for non-simple codes
// Extra carries a list of extra bits for non-simple codes
//
// Output parameters:
// Temp points to the starting table
// M receives the maxium lookup bits (actual space for trees)
// HP receives the Huffman tables
// while HN decribes how many of HP is actually used
// finally V is a working area which receives values in order of bit length

var
  A: cardinal; // counter for codes of length K
  F: cardinal; // I repeats in table every F entries
  G: Integer; // maximum code Length
  H: Integer; // table Level
  i: cardinal; // counter, current code
  J: cardinal; // counter
  K: Integer; // number of bits in current code
  L: Integer; // bits per table (returned in M)
  Mask: cardinal; // (1 shl W) - 1, to avoid cc - O bug on HP
  P: TPCardinal; // Pointer into C[], B[], or V[]
  Q: PInflateHuft; // points to current table
  R: TInflateHuft; // table entry for structure assignment
  XP: TPCardinal; // Pointer into X
  Y: Integer; // number of dummy codes added
  Z: cardinal; // number of entries in current table
  W: Integer; // bits before this table = (L * H)
  C: array [0 .. BMAX] of cardinal; // bit length count table
  U: array [0 .. BMAX - 1] of PInflateHuft; // table stack
  X: array [0 .. BMAX] of cardinal; // bit offsets, then code stack
Begin
  // generate counts for each bit length
  FillChar(C, SizeOf(C), 0);

  // assume all entries <= BMAX
  for i := 0 to N - 1 do
    inc(C[B[i]]);

  // nil input -> all zero length codes
  if C[0] = N then
  Begin
    Temp^ := nil;
    M := 0;
    Result := Z_OK;
    Exit;
  end;

  // find minimum and maximum length, bound [M] by those
  L := M;
  for J := 1 to BMAX do
    if C[J] <> 0 then
      break;
  // minimum code Length
  K := J;
  if cardinal(L) < J then
    L := J;
  for i := BMAX downto 1 do
    if C[i] <> 0 then
      break;
  // maximum code length
  G := i;
  if cardinal(L) > i then
    L := i;
  M := L;

  // adjust last length count to fill out codes if needed
  Y := 1 shl J;
  while J < i do
  begin
    dec(Y, C[J]);
    if Y < 0 then
    begin
      // bad input: more codes than bits
      Result := Z_DATA_ERROR;
      Exit;
    end;
    inc(J);
    Y := Y shl 1;
  end;
  dec(Y, C[i]);
  if Y < 0 then
  begin
    // bad input: more codes than bits
    Result := Z_DATA_ERROR;
    Exit;
  end;
  inc(C[i], Y);

  // generate starting offsets into the value table for each length
  X[1] := 0;
  J := 0;
  for i := 1 to G - 1 do
  begin
    inc(J, C[i]);
    X[i + 1] := J;
  end;
  { P := @C[1];
    XP := @X[2];
    // note that I = G from above
    Dec(I);
    while (I > 0) do begin
    Inc(J, P^);
    XP^ := J;
    Inc(P);
    Inc(XP);
    Dec(I);
    end; }

  // make a table of values in order of bit lengths
  for i := 0 to N - 1 do
  begin
    J := B[i];
    if J <> 0 then
    begin
      V[X[J]] := i;
      inc(X[J]);
    end;
  end;
  // set N to Length of V
  N := X[G];

  // generate the Huffman codes and for each make the table entries
  i := 0;
  // first Huffman code is zero
  X[0] := 0;
  // grab values in bit order
  P := @V;
  // no tables yet -> Level - 1
  H := -1;
  // bits decoded = (L * H)
  W := -L;

  U[0] := nil;
  Q := nil;
  Z := 0;

  // go through the bit lengths (K already is bits in shortest code)
  while K <= G Do
  begin
    A := C[K];
    while A <> 0 Do
    begin
      dec(A);
      // here I is the Huffman code of length K bits for value P^
      // make tables up to required level
      while K > W + L do
      begin
        inc(H);
        // add bits already decoded, previous table always L Bits
        inc(W, L);
        // compute minimum Size table less than or equal to L bits
        Z := G - W;
        if Z > cardinal(L) then
          Z := L;

        // try a K - W bit table
        J := K - W;
        F := 1 shl J;
        // too few codes for K - W bit table
        if F > A + 1 then
        begin
          // deduct codes from patterns left
          dec(F, A + 1);
          XP := @C[K];
          if J < Z then
          begin
            inc(J);
            while J < Z do
            begin
              // try smaller tables up to Z bits
              F := F shl 1;
              inc(XP);
              // enough codes to use up J Bits
              if F <= XP^ then
                break;
              // else deduct codes from patterns
              dec(F, XP^);
              inc(J);
            end;
          end;
        end;

        // table entries for J-bit table
        Z := 1 shl J;
        // allocate new table (note: doesn't matter for fixed)
        if HN + Z > MANY then
        begin
          Result := Z_MEM_ERROR;
          Exit;
        end;

        Q := @HP[HN];
        U[H] := Q;
        inc(HN, Z);

        // connect to last table, if there is one
        if H <> 0 then
        begin
          // save pattern for backing up
          X[H] := i;
          // bits to dump before this table
          R.Bits := L;
          // bits in this table
          R.Exop := J;
          J := i shr (W - L);
          R.Base := (cardinal(Q) - cardinal(U[H - 1])) div SizeOf(Q^) - J;
          // connect to last table
          PHuftField(U[H - 1])[J] := R;
        end
        else
          // first table is returned result
          Temp^ := Q;
      end;

      // set up table entry in R
      R.Bits := byte(K - W);

      // out of values -> invalid code
      if cardinal(P) >= cardinal(@V[N]) then
        R.Exop := 128 + 64
      else if P^ < S then
      begin
        // 256 is end-of-block code
        if P^ < 256 then
          R.Exop := 0
        else
          R.Exop := 32 + 64;
        // simple code is just the value
        R.Base := P^;
        inc(P);
      end
      else
      begin
        // non-simple -> look up in lists
        R.Exop := byte(Extra[P^ - S] + 16 + 64);
        R.Base := D[P^ - S];
        inc(P);
      end;

      // fill xode-like entries with R
      F := 1 shl (K - W);
      J := i shr W;
      while J < Z do
      begin
        PHuftField(Q)[J] := R;
        inc(J, F);
      end;

      // backwards increment the K-bit code I
      J := 1 shl (K - 1);
      while (i and J) <> 0 do
      begin
        i := i xor J;
        J := J shr 1
      end;
      i := i xor J;

      // backup over finished tables
      // needed on HP, cc -O bug
      Mask := (1 shl W) - 1;
      while (i and Mask) <> X[H] do
      begin
        // don't need to update Q
        dec(H);
        dec(W, L);
        Mask := (1 shl W) - 1;
      end;
    end;
    inc(K);
  end;

  // Return Z_BUF_ERROR if we were given an incomplete table
  if (Y <> 0) and (G <> 1) then
    Result := Z_BUF_ERROR
  else
    Result := Z_OK;
end;

function InflateTreesBits(var C: array of cardinal; var BB: cardinal;
  var TB: PInflateHuft; var HP: array of TInflateHuft;
  var Z: TZState): Integer;
// C holds 19 code lengths
// BB - bits tree desired/actual depth
// TB - bits tree result
// HP - space for trees
// Z - for messages
var
  R: Integer;
  HN: cardinal; // hufts used in space
  V: array [0 .. 18] of cardinal; // work area for BuildHuffmanTables
begin
  HN := 0;
  R := BuildHuffmanTables(C, 19, 19, CopyLengths, CopyLiteralExtra, @TB, BB,
    HP, HN, V);
  if (R = Z_BUF_ERROR) or (BB = 0) then
    R := Z_DATA_ERROR;
  Result := R;
end;

function InflateTreesDynamic(NL: cardinal; ND: cardinal;
  var C: array of cardinal; var LiteralBits: cardinal;
  var DistanceBits: cardinal; var TL: PInflateHuft; var TD: PInflateHuft;
  var HP: array of TInflateHuft; var Z: TZState): Integer;
// NL - number of literal/length codes
// ND - number of distance codes
// C - code lengths
// LiteralBits - literal desired/actual bit depth
// DistanceBits - distance desired/actual bit depth
// TL - literal/length tree result
// TD - distance tree result
// HP - space for trees
// Z - for messages
var
  R: Integer;
  HN: cardinal; // hufts used in space
  V: array [0 .. 287] of cardinal; // work area for BuildHuffmanTables
begin
  HN := 0;
  // allocate work area
  Result := Z_OK;
  // build literal/length tree
  R := BuildHuffmanTables(C, NL, 257, CopyLengths, CopyLiteralExtra, @TL,
    LiteralBits, HP, HN, V);
  if (R <> Z_OK) or (LiteralBits = 0) then
  begin
    Result := R;
    Exit;
  end;
  // build distance tree
  R := BuildHuffmanTables(TPACardinal(@C[NL])^, ND, 0, CopyOffsets, CopyExtra,
    @TD, DistanceBits, HP, HN, V);
  if (R <> Z_OK) or ((DistanceBits = 0) and (NL > 257)) then
  begin
    if R = Z_BUF_ERROR then
      R := Z_DATA_ERROR
    else if R <> Z_MEM_ERROR then
      R := Z_DATA_ERROR;
    Result := R;
  end;
end;

var
  // build fixed tables only once -> keep them here
  FixedBuild: Boolean = false;

const
  // number of hufts used by fixed tables
  FIXEDH = 544;

var
  FixedTablesMemory: array [0 .. FIXEDH - 1] of TInflateHuft;
  FixedLiteralBits: cardinal;
  FixedDistanceBits: cardinal;
  FixedLiteralTable: PInflateHuft;
  FixedDistanceTable: PInflateHuft;

function InflateTreesFixed(var LiteralBits: cardinal;
  var DistanceBits: cardinal; var TL, TD: PInflateHuft;
  var Z: TZState): Integer;

type
  PFixedTable = ^TFixedTable;
  TFixedTable = array [0 .. 287] of cardinal;

var
  K: Integer; // temporary variable
  C: PFixedTable; // length list for BuildHuffmanTables
  V: TPACardinal; // work area for BuildHuffmanTables
  F: cardinal; // number of hufts used in FixedTablesMemory

begin
  // build fixed tables if not already (multiple overlapped executions ok)
  if not FixedBuild then
  begin
    F := 0;
    C := nil;
    V := nil;
    try
      GetMem(C, 288 * SizeOf(cardinal));
      GetMem(V, 288 * SizeOf(cardinal));
      // literal table
      for K := 0 to 143 do
        C[K] := 8;
      for K := 144 to 255 do
        C[K] := 9;
      for K := 256 to 279 do
        C[K] := 7;
      for K := 280 to 287 do
        C[K] := 8;
      FixedLiteralBits := 9;
      BuildHuffmanTables(C^, 288, 257, CopyLengths, CopyLiteralExtra,
        @FixedLiteralTable, FixedLiteralBits, FixedTablesMemory, F, V^);
      // distance table
      for K := 0 to 29 do
        C[K] := 5;
      FixedDistanceBits := 5;
      BuildHuffmanTables(C^, 30, 0, CopyOffsets, CopyExtra,
        @FixedDistanceTable, FixedDistanceBits, FixedTablesMemory, F, V^);
      FixedBuild := true;
    finally
      if Assigned(V) then
        FreeMem(V);
      if Assigned(C) then
        FreeMem(C);
    end;
  end;
  LiteralBits := FixedLiteralBits;
  DistanceBits := FixedDistanceBits;
  TL := FixedLiteralTable;
  TD := FixedDistanceTable;
  Result := Z_OK;
end;

// tables for Deflate from PKZIP'S appnote.txt.
const
  // order of the bit length code lengths
  BitOrder: array [0 .. 18] of byte = (16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4,
    12, 3, 13, 2, 14, 1, 15);

  // Notes beyond the 1.93a appnote.txt:
  // 1. Distance pointers never point before the beginning of the output stream.
  // 2. Distance pointers can point back across blocks, up to 32k away.
  // 3. There is an implied maximum of 7 Bits for the bit Length table and 15 Bits for the actual data.
  // 4. if only one Code exists, then it is encoded using one bit. (zero would be more efficient, but perhaps a little
  // confusing.) If two codes exist, they are coded using one bit each (0 and 1).
  // 5. There is no way of sending zero distance codes -> a dummy must be sent if there are none. (History: a pre 2.0
  // Version of PKZIP would store blocks with no distance codes, but this was discovered to be
  // too harsh a criterion.) Valid only for 1.93a. 2.04c does allow zero distance codes, which is sent as one Code of
  // zero Bits in length.
  // 6. There are up to 286 literal/Length codes. Code 256 represents the end-of-block. Note however that the static
  // length Tree defines 288 codes just to fill out the Huffman codes. Codes 286 and 287 cannot be used though, since
  // there is no length base or extra bits defined for them. Similarily, there are up to 30 distance codes. However,
  // static trees defines 32 codes (all 5 Bits) to fill out the Huffman codes, but the last two had better not show up
  // in the data.
  // 7. Unzip can check dynamic Huffman blocks for complete code sets. The exception is that a single code would not be
  // complete (see #4).
  // 8. The five Bits following the block type is really the number of literal codes sent minus 257.
  // 9. Length codes 8, 16, 16 are interpreted as 13 Length codes of 8 bits (1 + 6 + 6). Therefore, to output three times
  // the length, you output three codes (1 + 1 + 1), whereas to output four times the same length,
  // you only need two codes (1+3).  Hmm.
  // 10. In the tree reconstruction algorithm, Code = Code + Increment only if BitLength(I) is not zero (pretty obvious).
  // 11. Correction: 4 Bits: # of Bit Length codes - 4 (4 - 19)
  // 12. Note: length code 284 can represent 227 - 258, but length code 285 really is 258. The last length deserves its
  // own, short code since it gets used a lot in very redundant files. The length 258 is special since 258 - 3 (the
  // min match length) is 255.
  // 13. The literal/length and distance code bit lengths are read as a single stream of lengths.  It is possible (and
  // advantageous) for a repeat code (16, 17, or 18) to go across the boundary between the two sets of lengths.

procedure InflateBlockReset(var S: TInflateBlocksState; var Z: TZState);
begin
  if (S.Mode = ibmBitTree) or (S.Mode = ibmDistTree) then
    FreeMem(S.sub.Trees.blens);
  if S.Mode = ibmCodes then
    FreeMem(S.sub.decode.codes);

  S.Mode := ibmZType;
  S.bitk := 0;
  S.bitb := 0;

  S.write := S.window;
  S.read := S.window;
end;

function InflateBlocksNew(var Z: TZState; W: cardinal): PInflateBlocksState;
// W is the window Size
var
  S: PInflateBlocksState;
begin
  GetMem(S, SizeOf(TInflateBlocksState));
  if S = nil then
    Result := S
  else
    try
      GetMem(S.hufts, SizeOf(TInflateHuft) * MANY);
      GetMem(S.window, W);
      S.zend := S.window;
      inc(S.zend, W);
      S.Mode := ibmZType;
      InflateBlockReset(S^, Z);
      Result := S;
    except
      if Assigned(S.window) then
        FreeMem(S.window);
      if Assigned(S.hufts) then
        FreeMem(S.hufts);
      FreeMem(S);
      raise ;
    end;
end;

function InflateBlocks(var S: TInflateBlocksState; var Z: TZState;
  R: Integer): Integer;
// R contains the initial return code
var
  Temp: cardinal;
  B: cardinal; // bit buffer
  K: cardinal; // bits in bit buffer
  P: PByte; // input data Pointer
  N: cardinal; // bytes available there
  Q: PByte; // output Window write Pointer
  M: cardinal; // bytes to end of window or read Pointer
  // fixed code blocks
  LiteralBits, DistanceBits: cardinal;
  TL, TD: PInflateHuft;
  H: PInflateHuft;
  i, J, C: cardinal;
  CodeState: PInflateCodesState;

  function UpdatePointers: Integer;
  begin
    S.bitb := B;
    S.bitk := K;
    Z.AvailableInput := N;
    inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
    Z.NextInput := P;
    S.write := Q;
    Result := InflateFlush(S, Z, R);
  end;

begin
  // copy input/output information to locals
  P := Z.NextInput;
  N := Z.AvailableInput;
  B := S.bitb;
  K := S.bitk;
  Q := S.write;
  if cardinal(Q) < cardinal(S.read) then
    M := cardinal(S.read) - cardinal(Q) - 1
  else
    M := cardinal(S.zend) - cardinal(Q);
  // decompress an inflated block
  // process input based on current state
  while true do
  begin
    case S.Mode of
      ibmZType:
        begin
          while K < 3 do
          begin
            if N <> 0 then
              R := Z_OK
            else
            begin
              Result := UpdatePointers;
              Exit;
            end;
            dec(N);
            B := B or (cardinal(P^) shl K);
            inc(P);
            inc(K, 8);
          end;

          Temp := B and 7;
          S.Last := Boolean(Temp and 1);
          case Temp shr 1 of
            0: // stored
              begin
                B := B shr 3;
                dec(K, 3);
                // go to byte boundary
                Temp := K and 7;
                B := B shr Temp;
                dec(K, Temp);
                // get length of stored block
                S.Mode := ibmLens;
              end;
            1: // fixed
              begin
                InflateTreesFixed(LiteralBits, DistanceBits, TL, TD, Z);
                S.sub.decode.codes := InflateCodesNew(LiteralBits,
                  DistanceBits, TL, TD, Z);
                if S.sub.decode.codes = nil then
                begin
                  R := Z_MEM_ERROR;
                  Result := UpdatePointers;
                  Exit;
                end;
                B := B shr 3;
                dec(K, 3);
                S.Mode := ibmCodes;
              end;
            2: // dynamic
              begin
                B := B shr 3;
                dec(K, 3);
                S.Mode := ibmTable;
              end;
            3: // illegal
              begin
                B := B shr 3;
                dec(K, 3);
                S.Mode := ibmBlockBad;
                R := Z_DATA_ERROR;
                Result := UpdatePointers;
                Exit;
              end;
          end;
        end;
      ibmLens:
        begin
          while K < 32 do
          begin
            if N <> 0 then
              R := Z_OK
            else
            begin
              Result := UpdatePointers;
              Exit;
            end;
            dec(N);
            B := B or (cardinal(P^) shl K);
            inc(P);
            inc(K, 8);
          end;

          if (((not B) shr 16) and $FFFF) <> (B and $FFFF) then
          begin
            S.Mode := ibmBlockBad;
            R := Z_DATA_ERROR;
            Result := UpdatePointers;
            Exit;
          end;
          S.sub.left := B and $FFFF;
          K := 0;
          B := 0;
          if S.sub.left <> 0 then
            S.Mode := ibmStored
          else if S.Last then
            S.Mode := ibmDry
          else
            S.Mode := ibmZType;
        end;
      ibmStored:
        begin
          if N = 0 then
          begin
            Result := UpdatePointers;
            Exit;
          end;

          if M = 0 then
          begin
            if (Q = S.zend) and (S.read <> S.window) then
            begin
              Q := S.window;
              if cardinal(Q) < cardinal(S.read) then
                M := cardinal(S.read) - cardinal(Q) - 1
              else
                M := cardinal(S.zend) - cardinal(Q);
            end;

            if M = 0 then
            begin
              S.write := Q;
              R := InflateFlush(S, Z, R);
              Q := S.write;
              if cardinal(Q) < cardinal(S.read) then
                M := cardinal(S.read) - cardinal(Q) - 1
              else
                M := cardinal(S.zend) - cardinal(Q);
              if (Q = S.zend) and (S.read <> S.window) then
              begin
                Q := S.window;
                if cardinal(Q) < cardinal(S.read) then
                  M := cardinal(S.read) - cardinal(Q) - 1
                else
                  M := cardinal(S.zend) - cardinal(Q);
              end;

              if M = 0 then
              begin
                Result := UpdatePointers;
                Exit;
              end;
            end;
          end;
          R := Z_OK;

          Temp := S.sub.left;
          if Temp > N then
            Temp := N;
          if Temp > M then
            Temp := M;
          Move(P^, Q^, Temp);
          inc(P, Temp);
          dec(N, Temp);
          inc(Q, Temp);
          dec(M, Temp);
          dec(S.sub.left, Temp);
          if S.sub.left = 0 then
          begin
            if S.Last then
              S.Mode := ibmDry
            else
              S.Mode := ibmZType;
          end;
        end;
      ibmTable:
        begin
          while K < 14 do
          begin
            if N <> 0 then
              R := Z_OK
            else
            begin
              Result := UpdatePointers;
              Exit;
            end;
            dec(N);
            B := B or (cardinal(P^) shl K);
            inc(P);
            inc(K, 8);
          end;

          Temp := B and $3FFF;
          S.sub.Trees.Table := Temp;
          if ((Temp and $1F) > 29) or (((Temp shr 5) and $1F) > 29) then
          begin
            S.Mode := ibmBlockBad;
            R := Z_DATA_ERROR;
            Result := UpdatePointers;
            Exit;
          end;
          Temp := 258 + (Temp and $1F) + ((Temp shr 5) and $1F);
          GetMem(S.sub.Trees.blens, Temp * SizeOf(cardinal));
          B := B shr 14;
          dec(K, 14);

          S.sub.Trees.Index := 0;
          S.Mode := ibmBitTree;
        end;
      ibmBitTree:
        begin
          while (S.sub.Trees.Index < 4 + (S.sub.Trees.Table shr 10)) do
          begin
            while K < 3 do
            begin
              if N <> 0 then
                R := Z_OK
              else
              begin
                Result := UpdatePointers;
                Exit;
              end;
              dec(N);
              B := B or (cardinal(P^) shl K);
              inc(P);
              inc(K, 8);
            end;

            S.sub.Trees.blens[BitOrder[S.sub.Trees.Index]] := B and 7;
            inc(S.sub.Trees.Index);
            B := B shr 3;
            dec(K, 3);
          end;
          while S.sub.Trees.Index < 19 do
          begin
            S.sub.Trees.blens[BitOrder[S.sub.Trees.Index]] := 0;
            inc(S.sub.Trees.Index);
          end;
          S.sub.Trees.BB := 7;
          Temp := InflateTreesBits(S.sub.Trees.blens^, S.sub.Trees.BB,
            S.sub.Trees.TB, S.hufts^, Z);
          if Temp <> Z_OK then
          begin
            FreeMem(S.sub.Trees.blens);
            R := Temp;
            if R = Z_DATA_ERROR then
              S.Mode := ibmBlockBad;
            Result := UpdatePointers;
            Exit;
          end;
          S.sub.Trees.Index := 0;
          S.Mode := ibmDistTree;
        end;
      ibmDistTree:
        begin
          while true do
          begin
            Temp := S.sub.Trees.Table;
            if not(S.sub.Trees.Index < 258 + (Temp and $1F) +
                ((Temp shr 5) and $1F)) then
              break;
            Temp := S.sub.Trees.BB;
            while K < Temp do
            begin
              if N <> 0 then
                R := Z_OK
              else
              begin
                Result := UpdatePointers;
                Exit;
              end;
              dec(N);
              B := B or (cardinal(P^) shl K);
              inc(P);
              inc(K, 8);
            end;

            H := S.sub.Trees.TB;
            inc(H, B and InflateMask[Temp]);
            Temp := H^.Bits;
            C := H^.Base;

            if C < 16 then
            begin
              B := B shr Temp;
              dec(K, Temp);
              S.sub.Trees.blens^[S.sub.Trees.Index] := C;
              inc(S.sub.Trees.Index);
            end
            else
            begin
              // C = 16..18
              if C = 18 then
              begin
                i := 7;
                J := 11;
              end
              else
              begin
                i := C - 14;
                J := 3;
              end;

              while K < Temp + i do
              begin
                if N <> 0 then
                  R := Z_OK
                else
                begin
                  Result := UpdatePointers;
                  Exit;
                end;
                dec(N);
                B := B or (cardinal(P^) shl K);
                inc(P);
                inc(K, 8);
              end;

              B := B shr Temp;
              dec(K, Temp);

              inc(J, cardinal(B) and InflateMask[i]);
              B := B shr i;
              dec(K, i);

              i := S.sub.Trees.Index;
              Temp := S.sub.Trees.Table;
              if (i + J > 258 + (Temp and $1F) + ((Temp shr 5) and $1F)) or
                ((C = 16) and (i < 1)) then
              begin
                FreeMem(S.sub.Trees.blens);
                S.Mode := ibmBlockBad;
                R := Z_DATA_ERROR;
                Result := UpdatePointers;
                Exit;
              end;

              if C = 16 then
                C := S.sub.Trees.blens[i - 1]
              else
                C := 0;
              repeat
                S.sub.Trees.blens[i] := C;
                inc(i);
                dec(J);
              until J = 0;
              S.sub.Trees.Index := i;
            end;
          end; // while

          S.sub.Trees.TB := nil;
          LiteralBits := 9;
          DistanceBits := 6;
          Temp := S.sub.Trees.Table;
          Temp := InflateTreesDynamic(257 + (Temp and $1F),
            1 + ((Temp shr 5) and $1F), S.sub.Trees.blens^, LiteralBits,
            DistanceBits, TL, TD, S.hufts^, Z);
          FreeMem(S.sub.Trees.blens);
          if Temp <> Z_OK then
          begin
            if Integer(Temp) = Z_DATA_ERROR then
              S.Mode := ibmBlockBad;
            R := Temp;
            Result := UpdatePointers;
            Exit;
          end;
          CodeState := InflateCodesNew(LiteralBits, DistanceBits, TL, TD, Z);
          if CodeState = nil then
          begin
            R := Z_MEM_ERROR;
            Result := UpdatePointers;
            Exit;
          end;
          S.sub.decode.codes := CodeState;
          S.Mode := ibmCodes;
        end;
      ibmCodes:
        begin
          // update pointers
          S.bitb := B;
          S.bitk := K;
          Z.AvailableInput := N;
          inc(Z.TotalInput, cardinal(P) - cardinal(Z.NextInput));
          Z.NextInput := P;
          S.write := Q;
          R := InflateCodes(S, Z, R);

          if R <> Z_STREAM_END then
          begin
            Result := InflateFlush(S, Z, R);
            Exit;
          end;
          R := Z_OK;
          FreeMem(S.sub.decode.codes);
          // load local pointers
          P := Z.NextInput;
          N := Z.AvailableInput;
          B := S.bitb;
          K := S.bitk;
          Q := S.write;
          if cardinal(Q) < cardinal(S.read) then
            M := cardinal(S.read) - cardinal(Q) - 1
          else
            M := cardinal(S.zend) - cardinal(Q);
          if not S.Last then
          begin
            S.Mode := ibmZType;
            continue;
          end;
          S.Mode := ibmDry;
        end;
      ibmDry:
        begin
          S.write := Q;
          R := InflateFlush(S, Z, R);
          Q := S.write;
          if S.read <> S.write then
          begin
            Result := UpdatePointers;
            Exit;
          end;
          S.Mode := ibmBlockDone;
        end;
      ibmBlockDone:
        begin
          R := Z_STREAM_END;
          Result := UpdatePointers;
          Exit;
        end;
      ibmBlockBad:
        begin
          R := Z_DATA_ERROR;
          Result := UpdatePointers;
          Exit;
        end;
    else
      R := Z_STREAM_ERROR;
      Result := UpdatePointers;
      Exit;
    end; // case S.mode of
  end;
end;

function CompressMem(src, dst: Pointer; srcLen, dstLen: Integer): Integer;

  function LongestMatch(var S: TDeflateState; CurrentMatch: cardinal): cardinal;
  // Sets MatchStart to the longest match starting at the given String and returns its length. Matches shorter or equal to
  // PreviousLength are discarded, in which case the result is equal to PreviousLength and MatchStart is garbage.
  // CurrentMatch is the head of the hash chain for the current String (StringStart) and its distance is <= MaxDistance,
  // and PreviousLength >= 1.
  // The match length will not be greater than S.Lookahead.

    function ScanFast(Scan, Match, StrEnd: PByte): Integer;
    // faster routine by AB
    begin
      inc(Scan, 2);
      inc(Match);
      // We check for insufficient lookahead only every 8th comparison,
      // the 256th check will be made at StringStart + 258.
      repeat
        inc(Scan);
        inc(Match);
        if (Scan^ <> Match^) then
          break;
        inc(Scan);
        inc(Match);
        if (Scan^ <> Match^) then
          break;
        inc(Scan);
        inc(Match);
        if (Scan^ <> Match^) then
          break;
        inc(Scan);
        inc(Match);
        if (Scan^ <> Match^) then
          break;
        inc(Scan);
        inc(Match);
        if (Scan^ <> Match^) then
          break;
        inc(Scan);
        inc(Match);
        if (Scan^ <> Match^) then
          break;
        inc(Scan);
        inc(Match);
        if (Scan^ <> Match^) then
          break;
        inc(Scan);
        inc(Match);
        if (Scan^ <> Match^) then
          break;
      until (cardinal(Scan) >= cardinal(StrEnd));
      Result := MAX_MATCH - Integer(cardinal(StrEnd) - cardinal(Scan));
    end;

  const
    CGoodLen = 4;
    CNiceLen = 16;
    CMaxChain = 8;
  var
    ChainLength: cardinal; // max hash chain length
    Scan: PByte; // current String
    Match: PByte; // matched String
    Len: cardinal; // length of current match
    BestLen: cardinal; // best match length so far
    NiceMatch: cardinal;
    Limit: cardinal;
    Previous: TPAWord;
    WMask: cardinal;
    StrEnd: PByte;
    ScanEnd1: byte;
    ScanEnd: byte;
    MaxDistance: cardinal;
  begin
    ChainLength := CMaxChain;
    Scan := @S.window[S.StringStart];
    BestLen := S.PreviousLength;
    NiceMatch := CNiceLen;
    MaxDistance := S.WindowSize - MIN_LOOKAHEAD;

    // In order to simplify the code, match distances are limited to MaxDistance instead of WSize.
    if S.StringStart > MaxDistance then
      Limit := S.StringStart - MaxDistance
    else
      Limit := 0;

    // Stop when CurrentMatch becomes <= Limit. To simplify the Code we prevent matches with the String of window index 0.
    Previous := S.Previous;
    WMask := S.WindowMask;

    StrEnd := @S.window[S.StringStart + MAX_MATCH];
{$IFOPT R+} {$R-} {$DEFINE RangeCheck} {$ENDIF}
    ScanEnd1 := TPAByte(Scan)[BestLen - 1];
    ScanEnd := TPAByte(Scan)[BestLen];
{$IFDEF RangeCheck} {$R+} {$UNDEF RangeCheck} {$ENDIF}
    // The code is optimized for HashBits >= 8 and MAX_MATCH - 2 multiple of 16.
    // It is easy to get rid of this optimization if necessary.
    // Do not waste too much time if we already have a good Match.
    if S.PreviousLength >= CGoodLen then
      ChainLength := ChainLength shr 2;

    // Do not look for matches beyond the end of the input. This is necessary to make Deflate deterministic.
    if NiceMatch > S.Lookahead then
      NiceMatch := S.Lookahead;

    repeat
      Match := @S.window[CurrentMatch];

      // Skip to next match if the match length cannot increase or if the match length is less than 2.
{$IFOPT R+} {$R-} {$DEFINE RangeCheck} {$ENDIF}
      if (TPAByte(Match)[BestLen] = ScanEnd) and
        (TPAByte(Match)[BestLen - 1] = ScanEnd1) and (Match^ = Scan^) then
      begin
{$IFDEF RangeCheck} {$R+} {$UNDEF RangeCheck} {$ENDIF}
        inc(Match);
        if Match^ = TPAByte(Scan)[1] then
        begin
          // The Check at BestLen - 1 can be removed because it will be made again later (this heuristic is not always a win).
          // It is not necessary to compare Scan[2] and Match[2] since they are always equal when the other bytes match,
          // given that the hash keys are equal and that HashBits >= 8.
          Len := ScanFast(Scan, Match, StrEnd); // faster routine by AB
          Scan := StrEnd;
          dec(Scan, MAX_MATCH);
          if Len > BestLen then
          begin
            S.MatchStart := CurrentMatch;
            BestLen := Len;
            if Len >= NiceMatch then
              break;
{$IFOPT R+} {$R-} {$DEFINE RangeCheck} {$ENDIF}
            ScanEnd1 := TPAByte(Scan)[BestLen - 1];
            ScanEnd := TPAByte(Scan)[BestLen];
{$IFDEF RangeCheck} {$R+} {$UNDEF RangeCheck} {$ENDIF}
          end;
        end;
      end;
      CurrentMatch := Previous[CurrentMatch and WMask];
      dec(ChainLength);
    until (CurrentMatch <= Limit) or (ChainLength = 0);

    if BestLen <= S.Lookahead then
      Result := BestLen
    else
      Result := S.Lookahead;
  end;

  procedure FillWindow(var S: TDeflateState);
  // Fills the window when the lookahead becomes insufficient, updates StringStart and Lookahead.
  // Lookahead must be less than MIN_LOOKAHEAD.
  // StringStart will be <= CurrentWindowSize - MIN_LOOKAHEAD on exit.
  // On exit at least one byte has been read, or AvailableInput = 0. Reads are performed for at least two bytes (required
  // for the zip translate_eol option -> not supported here).

    function ReadBuffer(ZState: PZState; Buffer: PByte;
      Size: cardinal): Integer;
    // Reads a new buffer from the current input stream, updates the Adler32 and total number of bytes read.  All Deflate
    // input goes through this function so some applications may wish to modify it to avoid allocating a large
    // ZState.NextInput buffer and copying from it (see also FlushPending).
    var
      Len: cardinal;
    begin
      Len := ZState.AvailableInput;
      if Len > Size then
        Len := Size;
      if Len = 0 then
      begin
        Result := 0;
        Exit;
      end;
      dec(ZState.AvailableInput, Len);
      Move(ZState.NextInput^, Buffer^, Len);
      inc(ZState.NextInput, Len);
      inc(ZState.TotalInput, Len);
      Result := Len;
    end;

  var
    N, M: cardinal;
    P: TPWord;
    More: cardinal; // amount of free space at the end of the window
  begin
    repeat
      More := S.CurrentWindowSize - Integer(S.Lookahead) - Integer
        (S.StringStart);
      if (More = 0) and (S.StringStart = 0) and (S.Lookahead = 0) then
        More := S.WindowSize
      else if More = cardinal(-1) then
      begin
        // Very unlikely, but sometimes possible if StringStart = 0 and Lookahead = 1 (input done one byte at time)
        dec(More);
        // If the Window is almost full and there is insufficient lookahead,
        // move the upper half to the lower one to make room in the upper half.
      end
      else if S.StringStart >= S.WindowSize + (S.WindowSize - MIN_LOOKAHEAD)
        then
      begin
        Move(S.window[S.WindowSize], S.window^, S.WindowSize);
        dec(S.MatchStart, S.WindowSize);
        dec(S.StringStart, S.WindowSize);
        // we now have StringStart >= MaxDistance
        dec(S.BlockStart, Integer(S.WindowSize));

        // Slide the hash table (could be avoided with 32 bit values at the expense of memory usage). We slide even when
        // Level = 0 to keep the hash table consistent if we switch back to Level > 0 later. (Using Level 0 permanently
        // is not an optimal usage of zlib, so we don't care about this pathological case.)
        P := @S.Head[S.HashSize];
        for N := 1 to S.HashSize do
        begin
          dec(P);
          M := P^;
          if M >= S.WindowSize then
            P^ := M - S.WindowSize
          else
            P^ := 0;
        end;
        P := @S.Previous[S.WindowSize];
        for N := 1 to S.WindowSize do
        begin
          dec(P);
          M := P^;
          if M >= S.WindowSize then
            P^ := M - S.WindowSize
          else
            P^ := 0;
          // if N is not on any hash chain Previous[N] is garbage but its value will never be used
        end;
        inc(More, S.WindowSize);
      end;

      if S.ZState.AvailableInput = 0 then
        Exit;

      // If there was no sliding:
      // StringStart <= S.WindowSize + MaxDistance - 1 and Lookahead <= MIN_LOOKAHEAD - 1 and
      // More = CurrentWindowSize - Lookahead - StringStart
      // => More >= CurrentWindowSize - (MIN_LOOKAHEAD - 1 + S.WindowSize + MaxDistance - 1)
      // => More >= CurrentWindowSize - 2 * S.WindowSize + 2
      // In the BIG_MEM or MMAP case (not yet supported),
      // CurrentWindowSize = input_size + MIN_LOOKAHEAD  and
      // StringStart + S.Lookahead <= input_size => More >= MIN_LOOKAHEAD.
      // Otherwise, CurrentWindowSize = 2 * S.WindowSize so More >= 2.
      // If there was sliding More >= S.WindowSize. So in all cases More >= 2.
      N := ReadBuffer(S.ZState, @S.window[S.StringStart + S.Lookahead], More);
      inc(S.Lookahead, N);

      // Initialize the hash Value now that we have some input:
      if S.Lookahead >= MIN_MATCH then
      begin
        S.InsertHash := S.window[S.StringStart];
        S.InsertHash := ((S.InsertHash shl S.HashShift)
            xor S.window[S.StringStart + 1]) and S.HashMask;
      end;
      // If the whole input has less than MIN_MATCH bytes, InsertHash is garbage,
      // but this is not important since only literal bytes will be emitted.
    until (S.Lookahead >= MIN_LOOKAHEAD) or (S.ZState.AvailableInput = 0);
  end;

  procedure InitializeBlock(var S: TDeflateState);
  var
    N: Integer;
  begin
    // initialize the trees
    for N := 0 to L_CODES - 1 do
      S.LiteralTree[N].fc.Frequency := 0;
    for N := 0 to D_CODES - 1 do
      S.DistanceTree[N].fc.Frequency := 0;
    for N := 0 to BL_CODES - 1 do
      S.BitLengthTree[N].fc.Frequency := 0;
    S.LiteralTree[END_BLOCK].fc.Frequency := 1;
    S.StaticLength := 0;
    S.OptimalLength := 0;
    S.Matches := 0;
    S.LastLiteral := 0;
  end;

  procedure FlushBlockOnly(var S: TDeflateState; EOF: Boolean);
  // Flushs the current block with given end-of-file flag.
  // StringStart must be set to the end of the current match.

    procedure FlushPending(var ZState: TZState);
    // Flushs as much pending output as possible. All Deflate output goes through this function so some applications may
    // wish to modify it to avoid allocating a large ZState.NextOutput buffer and copying into it
    // (see also ReadBuffer).

    var
      Len: cardinal;
      S: PDeflateState;

    begin
      S := PDeflateState(ZState.State);
      Len := S.Pending;

      if Len > ZState.AvailableOutput then
        Len := ZState.AvailableOutput;
      if Len > 0 then
      begin
        Move(S.PendingOutput^, ZState.NextOutput^, Len);
        inc(ZState.NextOutput, Len);
        inc(S.PendingOutput, Len);
        inc(ZState.TotalOutput, Len);
        dec(ZState.AvailableOutput, Len);
        dec(S.Pending, Len);
        if S.Pending = 0 then
          S.PendingOutput := PByte(S.PendingBuffer);
      end;
    end;

    function TreeFlushBlock(var S: TDeflateState; Buffer: PByte;
      StoredLength: Integer; EOF: Boolean): Integer;
    // Determines the best encoding for the current block: dynamic trees, static trees or store, and outputs the encoded
    // block. Buffer contains the input block (or nil if too old), StoredLength the length of this block and EOF if this
    // is the last block.
    // Returns the total compressed length so far.

      procedure BuildTree(var S: TDeflateState;
        var Descriptor: TTreeDescriptor);
      // Constructs a Huffman tree and assigns the code bit strings and lengths.
      // Updates the total bit length for the current block. The field Frequency must be set for all tree elements on entry.
      // Result: the fields Len and Code are set to the optimal bit length and corresponding Code. The length OptimalLength
      // is updated; StaticLength is also updated if STree is not nil. The field MaxCode is set.

        procedure GenerateCodes(Tree: PTree; MaxCode: Integer;
          const BitLengthCounts: array of word);
        // Generates the codes for a given tree and bit counts (which need not be optimal).
        // The array BitLengthCounts contains the bit length statistics for the given tree and the field Len is set for all
        // Tree elements. MaxCode is the largest code with non zero frequency and BitLengthCounts are the number of codes at
        // each bit length.
        // On exit the field code is set for all tree elements of non zero code length.

          function BitReverse(Code: word; Len: Integer): word;
          // Reverses the first Len bits of Code, using straightforward code (a faster
          // imMethod would use a table)
          begin
            Result := 0;
            repeat
              Result := Result or (Code and 1);
              Code := Code shr 1;
              Result := Result shl 1;
              dec(Len);
            until Len <= 0;
            Result := Result shr 1;
          end;

        var
          NextCode: array [0 .. MAX_BITS] of word;
          // next code value for each bit length
          Code: word; // running code value
          Bits: Integer; // bit Index
          N: Integer; // code Index
          Len: Integer;
        begin
          Code := 0;
          // The distribution counts are first used to generate the code values without bit reversal.
          for Bits := 1 to MAX_BITS do
          begin
            Code := (Code + BitLengthCounts[Bits - 1]) shl 1;
            NextCode[Bits] := Code;
          end;
          // Check that the bit counts in BitLengthCounts are consistent. The last code must be all ones.
          for N := 0 to MaxCode do
          begin
            Len := Tree[N].dl.Len;
            if Len = 0 then
              continue;
            Tree[N].fc.Code := BitReverse(NextCode[Len], Len);
            inc(NextCode[Len]);
          end;
        end;

        procedure RestoreHeap(var S: TDeflateState; const Tree: TTree;
          K: Integer);
        // Restores the heap property by moving down tree starting at node K,
        // exchanging a Node with the smallest of its two sons if necessary, stopping
        // when the heap property is re-established (each father smaller than its two sons).
        var
          V, J: Integer;
        begin
          V := S.Heap[K];
          J := K shl 1; // left son of K
          while J <= S.HeapLength do
          begin
            // set J to the smallest of the two sons:
            if (J < S.HeapLength) and
              ((Tree[S.Heap[J + 1]].fc.Frequency < Tree[S.Heap[J]]
                  .fc.Frequency) or
                ((Tree[S.Heap[J + 1]].fc.Frequency = Tree[S.Heap[J]]
                    .fc.Frequency) and (S.Depth[S.Heap[J + 1]] <= S.Depth
                    [S.Heap[J]]))) then
              inc(J);

            // exit if V is smaller than both sons
            if ((Tree[V].fc.Frequency < Tree[S.Heap[J]].fc.Frequency) or
                ((Tree[V].fc.Frequency = Tree[S.Heap[J]].fc.Frequency) and
                  (S.Depth[V] <= S.Depth[S.Heap[J]]))) then
              break;

            // exchange V with the smallest son
            S.Heap[K] := S.Heap[J];
            K := J;

            // and xontinue down the tree, setting J to the left son of K
            J := J shl 1;
          end;
          S.Heap[K] := V;
        end;

        procedure GenerateBitLengths(var S: TDeflateState;
          var Descriptor: TTreeDescriptor);
        // Computes the optimal bit lengths for a tree and update the total bit length for the current block.
        // The fields Frequency and dad are set, Heap[HeapMaximum] and above are the tree nodes sorted by increasing frequency.
        // Result: The field Len is set to the optimal bit length, the array BitLengthCounts contains the frequencies for each
        // bit length. The length OptimalLength is updated. StaticLength is also updated if STree is not nil.
        var
          Tree: PTree;
          MaxCode: Integer;
          STree: PTree;
          Extra: TPAInteger;
          Base: Integer;
          MaxLength: Integer;
          H: Integer; // heap Index
          N, M: Integer; // iterate over the tree elements
          Bits: word; // bit length
          ExtraBits: Integer;
          F: word; // frequency
          Overflow: Integer; // number of elements with bit length too large
        begin
          Tree := Descriptor.DynamicTree;
          MaxCode := Descriptor.MaxCode;
          STree := Descriptor.StaticDescriptor.StaticTree;
          Extra := Descriptor.StaticDescriptor.ExtraBits;
          Base := Descriptor.StaticDescriptor.ExtraBase;
          MaxLength := Descriptor.StaticDescriptor.MaxLength;
          Overflow := 0;

          FillChar(S.BitLengthCounts, SizeOf(S.BitLengthCounts), 0);

          // in a first pass, compute the optimal bit lengths (which may overflow in the case of the bit length tree)
          Tree[S.Heap[S.HeapMaximum]].dl.Len := 0; // root of the heap

          for H := S.HeapMaximum + 1 to HEAP_SIZE - 1 do
          begin
            N := S.Heap[H];
            Bits := Tree[Tree[N].dl.dad].dl.Len + 1;
            if Bits > MaxLength then
            begin
              Bits := MaxLength;
              inc(Overflow);
            end;
            Tree[N].dl.Len := Bits;

            // overwrite Tree[N].dl.Dad which is no longer needed
            if N > MaxCode then
              continue; // not a leaf node

            inc(S.BitLengthCounts[Bits]);
            ExtraBits := 0;
            if N >= Base then
              ExtraBits := Extra[N - Base];
            F := Tree[N].fc.Frequency;
            inc(S.OptimalLength, Integer(F) * (Bits + ExtraBits));
            if Assigned(STree) then
              inc(S.StaticLength, Integer(F) * (STree[N].dl.Len + ExtraBits));
          end;
          // This happens for example on obj2 and pic of the Calgary corpus
          if Overflow = 0 then
            Exit;

          // find the first bit length which could increase
          repeat
            Bits := MaxLength - 1;
            while (S.BitLengthCounts[Bits] = 0) do
              dec(Bits);
            // move one leaf down the tree
            dec(S.BitLengthCounts[Bits]);
            // move one overflow item as its brother
            inc(S.BitLengthCounts[Bits + 1], 2);
            // The brother of the overflow item also movels one step up,
            // but this does not affect BitLengthCounts[MaxLength]
            dec(S.BitLengthCounts[MaxLength]);
            dec(Overflow, 2);
          until (Overflow <= 0);

          // Now recompute all bit lengths, scanning in increasing frequency.
          // H is still equal to HEAP_SIZE. (It is simpler to reconstruct all
          // lengths instead of fixing only the wrong ones. This idea is taken
          // from 'ar' written by Haruhiko Okumura.)
          H := HEAP_SIZE;
          for Bits := MaxLength downto 1 do
          begin
            N := S.BitLengthCounts[Bits];
            while (N <> 0) do
            begin
              dec(H);
              M := S.Heap[H];
              if M > MaxCode then
                continue;
              if Tree[M].dl.Len <> Bits then
              begin
                inc(S.OptimalLength,
                  (Bits - Tree[M].dl.Len) * Tree[M].fc.Frequency);
                Tree[M].dl.Len := word(Bits);
              end;
              dec(N);
            end;
          end;
        end;

      var
        Tree: PTree;
        STree: PTree;
        Elements: Integer;
        N, M: Integer; // iterate over heap elements
        MaxCode: Integer; // largest code with non zero frequency
        Node: Integer; // new node being created

      begin
        Tree := Descriptor.DynamicTree;
        STree := Descriptor.StaticDescriptor.StaticTree;
        Elements := Descriptor.StaticDescriptor.Elements;
        MaxCode := -1;

        // Construct the initial Heap, with least frequent element in Heap[SMALLEST].
        // The sons of Heap[N] are Heap[2 * N] and Heap[2 * N + 1]. Heap[0] is not used.
        S.HeapLength := 0;
        S.HeapMaximum := HEAP_SIZE;

        for N := 0 to Elements - 1 do
        begin
          if Tree[N].fc.Frequency = 0 then
            Tree[N].dl.Len := 0
          else
          begin
            MaxCode := N;
            inc(S.HeapLength);
            S.Heap[S.HeapLength] := N;
            S.Depth[N] := 0;
          end;
        end;

        // The pkzip format requires that at least one distance code exists and that at least one bit
        // should be sent even if there is only one possible code. So to avoid special checks later on we force at least
        // two codes of non zero frequency.
        while S.HeapLength < 2 do
        begin
          inc(S.HeapLength);
          if MaxCode < 2 then
          begin
            inc(MaxCode);
            S.Heap[S.HeapLength] := MaxCode;
            Node := MaxCode;
          end
          else
          begin
            S.Heap[S.HeapLength] := 0;
            Node := 0;
          end;
          Tree[Node].fc.Frequency := 1;
          S.Depth[Node] := 0;
          dec(S.OptimalLength);
          if (STree <> nil) then
            dec(S.StaticLength, STree[Node].dl.Len);
          // Node is 0 or 1 so it does not have extra bits
        end;
        Descriptor.MaxCode := MaxCode;

        // The elements Heap[HeapLength / 2 + 1 .. HeapLength] are leaves of the Tree,
        // establish sub-heaps of increasing lengths.
        for N := S.HeapLength div 2 downto 1 do
          RestoreHeap(S, Tree^, N);

        // construct the Huffman tree by repeatedly combining the least two frequent nodes
        Node := Elements; // next internal node of the tree
        repeat
          N := S.Heap[1];
          S.Heap[1] := S.Heap[S.HeapLength];
          dec(S.HeapLength);
          RestoreHeap(S, Tree^, 1);

          // M := node of next least frequency
          M := S.Heap[1];
          dec(S.HeapMaximum);
          // keep the nodes sorted by frequency
          S.Heap[S.HeapMaximum] := N;
          dec(S.HeapMaximum);
          S.Heap[S.HeapMaximum] := M;

          // create a new node father of N and M
          Tree[Node].fc.Frequency := Tree[N].fc.Frequency + Tree[M]
            .fc.Frequency;
          // maximum
          if (S.Depth[N] >= S.Depth[M]) then
            S.Depth[Node] := byte(S.Depth[N] + 1)
          else
            S.Depth[Node] := byte(S.Depth[M] + 1);

          Tree[M].dl.dad := word(Node);
          Tree[N].dl.dad := word(Node);
          // and insert the new node in the heap
          S.Heap[1] := Node;
          inc(Node);
          RestoreHeap(S, Tree^, 1);
        until S.HeapLength < 2;

        dec(S.HeapMaximum);
        S.Heap[S.HeapMaximum] := S.Heap[1];

        // At this point the fields Frequency and dad are set. We can now generate the bit lengths.
        GenerateBitLengths(S, Descriptor);

        // The field Len is now set, we can generate the bit codes
        GenerateCodes(Tree, MaxCode, S.BitLengthCounts);
      end;

      procedure BitsWindup(var S: TDeflateState);
      // flushs the bit buffer and aligns the output on a byte boundary
      begin
        if S.ValidBits > 8 then
        begin
          S.PendingBuffer[S.Pending] := byte(S.BitsBuffer and $FF);
          inc(S.Pending);
          S.PendingBuffer[S.Pending] := byte(word(S.BitsBuffer) shr 8);
          inc(S.Pending);
        end
        else if S.ValidBits > 0 then
        begin
          S.PendingBuffer[S.Pending] := byte(S.BitsBuffer);
          inc(S.Pending);
        end;
        S.BitsBuffer := 0;
        S.ValidBits := 0;
      end;

      procedure SendBits(var S: TDeflateState; Value: word; Length: Integer);
      // Value contains what is to be sent
      // Length is the number of bits to send
      begin
        // If there's not enough room in BitsBuffer use (valid) bits from BitsBuffer and
        // (16 - ValidBits) bits from Value, leaving (width - (16 - ValidBits)) unused bits in Value.
{$IFOPT Q+} {$Q-} {$DEFINE OverflowCheck} {$ENDIF}
{$IFOPT R+} {$R-} {$DEFINE RangeCheck} {$ENDIF}
        if (S.ValidBits > Integer(BufferSize) - Length) then
        begin
          S.BitsBuffer := S.BitsBuffer or (Value shl S.ValidBits);
          S.PendingBuffer[S.Pending] := S.BitsBuffer and $FF;
          inc(S.Pending);
          S.PendingBuffer[S.Pending] := S.BitsBuffer shr 8;
          inc(S.Pending);
          S.BitsBuffer := Value shr (BufferSize - S.ValidBits);
          inc(S.ValidBits, Length - BufferSize);
        end
        else
        begin
          S.BitsBuffer := S.BitsBuffer or (Value shl S.ValidBits);
          inc(S.ValidBits, Length);
        end;
{$IFDEF OverflowCheck} {$Q+} {$UNDEF OverflowCheck} {$ENDIF}
{$IFDEF RangeCheck} {$R+} {$UNDEF RangeCheck} {$ENDIF}
      end;

      procedure SendAllTrees(var S: TDeflateState;
        lcodes, dcodes, blcodes: Integer);
      // Sends the header for a block using dynamic Huffman trees: the counts, the
      // lengths of the bit length codes, the literal tree and the distance tree.
      // lcodes must be >= 257, dcodes >= 1 and blcodes >= 4

        procedure SendTree(var S: TDeflateState;
          const Tree: array of TTreeEntry; MaxCode: Integer);
        // Sends the given tree in compressed form using the codes in BitLengthTree.
        // MaxCode is the tree's largest code of non zero frequency.
        var
          N: Integer; // iterates over all tree elements
          PreviousLen: Integer; // last emitted length
          CurrentLen: Integer; // length of current code
          NextLen: Integer; // length of next code
          Count: Integer; // repeat count of the current code
          MaxCount: Integer; // max repeat count
          MinCount: Integer; // min repeat count
        begin
          PreviousLen := -1;
          NextLen := Tree[0].dl.Len;
          Count := 0;
          MaxCount := 7;
          MinCount := 4;
          // guard is already set
          if NextLen = 0 then
          begin
            MaxCount := 138;
            MinCount := 3;
          end;
          for N := 0 to MaxCode do
          begin
            CurrentLen := NextLen;
            NextLen := Tree[N + 1].dl.Len;
            inc(Count);
            if (Count < MaxCount) and (CurrentLen = NextLen) then
              continue
            else if Count < MinCount then
            begin
              repeat
                SendBits(S, S.BitLengthTree[CurrentLen].fc.Code,
                  S.BitLengthTree[CurrentLen].dl.Len);
                dec(Count);
              until (Count = 0);
            end
            else if CurrentLen <> 0 then
            begin
              if CurrentLen <> PreviousLen then
              begin
                SendBits(S, S.BitLengthTree[CurrentLen].fc.Code,
                  S.BitLengthTree[CurrentLen].dl.Len);
                dec(Count);
              end;
              SendBits(S, S.BitLengthTree[REP_3_6].fc.Code,
                S.BitLengthTree[REP_3_6].dl.Len);
              SendBits(S, Count - 3, 2);
            end
            else if Count <= 10 then
            begin
              SendBits(S, S.BitLengthTree[REPZ_3_10].fc.Code,
                S.BitLengthTree[REPZ_3_10].dl.Len);
              SendBits(S, Count - 3, 3);
            end
            else
            begin
              SendBits(S, S.BitLengthTree[REPZ_11_138].fc.Code,
                S.BitLengthTree[REPZ_11_138].dl.Len);
              SendBits(S, Count - 11, 7);
            end;
            Count := 0;
            PreviousLen := CurrentLen;
            if NextLen = 0 then
            begin
              MaxCount := 138;
              MinCount := 3;
            end
            else if CurrentLen = NextLen then
            begin
              MaxCount := 6;
              MinCount := 3;
            end
            else
            begin
              MaxCount := 7;
              MinCount := 4;
            end;
          end;
        end;

      var
        Rank: Integer;
      begin
        SendBits(S, lcodes - 257, 5); // not +255 as stated in appnote.txt
        SendBits(S, dcodes - 1, 5);
        SendBits(S, blcodes - 4, 4); // not -3 as stated in appnote.txt
        for Rank := 0 to blcodes - 1 do
          SendBits(S, S.BitLengthTree[BitLengthOrder[Rank]].dl.Len, 3);
        SendTree(S, S.LiteralTree, lcodes - 1);
        SendTree(S, S.DistanceTree, dcodes - 1);
      end;

      function BuildBitLengthTree(var S: TDeflateState): Integer;
      // Constructs the Huffman tree for the bit lengths and returns the Index in BitLengthOrder
      // of the last bit length code to send.

        procedure ScanTree(var S: TDeflateState; var Tree: array of TTreeEntry;
          MaxCode: Integer);
        // Scans a given tree to determine the frequencies of the codes in the bit length tree.
        // MaxCode is the tree's largest code of non zero frequency.
        var
          N: Integer; // iterates over all tree elements
          PreviousLen: Integer; // last emitted length
          CurrentLen: Integer; // Length of current code
          NextLen: Integer; // length of next code
          Count: Integer; // repeat count of the current xode
          MaxCount: Integer; // max repeat count
          MinCount: Integer; // min repeat count
        begin
          PreviousLen := -1;
          NextLen := Tree[0].dl.Len;
          Count := 0;
          MaxCount := 7;
          MinCount := 4;

          if NextLen = 0 then
          begin
            MaxCount := 138;
            MinCount := 3;
          end;
          Tree[MaxCode + 1].dl.Len := word($FFFF); // guard

          for N := 0 to MaxCode do
          begin
            CurrentLen := NextLen;
            NextLen := Tree[N + 1].dl.Len;
            inc(Count);
            if (Count < MaxCount) and (CurrentLen = NextLen) then
              continue
            else if (Count < MinCount) then
              inc(S.BitLengthTree[CurrentLen].fc.Frequency, Count)
            else if CurrentLen <> 0 then
            begin
              if (CurrentLen <> PreviousLen) then
                inc(S.BitLengthTree[CurrentLen].fc.Frequency);
              inc(S.BitLengthTree[REP_3_6].fc.Frequency);
            end
            else if (Count <= 10) then
              inc(S.BitLengthTree[REPZ_3_10].fc.Frequency)
            else
              inc(S.BitLengthTree[REPZ_11_138].fc.Frequency);
            Count := 0;
            PreviousLen := CurrentLen;
            if NextLen = 0 then
            begin
              MaxCount := 138;
              MinCount := 3;
            end
            else if CurrentLen = NextLen then
            begin
              MaxCount := 6;
              MinCount := 3;
            end
            else
            begin
              MaxCount := 7;
              MinCount := 4;
            end;
          end;
        end;

      begin
        // determine the bit length frequencies for literal and distance trees
        ScanTree(S, S.LiteralTree, S.LiteralDescriptor.MaxCode);
        ScanTree(S, S.DistanceTree, S.DistanceDescriptor.MaxCode);

        // build the bit length tree
        BuildTree(S, S.BitLengthDescriptor);
        // OptimalLength now includes the length of the tree representations, except
        // the lengths of the bit lengths codes and the 5 + 5 + 4 (= 14) bits for the counts.

        // Determine the number of bit length codes to send. The pkzip format requires that at least 4 bit length codes
        // be sent. (appnote.txt says 3 but the actual value used is 4.)
        for Result := BL_CODES - 1 downto 3 do
          if S.BitLengthTree[BitLengthOrder[Result]].dl.Len <> 0 then
            break;

        // update OptimalLength to include the bit length tree and counts
        inc(S.OptimalLength, 3 * (Result + 1) + 14);
      end;

      procedure TreeStroredBlock(var S: TDeflateState; Buffer: PByte;
        StoredLength: Integer; EOF: Boolean);
      // sends a stored block
      // Buffer contains the input data, Len the buffer length and EOF is True if this is the last block for a file.

        procedure CopyBlock(var S: TDeflateState; Buffer: PByte; Len: cardinal;
          Header: Boolean);
        // copies a stored block, storing first the length and its one's complement if requested
        // Buffer contains the input data, Len the buffer length and Header is True if the block Header must be written too.
        begin
          BitsWindup(S); // align on byte boundary
          S.LastEOBLength := 8; // enough lookahead for Inflate

          if Header then
          begin
            S.PendingBuffer[S.Pending] := byte(word(Len) and $FF);
            inc(S.Pending);
            S.PendingBuffer[S.Pending] := byte(word(Len) shr 8);
            inc(S.Pending);
            S.PendingBuffer[S.Pending] := byte(word(not Len) and $FF);
            inc(S.Pending);
            S.PendingBuffer[S.Pending] := byte(word(not Len) shr 8);
            inc(S.Pending);
          end;

          while Len > 0 do
          begin
            dec(Len);
            S.PendingBuffer[S.Pending] := Buffer^;
            inc(Buffer);
            inc(S.Pending);
          end;
        end;

      begin
        SendBits(S, (STORED_BLOCK shl 1) + Ord(EOF), 3); // send block type
        S.CompressedLength := (S.CompressedLength + 10) and Integer(not 7);
        inc(S.CompressedLength, (StoredLength + 4) shl 3);

        // copy with header
        CopyBlock(S, Buffer, cardinal(StoredLength), true);
      end;

      procedure CompressBlock(var S: TDeflateState; const LiteralTree,
        DistanceTree: array of TTreeEntry);
      // sends the block data compressed using the given Huffman trees
      var
        Distance: cardinal; // distance of matched String
        lc: Integer; // match length or unmatched char (if Distance = 0)
        i: cardinal;
        Code: cardinal; // the code to send
        Extra: Integer; // number of extra bits to send

      begin
        i := 0;
        if S.LastLiteral <> 0 then
          repeat
            Distance := S.DistanceBuffer[i];
            lc := S.LiteralBuffer[i];
            inc(i);
            if Distance = 0 then
            begin
              // send a literal byte
              SendBits(S, LiteralTree[lc].fc.Code, LiteralTree[lc].dl.Len);
            end
            else
            begin
              // Here, lc is the match length - MIN_MATCH
              Code := LengthCode[lc];
              // send the length code
              SendBits(S, LiteralTree[Code + LITERALS + 1].fc.Code,
                LiteralTree[Code + LITERALS + 1].dl.Len);
              Extra := ExtraLengthBits[Code];
              if Extra <> 0 then
              begin
                dec(lc, BaseLength[Code]);
                // send the extra length bits
                SendBits(S, lc, Extra);
              end;
              dec(Distance); // Distance is now the match distance - 1
              if Distance < 256 then
                Code := DistanceCode[Distance]
              else
                Code := DistanceCode[256 + (Distance shr 7)];

              // send the distance code
              SendBits(S, DistanceTree[Code].fc.Code,
                DistanceTree[Code].dl.Len);
              Extra := ExtraDistanceBits[Code];
              if Extra <> 0 then
              begin
                dec(Distance, BaseDistance[Code]);
                SendBits(S, Distance, Extra); // send the extra distance bits
              end;
            end; // literal or match pair?

            // Check that the overlay between PendingBuffer and DistanceBuffer + LiteralBuffer is ok
          until i >= S.LastLiteral;

          SendBits(S, LiteralTree[END_BLOCK].fc.Code,
            LiteralTree[END_BLOCK].dl.Len);
        S.LastEOBLength := LiteralTree[END_BLOCK].dl.Len;
      end;

    var
      OptimalByteLength, StaticByteLength: Integer;
      // OptimalLength and StaticLength in bytes
      MacBLIndex: Integer; // index of last bit length code of non zero frequency
    begin
      // construct the literal and distance trees
      // After this, OptimalLength and StaticLength are the total bit lengths of
      // the compressed block data, excluding the tree representations.
      BuildTree(S, S.LiteralDescriptor);
      BuildTree(S, S.DistanceDescriptor);

      // Build the bit length tree for the above two trees and get the index
      // in BitLengthOrder of the last bit length code to send.
      MacBLIndex := BuildBitLengthTree(S);

      // determine the best encoding, compute first the block length in bytes
      OptimalByteLength := (S.OptimalLength + 10) shr 3;
      StaticByteLength := (S.StaticLength + 10) shr 3;
      if StaticByteLength <= OptimalByteLength then
        OptimalByteLength := StaticByteLength;

      // if Iompression failed and this is the first and last block,
      // and if the .zip file can be seeked (to rewrite the local header),
      // the whole file is transformed into a stored file.
      // (4 are the two words for the lengths)
      if (StoredLength + 4 <= OptimalByteLength) and Assigned(Buffer) then
      begin
        // The test Buffer <> nil is only necessary if LiteralBufferSize > WSize.
        // Otherwise we can't have processed more than WSize input bytes since
        // the last block dlush, because compression would have been successful.
        // if LiteralBufferSize <= WSize, it is never too late to transform a block into a stored block.
        TreeStroredBlock(S, Buffer, StoredLength, EOF);
      end
      else if StaticByteLength = OptimalByteLength then
      begin
        // force static trees
        SendBits(S, (STATIC_TREES shl 1) + Ord(EOF), 3);
        CompressBlock(S, StaticLiteralTree, StaticDescriptorTree);
        inc(S.CompressedLength, 3 + S.StaticLength);
      end
      else
      begin
        SendBits(S, (DYN_TREES shl 1) + Ord(EOF), 3);
        SendAllTrees(S, S.LiteralDescriptor.MaxCode + 1,
          S.DistanceDescriptor.MaxCode + 1, MacBLIndex + 1);
        CompressBlock(S, S.LiteralTree, S.DistanceTree);
        inc(S.CompressedLength, 3 + S.OptimalLength);
      end;
      InitializeBlock(S);

      if EOF then
      begin
        BitsWindup(S);
        // align on byte boundary
        inc(S.CompressedLength, 7);
      end;

      Result := S.CompressedLength shr 3;
    end;

  begin
    if S.BlockStart >= 0 then
      TreeFlushBlock(S, @S.window[cardinal(S.BlockStart)],
        Integer(S.StringStart) - S.BlockStart, EOF)
    else
      TreeFlushBlock(S, nil, Integer(S.StringStart) - S.BlockStart, EOF);

    S.BlockStart := S.StringStart;
    FlushPending(S.ZState^);
  end;

  function TreeTally(var S: TDeflateState; Distance: cardinal;
    lc: cardinal): Boolean;
  // Saves the match info and tallies the frequency counts. Returns True if the current block must be flushed.
  // Distance is the distance of the matched String and lc either match length minus MIN_MATCH or the unmatch character
  // (if Distance = 0).
  var
    Code: word;
  begin
    S.DistanceBuffer[S.LastLiteral] := word(Distance);
    S.LiteralBuffer[S.LastLiteral] := byte(lc);
    inc(S.LastLiteral);
    if (Distance = 0) then
    begin
      // lc is the unmatched char
      inc(S.LiteralTree[lc].fc.Frequency);
    end
    else
    begin
      inc(S.Matches);
      // here, lc is the match length - MIN_MATCH
      dec(Distance);
      if Distance < 256 then
        Code := DistanceCode[Distance]
      else
        Code := DistanceCode[256 + (Distance shr 7)];
      inc(S.LiteralTree[LengthCode[lc] + LITERALS + 1].fc.Frequency);
      inc(S.DistanceTree[Code].fc.Frequency);
    end;

    Result := (S.LastLiteral = S.LiteralBufferSize - 1);
    // We avoid equality with LiteralBufferSize because stored blocks are restricted to 64K - 1 bytes.
  end;

  procedure InsertString(var S: TDeflateState; Str: cardinal;
    var MatchHead: cardinal);
  // Inserts Str into the dictionary and sets MatchHead to the previous head of the hash chain (the most recent String
  // with same hash key). All calls to to InsertString are made with consecutive input characters and the first MIN_MATCH
  // bytes of Str are valid (except for the last MIN_MATCH - 1 bytes of the input file).
  // Returns the previous length of the hash chain.
  begin
    S.InsertHash := ((S.InsertHash shl S.HashShift) xor
        (S.window[(Str) + (MIN_MATCH - 1)])) and S.HashMask;

    MatchHead := S.Head[S.InsertHash];
    S.Previous[(Str) and S.WindowMask] := MatchHead;
    S.Head[S.InsertHash] := word(Str);
  end;

const
  CMaxInsertLen = 5;
var
  Z: TZState;
  Overlay: TPAWord;
  // We overlay PendingBuffer and DistanceBuffer + LiteralBuffer. This works since the average
  // output Size for (length, distance) codes is <= 24 Bits.
  HashHead: cardinal; // head of the hash chain
  BlockFlush: Boolean; // set if current block must be flushed
  S: TDeflateState;
begin
  Result := 0;
  FillChar(Z, SizeOf(Z), 0);
  Z.NextInput := src;
  Z.AvailableInput := srcLen;
  Z.NextOutput := dst;
  Z.AvailableOutput := dstLen;
  Z.TotalInput := Z.TotalOutput;
  FillChar(S, SizeOf(TDeflateState), 0);
  try
    Z.State := @S;
    S.ZState := @Z;
    S.WindowSize := 1 shl CWindowBits;
    S.WindowMask := S.WindowSize - 1;
    S.HashBits := CMemLevel + 7;
    S.HashSize := 1 shl S.HashBits;
    S.HashMask := S.HashSize - 1;
    S.HashShift := (S.HashBits + MIN_MATCH - 1) div MIN_MATCH;
    GetMem(S.window, S.WindowSize * (2 * SizeOf(byte)));
    GetMem(S.Previous, S.WindowSize * SizeOf(word));
    GetMem(S.Head, S.HashSize * SizeOf(word));
    S.LiteralBufferSize := 1 shl (CMemLevel + 6); // 16K elements by default
    GetMem(Overlay, S.LiteralBufferSize * (SizeOf(word) + 2));
    S.PendingBuffer := TPAByte(Overlay);
    S.PendingBufferSize := S.LiteralBufferSize * (SizeOf(word) + 2);
    S.DistanceBuffer := @Overlay[S.LiteralBufferSize div SizeOf(word)];
    S.LiteralBuffer := @S.PendingBuffer[(1 + SizeOf(word))
      * S.LiteralBufferSize];
    S.PendingOutput := PByte(S.PendingBuffer);
    S.LiteralDescriptor.DynamicTree := @S.LiteralTree;
    S.LiteralDescriptor.StaticDescriptor := @StaticLiteralDescriptor;
    S.DistanceDescriptor.DynamicTree := @S.DistanceTree;
    S.DistanceDescriptor.StaticDescriptor := @StaticDistanceDescriptor;
    S.BitLengthDescriptor.DynamicTree := @S.BitLengthTree;
    S.BitLengthDescriptor.StaticDescriptor := @StaticBitLengthDescriptor;
    S.LastEOBLength := 8; // enough Lookahead for Inflate
    InitializeBlock(S);
    S.CurrentWindowSize := 2 * S.WindowSize;
    S.Head[S.HashSize - 1] := 0;
    FillChar(S.Head^, (S.HashSize - 1) * SizeOf(S.Head[0]), 0);
    S.PreviousLength := MIN_MATCH - 1;
    S.MatchLength := MIN_MATCH - 1;

    HashHead := 0;
    while true do
    begin
      // Make sure that we always have enough lookahead, except at the end of the input file. We need MAX_MATCH bytes
      // for the next match plus MIN_MATCH bytes to insert the String following the next match.
      if S.Lookahead < MIN_LOOKAHEAD then
      begin
        FillWindow(S);

        // flush the current block
        if S.Lookahead = 0 then
        begin
          FlushBlockOnly(S, true);
          if Z.AvailableOutput <> 0 then
            Result := Z.TotalOutput;
          break;
        end;
      end;

      // Insert the String Window[StringStart .. StringStart + 2] in the
      // dictionary and set HashHead to the head of the hash chain.
      if S.Lookahead >= MIN_MATCH then
        InsertString(S, S.StringStart, HashHead);

      // Find the longest match, discarding those <= PreviousLength.
      // At this point we have always MatchLength < MIN_MATCH.
      if (HashHead <> 0) and (S.StringStart - HashHead <=
          (S.WindowSize - MIN_LOOKAHEAD)) then
        S.MatchLength := LongestMatch(S, HashHead);
      if S.MatchLength >= MIN_MATCH then
      begin
        BlockFlush := TreeTally(S, S.StringStart - S.MatchStart,
          S.MatchLength - MIN_MATCH);
        dec(S.Lookahead, S.MatchLength);

        // Insert new strings in the hash table only if the match length
        // is not too large. This saves time but degrades compression.
        if (S.MatchLength <= CMaxInsertLen) and (S.Lookahead >= MIN_MATCH) then
        begin
          // String at StringStart already in hash table
          dec(S.MatchLength);
          repeat
            inc(S.StringStart);
            InsertString(S, S.StringStart, HashHead);
            // StringStart never exceeds WSize - MAX_MATCH, so there are always MIN_MATCH bytes ahead.
            dec(S.MatchLength);
          until S.MatchLength = 0;
          inc(S.StringStart);
        end
        else
        begin
          inc(S.StringStart, S.MatchLength);
          S.MatchLength := 0;
          S.InsertHash := S.window[S.StringStart];
          S.InsertHash := ((S.InsertHash shl S.HashShift)
              xor S.window[S.StringStart + 1]) and S.HashMask;
          // if Lookahead < MIN_MATCH, InsertHash is garbage, but it does not
          // matter since it will be recomputed at next Deflate call.
        end;
      end
      else
      begin
        // no match, output a literal byte
        BlockFlush := TreeTally(S, 0, S.window[S.StringStart]);
        dec(S.Lookahead);
        inc(S.StringStart);
      end;
      if BlockFlush then
      begin
        FlushBlockOnly(S, false);
        if S.ZState.AvailableOutput = 0 then
          break;
      end;
    end;
  except
    Result := 0;
  end;
  FreeMem(S.PendingBuffer);
  FreeMem(S.Head);
  FreeMem(S.Previous);
  FreeMem(S.window);
end;

function UnCompressMem(src, dst: Pointer; srcLen, dstLen: Integer): Integer;
var
  Z: TZState;
begin
  Result := 0;
  FillChar(Z, SizeOf(Z), 0);
  try
    Z.NextInput := src;
    Z.AvailableInput := srcLen;
    Z.NextOutput := dst;
    Z.AvailableOutput := dstLen;
    Z.State := InflateBlocksNew(Z, 1 shl CWindowBits);
    InflateBlockReset(Z.State^, Z);
    if InflateBlocks(Z.State^, Z, Z_BUF_ERROR) in [Z_OK, Z_STREAM_END] then
      Result := Z.TotalOutput;
    InflateBlockReset(Z.State^, Z);
  except
    Result := 0;
  end;
  FreeMem(Z.State.window);
  FreeMem(Z.State.hufts);
  FreeMem(Z.State);
end;

function UpdateCrc32(acrc32: cardinal; inBuf: Pointer;
  inLen: Integer): cardinal;
var
  i: Integer;
begin
  Result := acrc32;
{$IFDEF DYNAMIC_CRC_TABLE}
  // if we used a dynamic table, we assume we want shorter code Size
  for i := 1 to inLen do
  begin
    Result := crc32Tab[byte(Result xor PByte(inBuf)^)] xor (Result shr 8);
    inc(cardinal(inBuf));
  end;
{$ELSE}
  for i := 0 to (inLen shr 2) - 1 do
  begin
    Result := crc32Tab[byte(Result xor PByte(inBuf)^)] xor (Result shr 8);
    inc(cardinal(inBuf));
    Result := crc32Tab[byte(Result xor PByte(inBuf)^)] xor (Result shr 8);
    inc(cardinal(inBuf));
    Result := crc32Tab[byte(Result xor PByte(inBuf)^)] xor (Result shr 8);
    inc(cardinal(inBuf));
    Result := crc32Tab[byte(Result xor PByte(inBuf)^)] xor (Result shr 8);
    inc(cardinal(inBuf));
  end;
  for i := 0 to (inLen and 3) - 1 do
  begin
    Result := crc32Tab[byte(Result xor PByte(inBuf)^)] xor (Result shr 8);
    inc(cardinal(inBuf));
  end;
{$ENDIF}
end;

function CompressString(const data: String;
  failIfGrow: Boolean = false): String;
var
  i1: Integer;
begin
  SetLength(Result, 12 + Length(data) * 11 div 10 + 12);
  pInt64(Result)^ := Length(data);
  TPACardinal(Result)^[2] := not UpdateCrc32($FFFFFFFF, Pointer(data),
    Length(data));
  i1 := CompressMem(Pointer(data), PAnsiChar(Integer(Result) + 12),
    Length(data), Length(Result) - 12);
  if (i1 > 0) and ((12 + i1 < Length(data)) or (not failIfGrow)) then
    SetLength(Result, 12 + i1)
  else
    Result := '';
end;

function UncompressString(const data: String): String;
begin
  if Length(data) > 12 then
  begin
    SetLength(Result, PCardinal(data)^);
    SetLength(Result, UnCompressMem(PAnsiChar(Integer(data) + 12),
        Pointer(Result), Length(data) - 12, Length(Result)));
    if (Result <> '') and ((not UpdateCrc32($FFFFFFFF, Pointer(Result),
          Length(Result))) <> TPACardinal(data)^[2]) then
      Result := '';
  end
  else
    Result := '';
end;
{$IFDEF WIN32}

type
  splitInt64 = record
    loCard, hiCard: cardinal end;

    function CompressFile(const srcFile, dstFile: String;
      failIfGrow: Boolean = false): Boolean;

  var
    sf, df: dword;
    sm, dm: dword;
    sb, db: Pointer;
    sl, dl: int64;
    err: dword;

  begin
    Result := false;
    err := 0;
    try
      sf := CreateFile(Pointer(srcFile), GENERIC_READ,
        FILE_SHARE_READ or FILE_SHARE_WRITE, nil, OPEN_EXISTING, 0, 0);
      if sf <> INVALID_HANDLE_VALUE then
      begin
        df := CreateFile(Pointer(dstFile), GENERIC_READ or GENERIC_WRITE, 0,
          nil, CREATE_ALWAYS, 0, 0);
        if df <> INVALID_HANDLE_VALUE then
        begin
          sm := CreateFileMapping(sf, nil, PAGE_READONLY, 0, 0, nil);
          if sm <> 0 then
          begin
            splitInt64(sl).loCard := GetFileSize(sf, @splitInt64(sl).hiCard);
            dl := 12 + sl * 11 div 10 + 12;
            dm := CreateFileMapping(df, nil, PAGE_READWRITE,
              splitInt64(dl).hiCard, splitInt64(dl).loCard, nil);
            if dm <> 0 then
            begin
              sb := MapViewOfFile(sm, FILE_MAP_READ, 0, 0, 0);
              if sb <> nil then
              begin
                db := MapViewOfFile(dm, FILE_MAP_ALL_ACCESS, 0, 0, 0);
                if db <> nil then
                begin
                  pInt64(db)^ := sl;
                  dl := CompressMem(sb, Pointer(dword(db) + 12), sl, dl - 12);
                  Result := (dl > 0) and ((dl + 12 < sl) or (not failIfGrow));
                  if Result then
                    PCardinal(dword(db) + 8)^ := not UpdateCrc32($FFFFFFFF, sb,
                      sl);
                  UnmapViewOfFile(db);
                end
                else
                  err := GetLastError;
                UnmapViewOfFile(sb);
              end
              else
                err := GetLastError;
              CloseHandle(dm);
            end
            else
              err := GetLastError;
            CloseHandle(sm);
          end
          else
            err := GetLastError;
          if Result then
          begin
            inc(dl, 12);
            SetFilePointer(df, Integer(splitInt64(dl).loCard),
              @splitInt64(dl).hiCard, FILE_BEGIN);
            SetEndOfFile(df);
          end;
          CloseHandle(df);
          if not Result then
            Windows.DeleteFile(Pointer(dstFile));
        end
        else
          err := GetLastError;
        CloseHandle(sf);
      end
      else
        err := GetLastError;
    except
      SetFileAttributes(Pointer(dstFile), 0);
      Windows.DeleteFile(Pointer(dstFile));
      err := ERROR_ACCESS_DENIED;
    end;
    if not Result then
      SetLastError(err);
  end;

  function UncompressFile(const srcFile, dstFile: String;
    lastWriteTime: int64 = 0; attr: dword = 0): Boolean;

  var
    sf, df: dword;
    sm, dm: dword;
    sb, db: Pointer;
    sl, dl: int64;
    err: dword;

  begin
    Result := false;
    err := 0;
    try
      sf := CreateFile(Pointer(srcFile), GENERIC_READ,
        FILE_SHARE_READ or FILE_SHARE_WRITE, nil, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL or FILE_FLAG_SEQUENTIAL_SCAN, 0);
      if sf <> INVALID_HANDLE_VALUE then
      begin
        df := CreateFile(Pointer(dstFile), GENERIC_READ or GENERIC_WRITE, 0,
          nil, CREATE_ALWAYS, attr or FILE_FLAG_SEQUENTIAL_SCAN, 0);
        if df <> INVALID_HANDLE_VALUE then
        begin
          sm := CreateFileMapping(sf, nil, PAGE_READONLY, 0, 0, nil);
          if sm <> 0 then
          begin
            sb := MapViewOfFile(sm, FILE_MAP_READ, 0, 0, 0);
            if sb <> nil then
            begin
              dl := pInt64(sb)^;
              dm := CreateFileMapping(df, nil, PAGE_READWRITE,
                splitInt64(dl).hiCard, splitInt64(dl).loCard, nil);
              if dm <> 0 then
              begin
                db := MapViewOfFile(dm, FILE_MAP_ALL_ACCESS, 0, 0, 0);
                if db <> nil then
                begin
                  splitInt64(sl).loCard := GetFileSize(sf,
                    @splitInt64(sl).hiCard);
                  dl := UnCompressMem(Pointer(dword(sb) + 12), db, sl - 12, dl);
                  Result := (dl > 0) and ((not UpdateCrc32($FFFFFFFF, db, dl))
                      = PCardinal(dword(sb) + 8)^);
                  UnmapViewOfFile(db);
                end
                else
                  err := GetLastError;
                CloseHandle(dm);
              end
              else
                err := GetLastError;
              UnmapViewOfFile(sb);
            end
            else
              err := GetLastError;
            CloseHandle(sm);
          end
          else
            err := GetLastError;
          if Result then
          begin
            SetFilePointer(df, Integer(splitInt64(dl).loCard),
              @splitInt64(dl).hiCard, FILE_BEGIN);
            SetEndOfFile(df);
          end;
          if Result and (lastWriteTime <> 0) then
            SetFileTime(df, nil, nil, @lastWriteTime);
          CloseHandle(df);
          if Result then
          begin
            if (attr <> 0) and (GetVersion and $80000000 = 0) then
              SetFileAttributes(Pointer(dstFile), attr)
          end
          else
            Windows.DeleteFile(Pointer(dstFile));
        end
        else
          err := GetLastError;
        CloseHandle(sf);
      end
      else
        err := GetLastError;
    except
      SetFileAttributes(Pointer(dstFile), 0);
      Windows.DeleteFile(Pointer(dstFile));
      err := ERROR_ACCESS_DENIED;
    end;
    if not Result then
      SetLastError(err);
  end;

  function IsCompressedFileEqual(const uncomprFile, comprFile: String): Boolean;

  var
    size1, size2: int64;
    crc1, crc2: dword;

  begin
    Result := GetCompressedFileInfo(comprFile, size1, crc1)
      and GetUncompressedFileInfo(uncomprFile, size2, crc2) and
      (size1 = size2) and (crc1 = crc2);
  end;

  function GetCompressedFileInfo(const comprFile: String; var Size: int64;
    var crc32: dword): Boolean;

  var
    file_: dword;
    c1: dword;

  begin
    Result := false;
    crc32 := 0;
    file_ := CreateFile(Pointer(comprFile), GENERIC_READ,
      FILE_SHARE_READ or FILE_SHARE_WRITE, nil, OPEN_EXISTING, 0, 0);
    if file_ <> INVALID_HANDLE_VALUE then
    begin
      Result := ReadFile(file_, Size, 8, c1, nil) and (c1 = 8) and ReadFile
        (file_, crc32, 4, c1, nil) and (c1 = 4);
      CloseHandle(file_);
    end;
  end;

  function GetUncompressedFileInfo(const uncomprFile: String; var Size: int64;
    var crc32: dword): Boolean;

  var
    file_, map: dword;
    Buf: Pointer;

  begin
    Result := false;
    file_ := CreateFile(Pointer(uncomprFile), GENERIC_READ,
      FILE_SHARE_READ or FILE_SHARE_WRITE, nil, OPEN_EXISTING, 0, 0);
    if file_ <> INVALID_HANDLE_VALUE then
    begin
      splitInt64(Size).loCard := GetFileSize(file_, @splitInt64(Size).hiCard);
      map := CreateFileMapping(file_, nil, PAGE_READONLY, 0, 0, nil);
      if map <> 0 then
      begin
        Buf := MapViewOfFile(map, FILE_MAP_READ, 0, 0, 0);
        if Buf <> nil then
        begin
          crc32 := not UpdateCrc32($FFFFFFFF, Buf, Size);
          UnmapViewOfFile(Buf);
          Result := true;
        end;
        CloseHandle(map);
      end;
      CloseHandle(file_);
    end;
  end;
{$ENDIF}
  function GzCompress(src: Pointer; srcLen: Integer;
    const fName: String): cardinal;

  const
    gzheader: array [0 .. 2] of cardinal = ($88B1F, 0, 0);

  var
    F: file;
    dest: Pointer;
    destLen: cardinal;
    crc: cardinal;

  begin
    Result := 0;
{$I-}
    assign(F, fName);
    rewrite(F, 1);
    if ioresult <> 0 then
      Exit;
    try
      blockwrite(F, gzheader, 10);
      destLen := 12 + (srcLen * 11) div 10; // ensure enough space
      GetMem(dest, destLen);
      try
        destLen := CompressMem(src, dest, srcLen, destLen);
        blockwrite(F, dest^, destLen);
        crc := UpdateCrc32($FFFFFFFF, src, srcLen) xor $FFFFFFFF;
        blockwrite(F, crc, 4);
        blockwrite(F, srcLen, 4);
      finally
        FreeMem(dest);
      end;
    finally
      close(F);
    end;
{$I+} if ioresult <> 0 then
      Exit;
    Result := destLen + 18;
  end;
{$IFDEF WIN32}
  function Zip(const Zip: String; const files, zipAs: array of String;
    NoSubDirectories: Boolean = false): Boolean;

  var
    i1, i2, i3: Integer;
    dstFh: dword;
    srcFh: dword;
    ft: TFileTime;
    c1: dword;
    lfhr: TLocalFileHeader;
    srcBuf: Pointer;
    dstBuf: Pointer;
    Size: dword;
    zipRec: array of record name: String;
    fhr: TFileHeader;
  end;

lhr :
TLastHeader;

begin
  dstFh := CreateFile(Pointer(Zip), GENERIC_WRITE, 0, nil, CREATE_ALWAYS, 0, 0);
  Result := dstFh <> INVALID_HANDLE_VALUE;
  if Result then
  begin
    SetLength(zipRec, Length(files));
    i2 := 0;
    for i1 := 0 to high(files) do
      with zipRec[i2] do
      begin
        if i1 >= Length(zipAs) then
        begin
          name := files[i1];
          if NoSubDirectories then
            for i3 := Length(name) downto 1 do
              if name[i3] = '\' then
              begin
                Delete(name, 1, i3);
                break;
              end;
        end
        else
          name := zipAs[i1];
        srcFh := CreateFile(Pointer(files[i1]), GENERIC_READ, FILE_SHARE_READ,
          nil, OPEN_EXISTING, 0, 0);
        if srcFh <> INVALID_HANDLE_VALUE then
        begin
          Size := GetFileSize(srcFh, nil);
          srcBuf := Pointer(LocalAlloc(LPTR, Size));
          if srcBuf <> nil then
          begin
            dstBuf := Pointer(LocalAlloc(LPTR, Size * 11 div 10 + 12));
            if dstBuf <> nil then
            begin
              if ReadFile(srcFh, srcBuf^, Size, c1, nil) and (c1 = Size) then
              begin
                with lfhr, fileInfo do
                begin
                  signature := $04034B50 + 1;
                  dec(signature); // +1 to avoid finding it in the exe
                  neededVersion := $14;
                  flags := 0;
                  zzipMethod := 8;
                  zcrc32 := not UpdateCrc32(dword(-1), srcBuf, Size);
                  zzipSize := CompressMem(srcBuf, dstBuf, Size,
                    Size * 11 div 10 + 12);
                  zfullSize := Size;
                  nameLen := Length(name);
                  extraLen := 0;
                  GetFileTime(srcFh, nil, nil, @ft);
                  FileTimeToLocalFileTime(ft, ft);
                  FileTimeToDosDateTime(ft, zlastModDate, zlastModTime);
                end;
                with fhr do
                begin
                  signature := $02014B50 + 1;
                  dec(signature); // +1 to avoid finding it
                  madeBy := $14;
                  fileInfo := lfhr.fileInfo;
                  commentLen := 0;
                  firstDiskNo := 0;
                  intFileAttr := 0;
                  extFileAttr := GetFileAttributes(Pointer(files[i1]));
                  localHeadOff := SetFilePointer(dstFh, 0, nil, FILE_CURRENT);
                end;
                Result := WriteFile(dstFh, lfhr, SizeOf(lfhr), c1, nil) and
                  (c1 = SizeOf(lfhr)) and WriteFile(dstFh, Pointer(name)^,
                  Length(name), c1, nil) and (c1 = dword(Length(name)))
                  and WriteFile(dstFh, dstBuf^, lfhr.fileInfo.zzipSize, c1,
                  nil) and (c1 = lfhr.fileInfo.zzipSize);
                inc(i2);
              end;
              LocalFree(dword(dstBuf));
            end;
            LocalFree(dword(srcBuf));
          end;
          CloseHandle(srcFh);
        end;
        if not Result then
          break;
      end;
    Result := Result and (i2 > 0);
    if Result then
    begin
      with lhr do
      begin
        signature := $06054B50 + 1;
        dec(signature); // +1 to avoid finding it
        thisDisk := 0;
        headerDisk := 0;
        thisFiles := i2;
        totalFiles := i2;
        headerSize := 0;
        headerOffset := SetFilePointer(dstFh, 0, nil, FILE_CURRENT);
        commentLen := 0;
      end;
      for i1 := 0 to i2 - 1 do
        with zipRec[i1] do
        begin
          inc(lhr.headerSize, SizeOf(TFileHeader) + Length(name));
          if not(WriteFile(dstFh, fhr, SizeOf(fhr), c1,
              nil) and (c1 = SizeOf(fhr)) and WriteFile(dstFh, Pointer(name)^,
              Length(name), c1, nil) and (c1 = dword(Length(name)))) then
          begin
            Result := false;
            break;
          end;
        end;
      Result := Result and WriteFile(dstFh, lhr, SizeOf(lhr), c1, nil) and
        (c1 = SizeOf(lhr));
    end;
    CloseHandle(dstFh);
    if not Result then
      Windows.DeleteFile(Pointer(Zip));
  end;
end;
{$ENDIF}

procedure CreateVoidZip(const AFileName: String);
var
  H: THandle;
  lhr: TLastHeader;
begin
  FillChar(lhr, SizeOf(lhr), 0);
  lhr.signature := $06054B50 + 1;
  dec(lhr.signature); // +1 to avoid finding it in the exe
  H := FileCreate(AFileName);
  if H = INVALID_HANDLE_VALUE then
    Exit;
  FileWrite(H, lhr, SizeOf(lhr));
  FileClose(H);
end;
{$IFDEF DYNAMIC_CRC_TABLE}

{
  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.

  Polynomials over GF(2) are represented in binary, one bit per coefficient,
  with the lowest powers in the most significant bit.  Then adding polynomials
  is just exclusive-or, and multiplying a polynomial by x is a right shift by
  one.  If we call the above polynomial p, and represent a byte as the
  polynomial q, also with the lowest power in the most significant bit (so the
  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
  where a mod b means the remainder after dividing a by b.

  This calculation is done using the shift-register method of multiplying and
  taking the remainder.  The register is initialized to zero, and for each
  incoming bit, x^32 is added mod p to the register if the bit is a one (where
  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
  x (which is shifting right by one and adding x^32 mod p if the bit shifted
  out is a one).  We start with the highest power (least significant bit) of
  q and repeat for all eight bits of q.

  The table is simply the CRC of all possible eight bit values.  This is all
  the information needed to generate CRC's on data a byte at a time for all
  combinations of CRC register values and incoming bytes.
}
procedure InitCrc32Tab;
var
  i, N, crc: cardinal;
begin // this code is 49 bytes long, generating a 1KB table
  for i := 0 to 255 do
  begin
    crc := i;
    for N := 1 to 8 do
      if (crc and 1) <> 0 then
        // $edb88320 from polynomial p=(0,1,2,4,5,7,8,10,11,12,16,22,23,26)
        crc := (crc shr 1) xor $EDB88320
      else
        crc := crc shr 1;
    crc32Tab[i] := crc;
  end;
end;
{$ENDIF}
{$IFDEF Win32}
{ TZipRead }

constructor TZipRead.Create(BufZip: PByteArray; Size: cardinal);
var
  lhr: ^TLastHeader;
  H: ^TFileHeader;
  lfhr: ^TLocalFileHeader;
  i, J, L: Integer;
  P: PAnsiChar;
begin
  for i := 0 to 31 do
  begin // resources Size may be rounded up to alignment
    lhr := @BufZip[Size - SizeOf(lhr^)];
    if lhr^.signature + 1 = $06054B51 then // +1 to avoid finding it in the exe
      break;
    dec(Size);
    if Size <= SizeOf(lhr^) then
      break;
  end;
  if lhr^.signature + 1 <> $06054B51 then
  begin // +1 to avoid finding it
    UnMap;
    MessageBox(0, 'ZIP format', nil, MB_SYSTEMMODAL or MB_ICONERROR);
    Exit;
  end;
  if lhr^.headerOffset > Size then
    Exit;
  SetLength(Entry, lhr^.totalFiles); // fill Entry[] with the Zip headers
  H := @BufZip[lhr^.headerOffset];
  for i := 1 to lhr^.totalFiles do
  begin
    if H^.signature + 1 <> $02014B51 then
    begin // +1 to avoid finding it
      UnMap;
      MessageBox(0, 'ZIP format', nil, MB_SYSTEMMODAL or MB_ICONERROR);
      Exit;
    end;
    lfhr := @BufZip[H^.localHeadOff];
    with Entry[Count] do
    begin
      info := @lfhr^.fileInfo;
      P := PAnsiChar(lfhr) + SizeOf(lfhr^);
      data := P + info^.nameLen + info^.extraLen;
      // data are still mapped in memory
      if info^.nameLen >= High(Name) - 1 then // avoid GPF with huge Name[]
        L := High(Name) - 1
      else
        L := info^.nameLen;
      J := 0;
      repeat
        if P^ = '/' then // normalize path delimiter
          Name[J] := '\'
        else
          Name[J] := P^;
        inc(J);
        inc(P);
      until J = L;
      Name[J] := #0; // make ASCIIZ
      inc(cardinal(H),
        SizeOf(H^) + info^.nameLen + H^.fileInfo.extraLen + H^.commentLen);
      if (info^.zzipMethod in [0, 8]) and (Name[J - 1] <> '\') then
        inc(Count); // known methods: stored + deflate
    end;
  end;
end;

constructor TZipRead.Create(Instance: THandle; const ResName: String;
  ResType: PChar);
// locked resources are memory map of the executable -> direct access is easy
var
  HResInfo: THandle;
  HGlobal: THandle;
begin
  HResInfo := FindResource(Instance, PChar(ResName), ResType);
  if HResInfo = 0 then
    Exit;
  HGlobal := LoadResource(HInstance, HResInfo);
  if HGlobal <> 0 then
    // warning: resources Size may be rounded up to alignment
    Create(LockResource(HGlobal), SizeofResource(HInstance, HResInfo));
end;

constructor TZipRead.Create(const AFileName: TFileName;
  ZipStartOffset, Size: cardinal; ShowMessageBoxOnError: Boolean);
var
  i, ExeOffset: Integer;
begin
  file_ := CreateFile(Pointer(AFileName), GENERIC_READ, FILE_SHARE_READ, nil,
    OPEN_EXISTING, 0, 0);
  if file_ = INVALID_HANDLE_VALUE then
    Exit; // file doesn't exist -> leave no Entry[] (Count=0)
  if Size = 0 then
    Size := GetFileSize(file_, nil);
  map := CreateFileMapping(file_, nil, PAGE_READONLY, 0, 0, nil);
  if map = 0 then
  begin
    UnMap;
    if ShowMessageBoxOnError then
      MessageBox(0, Pointer(AFileName), 'No File',
        MB_SYSTEMMODAL or MB_ICONERROR);
    Exit;
  end;
  Buf := MapViewOfFile(map, FILE_MAP_READ, 0, 0, 0);
  ExeOffset := -1;
  for i := ZipStartOffset to Size - 5 do
    if PCardinal(@Buf[i])^ + 1 = $04034B51 then
    begin // +1 to avoid finding it in the exe
      ExeOffset := i;
      break;
    end;
  if ExeOffset < 0 then
  begin
    UnMap;
    if ShowMessageBoxOnError then
      MessageBox(0, 'No ZIP found', nil, MB_SYSTEMMODAL or MB_ICONERROR);
    Exit;
  end;
  fZipStartOffset := ExeOffset;
  Create(@Buf[ExeOffset], Integer(Size) - ExeOffset);
end;

procedure TZipRead.UnMap;
begin
  Count := 0;
  if file_ <> INVALID_HANDLE_VALUE then
  begin
    if map <> 0 then
    begin
      UnmapViewOfFile(Buf);
      CloseHandle(map);
    end;
    CloseHandle(file_);
    file_ := INVALID_HANDLE_VALUE;
  end;
  Buf := nil;
end;

destructor TZipRead.Destroy;
begin
  UnMap;
  inherited;
end;

function TZipRead.NameToIndex(const aName: AnsiString): Integer;
begin
  if (self <> nil) and (aName <> '') then
    for Result := 0 to Count - 1 do
      if StrIComp(Entry[Result].Name, Pointer(aName)) = 0 then
        Exit;
  Result := -1;
end;

function TZipRead.UnZip(AIndex: Integer): AnsiString;
var
  Len: cardinal;
begin
  Result := ''; // somewhat faster is memory is reallocated each time
  if cardinal(AIndex) >= cardinal(Count) then
    Exit;
  with Entry[AIndex] do
  begin
    SetLength(Result, info^.zfullSize);
    if info^.zzipMethod = 0 then
    begin // stored method
      Len := info^.zfullSize;
      Move(data^, Pointer(Result)^, Len);
    end
    else // deflate method
      Len := UnCompressMem(data, Pointer(Result), info^.zzipSize, info^.zfullSize);

    if (Len <> info^.zfullSize) or (info^.zcrc32 <> not UpdateCrc32(dword(-1), Pointer(Result), info^.zfullSize)) then
    begin
      MessageBoxA(0, 'CRC', Name, 0);
      Result := '';
    end;
  end;
end;

function ForceDirectories(const Dir: String): Boolean;
begin
  if (Length(Dir) < 3) or DirectoryExists(Dir) or (ExtractFileDir(Dir) = Dir) then // avoid 'x:\' problem.
    Result := true
  else
    Result := ForceDirectories(ExtractFileDir(Dir)) and CreateDir(Dir);
end;

function TZipRead.CheckFile(AIndex: Integer; DestPath: String): Boolean;
var
  F, map: THandle;
  Buf: Pointer;
  Size: cardinal;
begin
  Result := false;
  if (cardinal(AIndex) >= cardinal(Count)) or (DestPath = '') then
    Exit;
  if DestPath[Length(DestPath)] <> '\' then
    DestPath := DestPath + '\';
  F := CreateFile(Pointer(DestPath + Entry[AIndex].Name), GENERIC_READ, FILE_SHARE_READ, nil, OPEN_EXISTING, 0, 0);
  if F <> INVALID_HANDLE_VALUE then
    with Entry[AIndex] do
      try
        Size := GetFileSize(F, nil);
        if Size <> info^.zfullSize then
          Exit;
        if Size = 0 then
          Result := true
        else
        begin
          map := CreateFileMapping(F, nil, PAGE_READONLY, 0, 0, nil);
          if map = 0 then
            Exit;
          Buf := MapViewOfFile(map, FILE_MAP_READ, 0, 0, 0);
          if (Buf <> nil) and (info^.zcrc32 = not UpdateCrc32(dword(-1), Buf,
              info^.zfullSize)) then
            Result := true;
          UnmapViewOfFile(Buf);
          CloseHandle(map);
        end;
      finally
        CloseHandle(F);
      end;
end;

function TZipRead.UnZipFile(AIndex: Integer; DestPath: String;
  ForceWriteFlush: Boolean): Boolean;
var
  N, F: String;
  Buf: Pointer;
{$IFDEF TRIMDIRECTORYNAME}
  i: Integer;
{$ENDIF}
  fFileSize, Len: cardinal;
  H: THandle;
  fFileTime, dFileTime: TFileTime;
begin
  Result := false;
  if (cardinal(AIndex) >= cardinal(Count)) or (DestPath = '') then
    Exit;
  if DestPath[Length(DestPath)] = '\' then
    SetLength(DestPath, Length(DestPath) - 1);
  if not DirectoryExists(DestPath) then
    Exit;
  if DestPath[Length(DestPath)] <> '\' then
    DestPath := DestPath + '\';
  with Entry[AIndex] do
  begin
    DosDateTimeToFileTime(info^.zlastModDate, info^.zlastModTime, dFileTime);
    N := Name;
{$IFDEF TRIMDIRECTORYNAME}
    i := pos('\', N);
    if i > 0 then
      Delete(N, 1, i); // trim directory name
{$ENDIF}
    F := DestPath + N;
    H := FileOpen(F, fmOpenRead);
    if H <> INVALID_HANDLE_VALUE then
    begin
      GetFileTime(H, nil, nil, @fFileTime);
      FileTimeToLocalFileTime(fFileTime, fFileTime);
      fFileSize := GetFileSize(H, nil);
      FileClose(H);
      if (int64(dFileTime) = int64(fFileTime)) and
        (info^.zfullSize = fFileSize) then
      begin
        Result := true;
        Exit; // good file is already there: don't overwrite for nothing
      end;
      while not Windows.DeleteFile(Pointer(F)) do // delete wrong version
        MessageBox(0,
          Pointer('File ' + UpperCase(N)
              + ' is still in use.'#13#13 + 'Please Close it for update.'),
          nil, MB_ICONERROR);
    end;
    ForceDirectories(ExtractFileDir(F));
    H := FileCreate(F);
    if H <> INVALID_HANDLE_VALUE then
      try
        if info^.zzipMethod = 0 then
        begin // stored method
          if (info^.zcrc32 <> not UpdateCrc32(dword(-1), data,
              info^.zfullSize)) then
          begin
            MessageBox(0, 'CRC', Pointer(N), 0);
            Exit;
          end;
          FileWrite(H, data^, info^.zfullSize);
        end
        else
        begin // deflate method
          GetMem(Buf, info^.zfullSize);
          try
            Len := UnCompressMem(data, Buf, info^.zzipSize, info^.zfullSize);
            if (Len <> info^.zfullSize) or
              (info^.zcrc32 <> not UpdateCrc32(dword(-1), Buf,
                info^.zfullSize)) then
            begin
              MessageBox(0, 'CRC', Pointer(N), 0);
              Exit;
            end;
            FileWrite(H, Buf^, info^.zfullSize);
          finally
            FreeMem(Buf);
          end;
        end;
        if LocalFileTimeToFileTime(dFileTime, fFileTime) and SetFileTime(H,
          @fFileTime, @fFileTime, @fFileTime) then
          Result := true;
        if ForceWriteFlush then
          FlushFileBuffers(H);
      finally
        FileClose(H);
      end;
  end;
end;

function TZipRead.GetInitialExeContent: AnsiString;
begin
  if (self = nil) or (Buf = nil) or (Count = 0) or (ZipStartOffset = 0) then
    Result := ''
  else
    SetString(Result, PAnsiChar(Buf), ZipStartOffset);
end;
{$ENDIF}
{ TZipWrite }

procedure TZipWrite.AddDeflated(const AFileName: AnsiString; Buf: Pointer;
  Size, CompressLevel, FileAge: Integer);
var
  tmp: Pointer;
  tmpsize: Integer;
begin
  if (self = nil) or (Handle = 0) or (Handle = Integer(INVALID_HANDLE_VALUE))
    then
    Exit;
  if Count >= Length(Entry) then
    SetLength(Entry, Length(Entry) + 20);
  with Entry[Count] do
  begin
    name := AFileName;
    with fhr, fileInfo do
    begin
      signature := $02014B50 + 1;
      dec(signature); // +1 to avoid finding it in the exe
      madeBy := $14;
      neededVersion := $14;
      nameLen := Length(name);
      zcrc32 := not UpdateCrc32(dword(-1), Buf, Size);
      zfullSize := Size;
      zzipMethod := 8; // deflate
      PInteger(@zlastModTime)^ := FileAge;
      localHeadOff := SetFilePointer(Handle, 0, nil, FILE_CURRENT)
        - fAppendOffset;
      tmpsize := (Size * 11) div 10 + 12;
      GetMem(tmp, tmpsize);
      zzipSize := CompressMem(Buf, tmp, Size, tmpsize);
      FileWrite(Handle, fMagic, 4);
      FileWrite(Handle, fileInfo, SizeOf(fileInfo));
      FileWrite(Handle, Pointer(name)^, nameLen);
      FileWrite(Handle, tmp^, zzipSize); // write stored data
      FreeMem(tmp);
    end;
  end;
  inc(Count);
end;

procedure TZipWrite.AddDeflated(const AFileName: AnsiString; RemovePath: Boolean; CompressLevel: Integer);
var
  H: THandle;
  Buf: Pointer;
  Size: Integer;
  Time: TFileTime;
  ZipName: String;
  FileTime: LongRec;
begin
  H := FileOpen(AFileName, fmOpenRead or fmShareDenyNone);
  if H = INVALID_HANDLE_VALUE then
    Exit;
  if RemovePath then
    ZipName := ExtractFileName(AFileName)
  else
    ZipName := AFileName;
  GetFileTime(H, nil, nil, @Time);
  FileTimeToLocalFileTime(Time, Time);
  FileTimeToDosDateTime(Time, FileTime.Hi, FileTime.Lo);
  Size := GetFileSize(H, nil);
  GetMem(Buf, Size);
  FileRead(H, Buf^, Size);
  AddDeflated(ZipName, Buf, Size, CompressLevel, Integer(FileTime));
  FreeMem(Buf);
  FileClose(H);
end;

procedure TZipWrite.AddFromZip(const ZipEntry: TZipEntry);
begin
  if (self = nil) or (Handle = 0) or (Handle = Integer(INVALID_HANDLE_VALUE))
    then
    Exit;
  if Count >= Length(Entry) then
    SetLength(Entry, Length(Entry) + 20);
  with Entry[Count] do
  begin
    name := ZipEntry.Name;
    with fhr do
    begin
      signature := $02014B50 + 1;
      dec(signature); // +1 to avoid finding it in the exe
      madeBy := $14;
      fileInfo := ZipEntry.info^;
      fileInfo.nameLen := Length(name);
      localHeadOff := SetFilePointer(Handle, 0, nil, FILE_CURRENT)
        - fAppendOffset;
      FileWrite(Handle, fMagic, 4);
      FileWrite(Handle, fileInfo, SizeOf(fileInfo));
      FileWrite(Handle, Pointer(name)^, fileInfo.nameLen);
      FileWrite(Handle, ZipEntry.data^, fileInfo.zzipSize);
    end;
  end;
  inc(Count);
end;

procedure TZipWrite.AddStored(const AFileName: AnsiString; Buf: Pointer;
  Size, FileAge: Integer);
begin
  if (self = nil) or (Handle = 0) or (Handle = Integer(INVALID_HANDLE_VALUE))
    then
    Exit;
  if Count >= Length(Entry) then
    SetLength(Entry, Length(Entry) + 20);
  with Entry[Count] do
  begin
    name := AFileName;
    with fhr, fileInfo do
    begin
      signature := $02014B50 + 1;
      dec(signature); // +1 to avoid finding it in the exe
      madeBy := $14;
      neededVersion := $14;
      nameLen := Length(name);
      zcrc32 := not UpdateCrc32(dword(-1), Buf, Size);
      zfullSize := Size;
      zzipSize := Size;
      PInteger(@zlastModTime)^ := FileAge;
      localHeadOff := SetFilePointer(Handle, 0, nil, FILE_CURRENT) - fAppendOffset;
      FileWrite(Handle, fMagic, 4);
      FileWrite(Handle, fileInfo, SizeOf(fileInfo));
      FileWrite(Handle, Pointer(name)^, nameLen);
      FileWrite(Handle, Buf^, Size); // write stored data
    end;
  end;
  inc(Count);
end;

procedure TZipWrite.Append(const Content: AnsiString);
begin
  if (self = nil) or (Handle = 0) or (Handle = Integer(INVALID_HANDLE_VALUE))
    or (fAppendOffset <> 0) then
    Exit;
  fAppendOffset := Length(Content);
  FileWrite(Handle, Pointer(Content)^, fAppendOffset);
end;

constructor TZipWrite.Create(const AFileName: TFileName);
begin
  Handle := FileCreate(AFileName);
  fFileName := AFileName;
  fMagic := $04034B50 + 1; // +1 to avoid finding it in the exe
  dec(fMagic);
end;

destructor TZipWrite.Destroy;
var
  lhr: TLastHeader;
  i: Integer;
begin
  FillChar(lhr, SizeOf(lhr), 0);
  lhr.signature := $06054B50 + 1;
  dec(lhr.signature); // +1 to avoid finding it in the exe
  lhr.thisFiles := Count;
  lhr.totalFiles := Count;
  lhr.headerOffset := SetFilePointer(Handle, 0, nil, FILE_CURRENT) - fAppendOffset;
  for i := 0 to Count - 1 do
    with Entry[i] do
    begin
      // assert(fhr.fileInfo.nameLen=length(name));
      inc(lhr.headerSize, SizeOf(TFileHeader) + fhr.fileInfo.nameLen);
      FileWrite(Handle, fhr, SizeOf(fhr));
      FileWrite(Handle, Pointer(Name)^, fhr.fileInfo.nameLen);
    end;
  FileWrite(Handle, lhr, SizeOf(lhr));
  SetEndOfFile(Handle);
  FileClose(Handle);
  { with TZipRead.Create(fFileName) do
    try
    assert(Count=self.Count);
    for i := 0 to Count-1 do
    assert(Entry[i].Name=self.Entry[i].Name);
    finally
    Free;
    end; }
  inherited;
end;

initialization

{$IFDEF DYNAMIC_CRC_TABLE}
InitCrc32Tab;
{$ENDIF}

end.
